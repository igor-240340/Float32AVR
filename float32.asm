;
; float32avr
;
; Библиотека подпрограмм для работы с числами в формате бинарной плавающей точки одинарной точности.
; Кроме арифметики содержит вспомогательные подпрограммы для конвертации из ASCII и в ASCII.
;
; Copyright (c) 2024 Igor Voytenko <igor.240340@gmail.com>
;
; Частичная совместимость с IEEE 754:
; - не реализованы спец. значения: inf, nan.
; - не реализованы денормализованные числа.
; - реализован только один режим округления: к ближайшему/к четному.
; - реализован только положительный ноль.
;
; Тем не менее, граничные значения экспоненты -127 и 128 (0 и 255 в коде со смещением)
; остаются зарезервированными для спец. значений и денормализованных чисел
; чтобы можно было довести до полной совместимости в будущем
; а также для удобства тестирования и сравнения с эталонной IEEE 754 реализацией прямо сейчас.
;
; Обработка исключительных ситуаций.
; В случае возникновения исключительной ситуации (деление на ноль, переполнение)
; происходит прыжок на адрес, который должен быть предварительно загружен в z-регистр перед вызовом подпрограммы.
            ;
            ; Байты исходной мантиссы делимого,
            ; расширенные GUARD-байтом для безопасного сдвига влево.
            .DEF MANTA0=R8              
            .DEF MANTA1=R9              
            .DEF MANTA2=R10             
            .DEF MANTAG=R2              

            ;
            ; Байты исходной мантиссы делителя,
            ; Расширенные GUARD-байтом для формирования доп. кода отрицательной мантиссы.
            .DEF MANTB0=R12             
            .DEF MANTB1=R13             
            .DEF MANTB2=R14             
            .DEF MANTBG=R3              

            ;
            ; Байты доп. кода отрицательной мантиссы делителя.
            .DEF MANTB0NEG=R4
            .DEF MANTB1NEG=R5
            .DEF MANTB2NEG=R6
            .DEF MANTBGNEG=R7

            ;
            ; Расширенные экспоненты.
            .DEF EXPA0=R11                  ; Первый операнд.
            .DEF EXPA1=R20                  ;
            .DEF EXPR0=R11                  ; Результат.
            .DEF EXPR1=R20                  ;
            .DEF EXPB0=R15                  ; Второй операнд.
            .DEF EXPB1=R21                  ;

            ;
            ; Байты мантиссы частного.
            .DEF Q0=R22
            .DEF Q1=R23
            .DEF Q2=R24
            .DEF Q3=R25

            .EQU QDIGITS=24+2               ; Количество цифр частного к вычислению: 24 + R + G + S (S определяется вне цикла).

            .DEF STEPS=R17                  ; Счетчик цикла.

            .EQU RGSMASK=0b00000111         ; Маска для извлечения rgs-битов при округлении.
            .DEF RGSBITS=R18                ; Дополнительные биты мантиссы частного + sticky-бит для корректного округления.

            .DEF RSIGN=R0                   ; Знак результата (частное/произведение/алгебраическая сумма).

            ;
            ; Мантисса произведения.
            .DEF MANTP0=R17
            .DEF MANTP1=R18
            .DEF MANTP2=R19
            .DEF MANTP3=R23
            .DEF MANTP4=R24
            .DEF MANTP5=R25
            .DEF GUARD=R7                  ; GUARD-регистр для временного хранения R-бита мантиссы произведения.

            .DEF STATUS0=R5                ; Регистр статуса после операции над младшим байтом.
            .DEF STATUS1=R6                ; Регистр статуса после операции над старшим байтом.
            .DEF SREGACC=R17               ; Регистр статуса после нескольких операций. например, побитовое и регистра status.

;
; Делит два числа по схеме с неподвижным делителем без восстановления остатка.
;
; Делимое ожидается в регистрах: R11, R10, R9, R8.
; Делитель ожидается в регистрах: R15, R14, R13, R12. 
; Частное помещается на место делимого: R11, R10, R9, R8.
FDIV32:     ;
            ; Фильтрация операндов.
            CLR R16                     ;
            OR R16,R12                  ;
            OR R16,R13                  ;
            OR R16,R14                  ;
            OR R16,R15                  ;
            IN R16,SREG                 ; 
            SBRC R16,SREG_Z             ; Делитель равен нулю?
            IJMP                        ; Да, выбрасываем ошибку. Делимое при этом может быть как нулевым так и ненулевым - оба варианта некорректны.

            CLR R16                     ; Нет, проверяем делимое.
            OR R16,R8                   ;
            OR R16,R9                   ;
            OR R16,R10                  ;
            OR R16,R11                  ;
            IN R16,SREG                 ;
            SBRC R16,SREG_Z             ; Делимое равно нулю?
            RJMP SETZERO                ; Да, возвращаем ноль.
                                        ; Нет, оба операнда ненулевые, вычисляем частное.
            
            ;
            ; Определение знака частного.
            MOV RSIGN,R11               ; Копируем старший байт делимого.
            MOV R1,R15                  ; Копируем старший байт делителя.
            LDI R16,0b10000000          ; Загружаем маску знака.
            AND RSIGN,R16               ; Извлекаем знак делимого.
            AND R1,R16                  ; Извлекаем знак делителя.
            EOR RSIGN,R1                ; Определяем знак частного.

            ;
            ; Распаковка делимого.
            ROL R10                     ; MSB мантиссы делимого содержит lsb экспоненты. Сдвигаем его в бит переноса.
            ROL R11                     ; Избавляемся от знака делимого и восстанавливаем младший бит экспоненты.
            ROR R10                     ; Возвращаем на место старший байт мантиссы делимого.
            OR R10,R16                  ; Восстанавливаем скрытую единицу мантиссы.

            ;
            ; Распаковка делителя.
            ROL R14                     ; То же самое для делителя.
            ROL R15                     ; 
            ROR R14                     ; 
            OR R14,R16                  ;

            ;
            ; Вычисление экспоненты частного.
            CLR EXPA1
            CLR EXPB1
            
            COM EXPB0                   ; Формируем доп. код экспоненты делителя.
            COM EXPB1                   ;
            LDI R16,1                   ; 
            ADD EXPB0,R16               ; 
            LDI R16,0                   ;
            ADC EXPB1,R16               ;

            ADD EXPA0,EXPB0             ; EXPA=EXPA-EXPB.
            ADC EXPA1,EXPB1             ;
            LDI R16,127                 ; Восстанавливаем результат в коде со смещением.
            ADD EXPA0,R16               ; 
            LDI R16,0                   ;
            ADC EXPA1,R16               ;
            
            ;
            ; Формирование доп. кода мантиссы делителя.
            CLR MANTAG                  ;
            CLR MANTBG                  ;

            MOV MANTB0NEG,MANTB0        ; Копируем положительную мантиссу делителя.
            MOV MANTB1NEG,MANTB1        ;
            MOV MANTB2NEG,MANTB2        ;
            MOV MANTBGNEG,MANTBG        ;

            COM MANTB0NEG               ; Поскольку 2^N-|B|=(2^N-1-|B|)+1=COM(|B|)+1,
            COM MANTB1NEG               ; то инвертируем биты положительной мантиссы
            COM MANTB2NEG               ;
            COM MANTBGNEG               ;

            LDI R16,1                   ; и прибавляем единицу,
            ADD MANTB0NEG,R16           ; не забывая про возможное появление бита переноса.
            LDI R16,0                   ;
            ADC MANTB1NEG,R16           ; 
            ADC MANTB2NEG,R16           ; 
            ADC MANTBGNEG,R16           ;

            ;
            ; Вычисление мантиссы частного.
            LDI STEPS,QDIGITS           ; Количество шагов равно количеству вычисляемых цифр частного.
            CLR Q0                      ; Зануляем мантиссу частного.
            CLR Q1                      ;
            CLR Q2                      ;
            CLR Q3                      ;

SUBMANTB:   ADD MANTA0,MANTB0NEG        ; Вычитаем из мантиссы делимого или остатка
            ADC MANTA1,MANTB1NEG        ; мантиссу делителя,
            ADC MANTA2,MANTB2NEG        ; умноженную на вес
            ADC MANTAG,MANTBGNEG        ; очередной цифры частного.

CALCDIGIT:  IN R16,SREG                 ;
            SBRS R16,SREG_N             ; Остаток отрицательный?
            SBR Q0,1                    ; Нет, устанавливаем текущую цифру частного в 1.

            DEC STEPS                   ; Вычислены все цифры частного?
            BREQ RESTPOSREM             ; Да, восстанавливаем последний положительный остаток.

            CLC                         ; Освобождаем и зануляем LSB для следующей цифры частного.
            ROL Q0                      ;
            ROL Q1                      ; 
            ROL Q2                      ;
            ROL Q3                      ;

            CLC                         ; Сдвигаем остаток влево вместе с виртуальной
            ROL MANTA0                  ; разрядной сеткой, которая привязана к нему.
            ROL MANTA1                  ; Неподвижная мантисса делителя в этой сетке
            ROL MANTA2                  ; станет эквивалентна умноженной на вес следующей
            ROL MANTAG                  ; младшей цифры частного, которую мы будем выяснять.

            IN R16,SREG                 ;
            SBRS R16,SREG_N             ; Остаток положительный?
            RJMP SUBMANTB               ; Да, отнимаем мантиссу делителя.
            ADD MANTA0,MANTB0           ; Нет, прибавляем мантиссу делителя.
            ADC MANTA1,MANTB1           ;
            ADC MANTA2,MANTB2           ;
            ADC MANTAG,MANTBG           ;
            RJMP CALCDIGIT              ; Определяем следующую цифру частного.

RESTPOSREM: IN R16,SREG                 ;
            SBRS R16,SREG_N             ; Последний остаток уже положительный?
            RJMP CALCSTICKY             ; Да, переходим к вычислению sticky-бита.
            ADD MANTA0,MANTB0           ; Нет, восстанавливаем до последнего положительного.
            ADC MANTA1,MANTB1           ;
            ADC MANTA2,MANTB2           ;
            ADC MANTAG,MANTBG           ;

            ;
            ; Вычисление sticky-бита для корректного округления к ближайшему.
            ;
            ; Если остаток ненулевой, значит справа от частного существуют ненулевые биты.
            ; S=1, R>0
            ; S=0, R=0
CALCSTICKY: COM MANTA0                  ; Вычисление доп. кода остатка.
            COM MANTA1                  ; Инвертируем остаток: 2^N-1-A < 2^N (для всех значений A).
            COM MANTA2                  ; Прибавляем единицу: 2^N-1-A+1=2^N-A < 2^N (только для ненулевых A).
            COM MANTAG                  ; Следовательно, только при нулевом остатке
            LDI R16,1                   ; из старшего байта будет единица переноса.
            ADD MANTA0,R16              ; А это значит, что S=NOT(C), где C - бит переноса.
            LDI R16,0                   ;
            ADC MANTA1,R16              ;
            ADC MANTA2,R16              ;
            ADC MANTAG,R16              ;

            IN R16,SREG                 ; Конвертируем бит переноса в S-бит.
            LDI R17,1                   ; 
            EOR R16,R17                 ;
            OUT SREG,R16                ;

            ROL Q0                      ; Добавляем справа к мантиссе частного значение S-бита.
            ROL Q1                      ; 
            ROL Q2                      ;
            ROL Q3                      ;

            ;
            ; Нормализация мантиссы частного.
            ;
            ; Мантисса частного лежит в интервале (0.5, 2)
            ; поэтому денормализация возможна только на 1 разряд вправо.
            SBRC Q3,2                   ; Целочисленная единица в частном есть?
            RJMP CHECKEXP               ; Да, частное нормализовано, проверяем экспоненту.
            CLC                         ; Нет, нормализуем влево на 1 разряд.
            ROL Q0                      ;
            ROL Q1                      ;
            ROL Q2                      ;
            ROL Q3                      ;
                                        
            LDI R16,0xFF                ; Уменьшаем экспоненту частного на 1.
            LDI R17,0XFF                ;
            ADD EXPR0,R16               ;
            ADC EXPR1,R17               ;

            ;
            ; Проверка экспоненты на переполнение/антипереполнение.
            ;
            ; Переполнение: EXP > 127+127=254. По стандарту - установка inf. Текущая реализация - выброс исключения.
            ; Антипереполнение: EXP < -126+127=1. По стандарту - переход к денормализованному числу. Текущая реализация - установка частного в ноль.
CHECKEXP:   MOV R18,EXPR0               ; Копируем расширенную экспоненту частного.
            MOV R19,EXPR1               ;

            LDI R16,255                 ; Формируем -1 в доп. коде.
            LDI R17,255                 ; 
            ADD R16,R18                 ; Если истинная экспонента меньше минимального представимого значения (-126),
            ADC R17,R19                 ; то в коде со смещением после вычитания единицы будет получено отрицательное число.
            IN R16,SREG                 ; 
            SBRC R16,SREG_N             ; Экспонента в прямом коде меньше -126?
            RJMP SETZERO                ; Да, антипереполнение, возвращаем ноль.
                                        ; 
            LDI R16,1                   ; Нет, проверяем экспоненту на переполнение.
            LDI R17,0                   ; Если истинная экспонента больше максимального представимого значения (127),
            ADD R16,R18                 ; то в коде со смещением после прибавления единицы старший байт расширенной экспоненты
            ADC R17,R19                 ; будет отличен от нуля.
            COM R17                     ; Если старший байт содержит ноль,
            LDI R16,1                   ; то вычисление доп. кода даст ноль.
            ADD R16,R17                 ; Экспонента в прямом коде меньше 128?
            BREQ ROUND                  ; Да, переполнения нет, переходим к округлению.
            IJMP                        ; Нет, переполнение, прыжок на обработчик ошибок, указанный в Z.

            ;
            ; Округление к ближайшему.
            ;
            ; Возможные сочетания битов RS. Для краткости GUARD-бит здесь не учитывается, иллюстрируется сама идея округления.
            ; RS
            ; --
            ; 00: Точное значение. |ERR| = 0.
            ; 01: Отбрасываем. |ERR| < 2^-24=2^-23/2=ULP/2. Ошибка меньше половины веса последнего разряда мантиссы одинарной точности.
            ; 10: Если такая ситуация имеет место, то делимое имеет ненулевые разряды за пределами доступной сетки, что невозможно в нашем случае (обоснование - в доках).
            ; 11: Отбрасываем и прибавляем 2^-23. |ERR| < 2^-24=ULP/2.
            ;
            ; Комментарии к последнему случаю:
            ; Q - истинная мантисса частного (бесконечная точность).
            ; Q' - округленное значение.
            ; Q' = Q-(2^-24+A)+2^-23, где A - биты за пределами сетки вправо от R, индикатором которых является S-БИТ, следовательно, A < 2^-24.
            ; 2^-23 = 2^-24+2^-24 = 2^-24+(A+B), где (A+B) = 2^-24, но A > 0, следовательно B < 2^-24.
            ; тогда можем записать Q' = Q-2^-24-A+2^-24+A+B = Q+B, где B < 2^-24.
            ; поэтому в последнем случае |ERR| < 2^-24=ULP/2.
ROUND:      MOV RGSBITS,Q0              ; Извлекаем RGS-биты из младшего байта мантиссы частного.
            LDI R16,RGSMASK             ;
            AND RGSBITS,R16             ;

            LDI STEPS,3                 ; Отбрасываем RGS-биты в мантиссе частного.
RSHIFT3:    CLC                         ; Мы вычисляли 26 цифр частного + S-бит,
            ROR Q3                      ; поэтому после сдвига все цифры мантиссы частного
            ROR Q2                      ; поместятся в трех младших байтах.
            ROR Q1                      ;
            ROR Q0                      ;
            DEC STEPS                   ;
            BRNE RSHIFT3                ;

            LDI R16,0xFC                ; Если в RGS установлен бит R и есть ненулевые биты справа от него,
            ADD RGSBITS,R16             ; тогда в RGS находится число больше 4, а значит, отбрасывая RGS
            IN R16,SREG                 ; мы получаем ошибку больше ULP/2.
            SBRC R16, SREG_N            ; Отбросили больше ULP/2?
            RJMP PACK                   ; Нет, пакуем частное.

            LDI R16,1                   ; Да, прибавляем 2^-23.
            ADD Q0,R16                  ; Переполнения при этом не будет (более детальное обоснование - в доках).
            LDI R16,0                   ; Нормализованная мантисса, которая даст переполнение - больше максимальной возможной нормализованной мантиссы,
            ADC Q1,R16                  ; а денормализованная мантисса, которая даст после нормализации переполнение,
            ADC Q2,R16                  ; может быть получена только если делимое имеет ненулевые разряды за пределами одинарной точности, что невозможно в нашем случае.

            ;
            ; Упаковка знака, мантиссы и экспоненты частного и запись на место делимого.
            ; Нормализованная и округленная мантисса частного теперь занимает 3 младших байтах.
PACK:       ROL Q0                      ; Сдвигаем мантиссу влево, убирая целочисленную единицу.
            ROL Q1                      ;
            ROL Q2                      ;

            CLC                         ; Выдвигаем вправо LSB экспоненты в разряд переноса,
            ROR EXPR0                   ; одновременно освобождая MSB под знак.

            ROR Q2                      ; Возвращаем мантиссу на место
            ROR Q1                      ; с LSB экспоненты вместо целочисленной единицы.
            ROR Q0                      ;

            OR EXPR0,RSIGN              ; Устанавливаем разряд знака.

            ;
            ; Запись мантиссы частного на место делимого.
            MOV MANTA0,Q0
            MOV MANTA1,Q1
            MOV MANTA2,Q2

            RJMP EXIT

;
; УМНОЖАЕТ ДВА ЧИСЛА
; ПО СХЕМЕ С НЕПОДВИЖНЫМ МНОЖИТЕЛЕМ.
;
; МНОЖИМОЕ ОЖИДАЕТСЯ В РЕГИСТРАХ: R11, R10, R9, R8.
; МНОЖИТЕЛЬ ОЖИДАЕТСЯ В РЕГИСТРАХ: R15, R14, R13, R12. 
; ПРОИЗВЕДЕНИЕ ПОМЕЩАЕТСЯ НА МЕСТО МНОЖИМОГО: R11, R10, R9, R8.
FMUL32:     ;
            ; ФИЛЬТРАЦИЯ ОПЕРАНДОВ.
            CLR R16                     ;
            OR R16,R8                   ;
            OR R16,R9                   ;
            OR R16,R10                  ;
            OR R16,R11                  ;
            IN R16,SREG                 ; 
            SBRC R16,SREG_Z             ; МНОЖИМОЕ РАВНО НУЛЮ?
            RJMP SETZERO                ; ДА, ВОЗВРАЩАЕМ НОЛЬ.

            CLR R16                     ; НЕТ, ПРОВЕРЯЕМ МНОЖИТЕЛЬ.
            OR R16,R12                  ;
            OR R16,R13                  ;
            OR R16,R14                  ;
            OR R16,R15                  ;
            IN R16,SREG                 ; 
            SBRC R16,SREG_Z             ; МНОЖИТЕЛЬ РАВЕН НУЛЮ?
            RJMP SETZERO                ; ДА, ВОЗВРАЩАЕМ НОЛЬ.

            ;
            ; ОПРЕДЕЛЕНИЕ ЗНАКА ПРОИЗВЕДЕНИЯ.
            MOV RSIGN,R11               ; КОПИРУЕМ СТАРШИЙ БАЙТ МНОЖИМОГО.
            MOV R1,R15                  ; КОПИРУЕМ СТАРШИЙ БАЙТ МНОЖИТЕЛЯ.
            LDI R16,0b10000000          ; ЗАГРУЖАЕМ МАСКУ ЗНАКА.
            AND RSIGN,R16               ; ИЗВЛЕКАЕМ ЗНАК МНОЖИМОГО.
            AND R1,R16                  ; ИЗВЛЕКАЕМ ЗНАК МНОЖИТЕЛЯ.
            EOR RSIGN,R1                ; ОПРЕДЕЛЯЕМ ЗНАК ПРОИЗВЕДЕНИЯ.

            ;
            ; РАСПАКОВКА МНОЖИМОГО.
            ROL R10                     ; MSB МАНТИССЫ СОДЕРЖИТ LSB ЭКСПОНЕНТЫ. СДВИГАЕМ ЕГО В БИТ ПЕРЕНОСА.
            ROL R11                     ; ИЗБАВЛЯЕМСЯ ОТ ЗНАКА И ВОССТАНАВЛИВАЕМ МЛАДШИЙ БИТ ЭКСПОНЕНТЫ.
            SEC                         ; ВОССТАНАВЛИВАЕМ СКРЫТУЮ ЕДИНИЦУ МАНТИССЫ.
            ROR R10                     ; ВОЗВРАЩАЕМ НА МЕСТО СТАРШИЙ БАЙТ МАНТИССЫ.

            ;
            ; РАСПАКОВКА МНОЖИТЕЛЯ.
            ROL R14                     ; ТО ЖЕ САМОЕ ЧТО И ДЛЯ МНОЖИМОГО.
            ROL R15                     ; 
            SEC                         ;
            ROR R14                     ; 

            ;
            ; ВЫЧИСЛЕНИЕ ЭКСПОНЕНТЫ ПРОИЗВЕДЕНИЯ.
            ;
            ; ПОСКОЛЬКУ ЭКСПОНЕНТЫ ПРЕДСТАВЛЕНЫ В КОДЕ СО СМЕЩЕНИЕМ, ТО
            ; ИХ ЗНАЧЕНИЯ ВСЕГДА ЯВЛЯЮТСЯ ПОЛОЖИТЕЛЬНЫМИ ЧИСЛАМИ В ДИАПАЗОНЕ [1,254].
            CLR EXPA1
            CLR EXPB1
            
            ADD EXPA0,EXPB0             ; EXPA=EXPA+EXPB.
            ADC EXPA1,EXPB1             ; СУММА ЭКСПОНЕНТ СОДЕРЖИТ ИЗБЫТОЧНОЕ ЗНАЧЕНИЕ 127.
            LDI R16,-127                ; НЕОБХОДИМО ОТНЯТЬ ЭТО ЗНАЧЕНИЕ.
            LDI R17,255                 ; ФОРМИРУЕМ ДОП. КОД ДЛЯ -127 В ДВОЙНОЙ СЕТКЕ.
            ADD EXPA0,R16               ; ВОССТАНАВЛИВАЕМ СУММУ ЭКСПОНЕНТ
            ADC EXPA1,R17               ; В КОДЕ СО СМЕЩЕНИЕМ.

            ;
            ; ВЫЧИСЛЕНИЕ МАНТИССЫ ПРОИЗВЕДЕНИЯ.
            LDI R22,24                  ; КОЛИЧЕСТВО ШАГОВ ЦИКЛА РАВНО КОЛИЧЕСТВУ ЦИФР МНОЖИМОГО.

            CLR MANTP0                  ; ЗАНУЛЯЕМ ПРОИЗВЕДЕНИЕ.
            CLR MANTP1                  ;
            CLR MANTP2                  ;
            CLR MANTP3                  ;
            CLR MANTP4                  ;
            CLR MANTP5                  ;

NEXTDIGIT:  ROR MANTA2                  ; ИЗВЛЕКАЕМ ОЧЕРЕДНУЮ ЦИФРУ МНОЖИМОГО.
            ROR MANTA1                  ;
            ROR MANTA0                  ;
                                        
            IN R16,SREG                 ; 
            SBRS R16,SREG_C             ; ЦИФРА РАВНА 1?
            RJMP LOOPCOND0              ; НЕТ, РАВНА 0, МНОЖИТЕЛЬ НЕ ПРИБАВЛЯЕМ.
            ADD MANTP3,MANTB0           ; ДА, ПРИБАВЛЯЕМ МНОЖИТЕЛЬ К АККУМУЛЯТОРУ.
            ADC MANTP4,MANTB1           ; МЛАДШИЕ 3 БАЙТА МНОЖИТЕЛЯ В ДВОЙНОЙ СЕТКЕ НУЛЕВЫЕ,
            ADC MANTP5,MANTB2           ; ПОЭТОМУ ДОСТАТОЧНО СЛОЖИТЬ ТОЛЬКО СТАРШИЕ БАЙТЫ.

LOOPCOND0:  DEC R22                     ; ЭТО БЫЛА ПОСЛЕДНЯЯ ЦИФРА МНОЖИМОГО?
            BREQ CHECKOVF0              ; ДА, МАНТИССА ПРОИЗВЕДЕНИЯ ВЫЧИСЛЕНА, ПРОВЕРЯЕМ ЕЁ НА ПЕРЕПОЛНЕНИЕ.

            ROR MANTP5                  ; НЕТ, ДЕЛИМ АККУМУЛЯТОР НА 2.
            ROR MANTP4                  ;
            ROR MANTP3                  ;
            ROR MANTP2                  ;
            ROR MANTP1                  ;
            ROR MANTP0                  ;            

            RJMP NEXTDIGIT              ; ПЕРЕХОДИМ К СЛЕДУЮЩЕЙ ЦИФРЕ МНОЖИМОГО.

CHECKOVF0:  IN R16,SREG                 ; 
            SBRS R16,SREG_C             ; МАНТИССА ПРОИЗВЕДЕНИЯ ДАЛА ПЕРЕПОЛНЕНИЕ?
            RJMP ROUNDPROD              ; НЕТ, ПЕРЕХОДИМ К ЕЁ ОКРУГЛЕНИЮ.
            ROR MANTP5                  ; ДА, НОРМАЛИЗУЕМ МАНТИССУ ПРОИЗВЕДЕНИЯ ВПРАВО НА 1 РАЗРЯД.
            ROR MANTP4                  ;
            ROR MANTP3                  ;
            ROR MANTP2                  ;
            ROR MANTP1                  ;
            ROR MANTP0                  ;

            LDI R16,1                   ; КОРРЕКТИРУЕМ ЭКСПОНЕНТУ.
            ADD EXPA0,R16               ;
            LDI R16,0                   ;
            ADC EXPA1,R16               ;

            ;
            ; ОКРУГЛЕНИЕ МАНТИССЫ ПРОИЗВЕДЕНИЯ.
            ;
            ; ПОСЛЕ УСТАНОВКИ S-БИТА И ИЗВЛЕЧЕНИЯ ПАРЫ RS
            ; MANTP2 МОЖЕТ СОДЕРЖАТЬ СЛЕДУЮЩИЕ ЗНАЧЕНИЯ:
            ; - 0b11000000
            ; - 0b10000000
            ; - 0b01000000
            ; - 0b00000000
ROUNDPROD:  CLR GUARD
            CLC
            
            ROL MANTP0                  ; СДВИГАЕМ R-БИТ В GUARD-РЕГИСТР.
            ROL MANTP1                  ; ТЕПЕРЬ МЛАДШАЯ ЧАСТЬ СОДЕРЖИТ ТОЛЬКО БИТЫ ПОСЛЕ R.
            ROL MANTP2                  ;
            ROL GUARD                   ;

            COM MANTP0                  ; ЕСЛИ ПОСЛЕ R-БИТА ВСЕ БИТЫ НУЛЕВЫЕ,
            COM MANTP1                  ; ТО ВЫЧИСЛЕНИЕ ДОП. КОДА МЛАДШЕЙ ЧАСТИ
            COM MANTP2                  ; ДАСТ БИТ ПЕРЕНОСА.
            LDI R16,1                   ; ПОЭТОМУ ОТСУТСТВИЕ БИТА ПЕРЕНОСА
            ADD MANTP0,R16              ; ИСПОЛЬЗУЕМ КАК ПРИЗНАК ТОГО,
            LDI R16,0                   ; ЧТО ПОСЛЕ R-БИТА ЕСТЬ ХОТЯ БЫ ОДИН НЕНУЛЕВОЙ БИТ.
            ADC MANTP1,R16              ;
            ADC MANTP2,R16              ;

            IN R16,SREG                 ;
            SBRS R16,SREG_C             ; ПОСЛЕ R-БИТА ЕСТЬ НЕНУЛЕВЫЕ БИТЫ?
            SBR MANTP2,0b10000000       ; ДА, УСТАНАВЛИВАЕМ S-БИТ.

            ROR GUARD                   ; НЕТ, ВСЯ МЛАДШАЯ ЧАСТЬ НУЛЕВАЯ (ВКЛЮЧАЯ S-БИТ, ПОЭТОМУ ЯВНО ОБНУЛЯТЬ S-БИТ НЕТ НЕОБХОДИМОСТИ).
            ROR MANTP2                  ; ВОССТАНАВЛИВАЕМ R-БИТ.
            ROR MANTP1                  ;
            ROR MANTP0                  ;

            LDI R16,0b11000000          ; ИЗВЛЕКАЕМ RS-БИТЫ.
            AND MANTP2,R16              ;

            CLR GUARD                   ; ИНТЕРПРЕТИРУЕМ РЕГИСТР С RS-БИТАМИ КАК ЧИСЛО И ФОРМИРУЕМ ЕГО ДОП. КОД.
            COM MANTP2                  ; ДОП. КОД ФОРМИРУЕМ В ДВОЙНОЙ СЕТКЕ, Т.К. ДЛЯ ПРЕДСТАВЛЕНИЯ В ДОП. КОДЕ
            COM GUARD                   ; ЗНАЧЕНИЙ 0b11000000 И 0b10000000 СО ЗНАКОМ МИНУС
            LDI R16,1                   ; ОДИНАРНОЙ СЕТКИ УЖЕ НЕ ДОСТАТОЧНО.
            ADD MANTP2,R16              ;
            LDI R16,0                   ;
            ADC GUARD,R16               ;

            CLR STATUS0                 ; РАЗНОСТЬ МЕЖДУ ОПОРНЫМ ЗНАЧЕНИМ 0b10000000 И ЧИСЛОВОЙ ИНТЕРПРЕТАЦИЕЙ RS
            CLR STATUS1                 ; ОДНОЗНАЧНО СВЯЗАНА С НАПРАВЛЕНИЕМ ОКРУГЛЕНИЯ (СМ. ДОКУ).
            LDI R16,0b10000000          ; ЗА ПРИЗНАК БЕРЕМ НУЛЕВОЙ РЕЗУЛЬТАТ И ЗНАК ПОЛУЧЕННОЙ РАЗНОСТИ.
            ADD MANTP2,R16              ; 
            IN STATUS0,SREG             ; СОХРАНЯЕМ ФЛАГИ ПОСЛЕ ОПЕРАЦИИ С МЛАДШИМ БАЙТОМ.
            LDI R16,0                   ; 
            ADC GUARD,R16               ;
            IN STATUS1,SREG             ; СОХРАНЯЕМ ФЛАГИ ПОСЛЕ ОПЕРАЦИИ СО СТАРШИМ БАЙТОМ.

            SBRS STATUS1,SREG_N         ; RS=0b11000000? [NOTE: ОТРИЦАТЕЛЬНАЯ РАЗНОСТЬ ВОЗМОЖНА ТОЛЬКО В СИТУАЦИИ 0b10000000-0b11000000.]
            RJMP HALFWAY                ; НЕТ, ПРОВЕРЯЕМ СЛЕДУЮЩИЙ ВАРИАНТ.
            LDI R16,1                   ; ДА, МЛАДШАЯ ЧАСТЬ БОЛЬШЕ ULP/2. ОКРУГЛЯЕМ В БОЛЬШУЮ СТОРОНУ.
            ADD MANTP3,R16              ; ОТБРАСЫВАЕМ МЛАДШУЮ ЧАСТЬ И ПРИБАВЛЯЕТ ULP.
            LDI R16,0                   ; ЭТО ЭКВИВАЛЕНТНО ПРИБАВЛЕНИЮ К МЛАДШЕЙ ЧАСТИ ВЕЛИЧИНЫ МЕНЬШЕ ULP/2,
            ADC MANTP4,R16              ; ПРИВОДЯЩЕМУ К ЗАНУЛЕНИЮ МЛАДШЕЙ ЧАСТИ И ПОЯВЛЕНИЮ БИТА ПЕРЕНОСА В MANTP3.
            ADC MANTP5,R16              ;
            RJMP CHECKOVF1              ;

HALFWAY:    AND STATUS1,STATUS0         ; РАЗНОСТЬ НУЛЕВАЯ, ЕСЛИ ФЛАГ Z БЫЛ УСТАНОВЛЕН ДЛЯ КАЖДОГО БАЙТА.
            SBRS STATUS1,SREG_Z         ; RS=0b10000000?
            RJMP CHECKEXP1              ; НЕТ, RS=0b01000000 ИЛИ RS=0b00000000. МЛАДШАЯ ЧАСТЬ МЕНЬШЕ ULP/2, ПРОСТО ОТБРАСЫВАЕМ ЕЁ. ПЕРЕПОЛНЕНИЕ ПРИ ОКРУГЛЕНИИ НЕ ВОЗМОЖНО - ПРОПУСКАЕМ ПРОВЕРКУ.
            LDI R16,0b00000001          ; ДА, СИММЕТРИЧНОЕ ОКРУГЛЕНИЕ. МЛАДШАЯ ЧАСТЬ РАВНА ULP/2, ОКРУГЛЯЕМ К ЧЕТНОМУ.
            AND R16,MANTP3              ; ИЗВЛЕКАЕМ ULP В R16.
            ADD MANTP3,R16              ; ЕСЛИ ULP=1, ТО СТАРШАЯ ЧАСТЬ НЕЧЕТНАЯ
            LDI R16,0                   ; И ПРИБАВЛЕНИЕ R16 (КОТОРЫЙ СОДЕРЖИТ ТАКЖЕ СОДЕРЖИТ 1) ДАСТ ПЕРЕХОД К ЧЕТНОМУ.
            ADC MANTP4,R16              ; ЕСЛИ ЖЕ ULP=0, ТО ЗНАЧЕНИЕ УЖЕ ЧЕТНОЕ
            ADC MANTP5,R16              ; И ПРИБАВЛЕНИЕ R16 (КОТОРЫЙ ТАКЖЕ СОДЕРЖИТ 0) НИКАКОГО ЭФФЕКТА НЕ ДАСТ, ОСТАВЛЯЯ ЗНАЧЕНИЕ ЧЕТНЫМ.

            ;
            ; ПРОВЕРКА МАНТИССЫ ПРОИЗВЕДЕНИЯ НА ПЕРЕПОЛНЕНИЕ ПОСЛЕ ОКРУГЛЕНИЯ.
CHECKOVF1:  IN R16,SREG                 ; 
            SBRS R16,SREG_C             ; ОКРУГЛЕНИЕ ДАЛО ПЕРЕПОЛНЕНИЕ?
            RJMP CHECKEXP1              ; НЕТ, ПЕРЕХОДИМ К ПРОВЕРКЕ ЭКСПОНЕНТЫ.
            ROR MANTP5                  ; ДА, НОРМАЛИЗУЕМ МАНТИССУ ПРОИЗВЕДЕНИЯ ВПРАВО НА 1 РАЗРЯД.
            ROR MANTP4                  ;
            ROR MANTP3                  ;

            LDI R16,1                   ; КОРРЕКТИРУЕМ ЭКСПОНЕНТУ.
            ADD EXPA0,R16               ;
            LDI R16,0                   ;
            ADC EXPA1,R16               ;

            ;
            ; ПРОВЕРКА ИТОГОВОГО ПРОИЗВЕДЕНИЯ НА ПЕРЕПОЛНЕНИЕ/АНТИПЕРЕПОЛНЕНИЕ ПО ЭКСПОНЕНТЕ.
            ;
            ; ЕСЛИ ЭКСПОНЕНТА МЕНЬШЕ -126 (-126+127=1 В КОДЕ СО СМЕЩЕНИЕМ), ТО ПРОИЗВЕДЕНИЕ СЛИШКОМ МАЛО И МЫ ПЕРЕХОДИМ К НУЛЮ.
            ; ЕСЛИ ЭКСПОНЕНТА БОЛЬШЕ 127 (127+127=254 В КОДЕ СО СМЕЩЕНИЕМ), ТО ПРОИЗВЕДЕНИЕ СЛИШКОМ ВЕЛИКО И МЫ ВЫБРАСЫВАЕМ ИСКЛЮЧЕНИЕ.
CHECKEXP1:  MOV R18,EXPR0               ; КОПИРУЕМ РАСШИРЕННУЮ ЭКСПОНЕНТУ ПРОИЗВЕДЕНИЯ.
            MOV R19,EXPR1               ;

            LDI R16,255                 ; ФОРМИРУЕМ -1 В ДОП. КОДЕ.
            LDI R17,255                 ; 
            ADD R16,R18                 ; ЕСЛИ ИСТИННАЯ ЭКСПОНЕНТА МЕНЬШЕ МИНИМАЛЬНОГО ПРЕДСТАВИМОГО ЗНАЧЕНИЯ (-126),
            ADC R17,R19                 ; ТО В КОДЕ СО СМЕЩЕНИЕМ ПОСЛЕ ВЫЧИТАНИЯ ЕДИНИЦЫ БУДЕТ ПОЛУЧЕНО ОТРИЦАТЕЛЬНОЕ ЧИСЛО.
            IN R16,SREG                 ; 
            SBRC R16,SREG_N             ; ЭКСПОНЕНТА В ПРЯМОМ КОДЕ МЕНЬШЕ -126?
            RJMP SETZERO                ; ДА, АНТИПЕРЕПОЛНЕНИЕ, ВОЗВРАЩАЕМ НОЛЬ.
                                        ; 
            LDI R16,1                   ; НЕТ, ПРОВЕРЯЕМ ЭКСПОНЕНТУ НА ПЕРЕПОЛНЕНИЕ.
            LDI R17,0                   ; ЕСЛИ ИСТИННАЯ ЭКСПОНЕНТА БОЛЬШЕ МАКСИМАЛЬНОГО ПРЕДСТАВИМОГО ЗНАЧЕНИЯ (127),
            ADD R16,R18                 ; ТО В КОДЕ СО СМЕЩЕНИЕМ ПОСЛЕ ПРИБАВЛЕНИЯ ЕДИНИЦЫ СТАРШИЙ БАЙТ РАСШИРЕННОЙ ЭКСПОНЕНТЫ БУДЕТ ОТЛИЧЕН ОТ НУЛЯ.
            ADC R17,R19                 ; ЭКСПОНЕНТА В ПРЯМОМ КОДЕ МЕНЬШЕ 128?
            BREQ PACKPROD               ; ДА, ПЕРЕПОЛНЕНИЯ НЕТ, ПЕРЕХОДИМ К УПАКОВКЕ.
            IJMP                        ; НЕТ, ПЕРЕПОЛНЕНИЕ, ПРЫЖОК НА ОБРАБОТЧИК ОШИБОК, УКАЗАННЫЙ В Z.
            
            ;
            ; УПАКОВКА МАНТИССЫ И ЭКСПОНЕНТЫ ПРОИЗВЕДЕНИЯ.
PACKPROD:   ROL MANTP3                  ; СДВИГАЕМ МАНТИССУ ВЛЕВО, УБИРАЯ ЦЕЛОЧИСЛЕННУЮ ЕДИНИЦУ.
            ROL MANTP4                  ;
            ROL MANTP5                  ;

            CLC                         ; ВЫДВИГАЕМ ВПРАВО LSB ЭКСПОНЕНТЫ В РАЗРЯД ПЕРЕНОСА,
            ROR EXPR0                   ; ОДНОВРЕМЕННО ОСВОБОЖДАЯ MSB ПОД ЗНАК.

            ROR MANTP5                  ; ВОЗВРАЩАЕМ МАНТИССУ НА МЕСТО
            ROR MANTP4                  ; С LSB ЭКСПОНЕНТЫ ВМЕСТО ЦЕЛОЧИСЛЕННОЙ ЕДИНИЦЫ.
            ROR MANTP3                  ;

            OR EXPR0,RSIGN              ; УСТАНАВЛИВАЕМ РАЗРЯД ЗНАКА.

            MOV MANTA0,MANTP3           ; ЗАПИСЬ МАНТИССЫ ПРОИЗВЕДЕНИЯ НА МЕСТО МАНТИССЫ МНОЖИМОГО.
            MOV MANTA1,MANTP4
            MOV MANTA2,MANTP5

            RJMP EXIT

            ; ВЫХОД.
EXIT:       RET

            ;
            ; УСТАНОВКА РЕЗУЛЬТАТА В НОЛЬ.
            ;
            ; ВЫПОЛНЯЕТСЯ В СЛЕДУЮЩИХ СЛУЧАЯХ:
            ; - АНТИПЕРЕПОЛНЕНИЕ РЕЗУЛЬТАТА ДЛЯ ЛЮБОЙ ОПЕРАЦИИ.
            ; - ДЕЛИМОЕ РАВНО НУЛЮ.
            ; - ХОТЯ БЫ ОДИН СОМНОЖИТЕЛЬ РАВЕН НУЛЮ.
            ; - ОБА СЛАГАЕМЫХ РАВНЫ НУЛЮ.
SETZERO:    CLR MANTA0
            CLR MANTA1
            CLR MANTA2
            CLR EXPA0
            RJMP EXIT

;
; ВЫЧИСЛЯЕТ РАЗНОСТЬ ДВУХ ПОЛОЖИТЕЛЬНЫХ ЧИСЕЛ.
;
; УМЕНЬШАЕМОЕ ОЖИДАЕТСЯ В РЕГИСТРАХ: R11, R10, R9, R8.
; ВЫЧИТАЕМОЕ СЛАГАЕМОЕ ОЖИДАЕТСЯ В РЕГИСТРАХ: R15, R14, R13, R12. 
; РАЗНОСТЬ ПОМЕЩАЕТСЯ НА МЕСТО УМЕНЬШАЕМОГО: R11, R10, R9, R8.
FSUB32:     LDI R16,0b10000000          ; B=-B.
            EOR B3,R16                  ;
            RJMP FADD32                 ;

;
; СКЛАДЫВАЕТ ДВА ЧИСЛА.
;
; ПЕРВОЕ СЛАГАЕМОЕ ОЖИДАЕТСЯ В РЕГИСТРАХ: R11, R10, R9, R8.
; ВТОРОЕ СЛАГАЕМОЕ ОЖИДАЕТСЯ В РЕГИСТРАХ: R15, R14, R13, R12. 
; СУММА ПОМЕЩАЕТСЯ НА МЕСТО ПЕРВОГО СЛАГАЕМОГО: R11, R10, R9, R8.
FADD32:     ;
            ; СВОП.
            ; УСТАНОВКА НАИБОЛЬШЕГО (ПО МОДУЛЮ) ОПЕРАНДА ПЕРВЫМ.
            MOV R0,R8                   ; КОПИРУЕМ A.
            MOV R1,R9                   ;
            MOV R2,R10                  ;
            MOV R3,R11                  ;

            MOV R4,R12                  ; КОПИРУЕМ B.
            MOV R5,R13                  ;
            MOV R6,R14                  ;
            MOV R7,R15                  ;

            LDI R16,0b01111111          ;
            AND R3,R16                  ; ВЫЧИСЛЯЕМ |A|.
            AND R7,R16                  ; ВЫЧИСЛЯЕМ |B|.

            COM R4                      ; ВЫЧИСЛЯЕМ ДОП. КОД |B|.
            COM R5                      ;
            COM R6                      ;
            COM R7                      ;
            LDI R16,1                   ;
            ADD R4,R16                  ;
            LDI R16,0                   ;
            ADC R5,R16                  ;
            ADC R6,R16                  ;
            ADC R7,R16                  ;

            ADD R4,R0                   ; |A|-|B|. ПЕРЕЗАПИСЫВАЕМ КОПИЮ B,
            ADC R5,R1                   ; КОТОРАЯ УЖЕ И ТАК В ДОП. КОДЕ,
            ADC R6,R2                   ; ЧТОБЫ СОХРАНИТЬ НЕТРОНУТОЙ КОПИЮ A В ПРЯМОМ КОДЕ.
            ADC R7,R3                   ;
                                        ; |A|-|B|>=0?
            BRGE HANDLEZERO             ; ДА, СВОП НЕ НУЖЕН. ПЕРЕХОДИМ К ОБРАБОТКЕ НУЛЕВЫХ ОПЕРАНДОВ.
                                        ; НЕТ, ДЕЛАЕМ СВОП.
            MOV R3,R11                  ; БЭКАПИМ A. НО ПОСКОЛЬКУ РЕГИСТРЫ R0..R3 УЖЕ ХРАНЯТ |A|, ОСТАЕТСЯ ТОЛЬКО ВОССТАНОВИТЬ ЗНАК.
            
            MOV R8,R12                  ; ЗАПИСЫВАЕМ B НА МЕСТО A.
            MOV R9,R13                  ;
            MOV R10,R14                 ;
            MOV R11,R15                 ;

            MOV R12,R0                  ; ВОССТАНАВЛИВАЕМ ИЗ БЭКАПА A НА МЕСТО B.
            MOV R13,R1                  ;
            MOV R14,R2                  ;
            MOV R15,R3                  ;

            ;
            ; ОБРАБОТКА НУЛЕВЫХ ОПЕРАНДОВ.
            ;
            ; ВОЗМОЖНЫЕ СИТУАЦИИ ДО СВОПА (ГДЕ 1 - ЛЮБОЕ НЕНУЛЕВОЕ ЗНАЧЕНИЕ ОПЕРАНДА):
            ; 0,0
            ; 0,1
            ; 1,0
            ; 1,1
            ;
            ; ПОСЛЕ СВОПА ОСТАЮТСЯ ТОЛЬКО СЛЕДУЮЩИЕ ВАРИАНТЫ:
            ; 0,0
            ; 1,0
            ; 1,1
            ;
            ; СЛЕДОВАТЕЛЬНО, ЕСЛИ ПОСЛЕ СВОПА ПЕРВЫЙ ОПЕРАНД НУЛЕВОЙ, ЗНАЧИТ ОБА НУЛЕВЫЕ, РЕЗУЛЬТАТ - НОЛЬ.
            ; ЕСЛИ ВТОРОЙ ОПЕРАНД НУЛЕВОЙ, ЗНАЧИТ ПЕРВЫЙ НЕНУЛЕВОЙ, РЕЗУЛЬТАТ - ПЕРВЫЙ ОПЕРАНД.
HANDLEZERO: CLR R16                     ;
            OR R16,MANTA0               ;
            OR R16,MANTA1               ;
            OR R16,MANTA2               ;
            OR R16,EXPA0                ; A=0?
            BREQ SETZERO                ; ДА, И A И B РАВНЫ НУЛЮ, ВОЗВРАЩАЕМ НОЛЬ.

            CLR R16                     ; НЕТ, ПРОВЕРЯЕМ B.
            OR R16,MANTB0               ;
            OR R16,MANTB1               ;
            OR R16,MANTB2               ;
            OR R16,EXPB0                ; B=0?
            BREQ EXIT                   ; ДА, ВОЗВРАЩАЕМ A (A УЖЕ НАХОДИТСЯ В РЕГИСТРЕ РЕЗУЛЬТАТА).
                                        ; НЕТ, НИ A НИ B НЕ РАВНЫ НУЛЮ, ПРОДОЛЖАЕМ ВЫЧИСЛЕНИЯ.

            ;
            ; ОПРЕДЕЛЕНИЕ ЗНАКА СУММЫ.
            ;
            ; БЕРЕТСЯ ЗНАК ОПЕРАНДА A, КОТОРЫЙ ПОСЛЕ СВОПА УДОВЛЕТВОРЯЕТ ВЫРАЖЕНИЮ |A|>=|B|.
            ; ЕСЛИ |A|>|B| И ЗНАКИ РАЗНЫЕ, ТО ЗНАК РАЗНОСТИ РАВЕН ЗНАКУ НАИБОЛЬШЕГО (ПО МОДУЛЮ) ОПЕРАНДА, Т.Е. A.
            ; ЕСЛИ ЖЕ ЗНАКИ ОДИНАКОВЫЕ, ТО ЗНАК СУММЫ РАВЕН ЗНАКУ ЛЮБОГО ОПЕРАНДА, В Т.Ч. A.
            ; ЕСЛИ |A|=|B| И ЗНАКИ ОДИНАКОВЫЕ, ТО ЗНАК СУММЫ ТАКЖЕ РАВЕН ЗНАКУ ЛЮБОГО ОПЕРАНДА, В Т.Ч. A.
            ; ЕСЛИ ЖЕ ЗНАКИ РАЗНЫЕ, ТО В СИЛУ РАВЕНСТВА МОДУЛЕЙ, РАЗНОСТЬ БУДЕТ РАВНА НУЛЮ И БУДЕТ УСТАНОВЛЕН ПОЛОЖИТЕЛЬНЫЙ ЗНАК, НЕЗАВИСИМО ОТ ЗНАКОВ A И B.
CALCSIGN:   MOV RSIGN,R11               ; КОПИРУЕМ СТАРШИЙ БАЙТ A.
            LDI R16,0b10000000          ; ФОРМИРУЕМ МАСКУ ДЛЯ ИЗВЛЕЧЕНИЯ ЗНАКА, КОТОРЫЙ ХРАНИТСЯ В MSB.
            AND RSIGN,R16               ; ИЗВЛЕКАЕМ ЗНАК A.

            ;
            ; БЭКАП ЗНАКА B.
            ; 
            ; ОН БУДЕТ НУЖЕН ДЛЯ ОПРЕДЕЛЕНИЯ ОПЕРАЦИИ: СЛОЖЕНИЕ ИЛИ ВЫЧИТАНИЕ.
            MOV R1,R15                  ; КОПИРУЕМ СТАРШИЙ БАЙТ B.
            AND R1,R16                  ; ИЗВЛЕКАЕМ ЗНАК B. МАСКА ЗНАКА УЖЕ СОДЕРЖИТСЯ В R16.

            ;
            ; РАСПАКОВКА ОПЕРАНДОВ.
            ROL R8                      ; РАСПАКОВКА A.
            ROL R9                      ;
            ROL R10                     ; ВЫДВИГАЕМ В БИТ ПЕРЕНОСА LSB ЭКСПОНЕНТЫ.
            ROL R11                     ; ВОССТАНАВЛИВАЕМ ЭКСПОНЕНТУ В СТАРШЕМ БАЙТЕ.
            SEC                         ; ВОССТАНАВЛИВАЕМ В МАНТИССЕ A НЕЯВНУЮ ЕДИНИЦУ.
            ROR R10                     ;
            ROR R9                      ;
            ROR R8                      ;

            ROL R12                     ; РАСПАКОВКА B
            ROL R13                     ;
            ROL R14                     ;
            ROL R15                     ;
            SEC                         ;
            ROR R14                     ;
            ROR R13                     ;
            ROR R12                     ;

            ;
            ; РАСШИРЯЕМ ЭКСПОНЕНТУ A НА ОДИН БАЙТ ВЛЕВО.
            CLR EXPA1                   ;

            ;
            ; РАСШИРЕНИЕ МАНТИСС ДО RGS.
            ;
            ; ЭТИ РЕГИСТРЫ СТЫКУЮТСЯ СПРАВА ОТ МАНТИССЫ A И B.
            CLR R6                      ; RGS МАНТИССЫ A.
            CLR R7                      ; RGS МАНТИССЫ B.

            ;
            ; ВЫРАВНИВАНИЕ ПОРЯДКОВ.
            ;
            ; ЭКСПОНЕНТЫ ОБОИХ ОПЕРАНДОВ ПРЕДСТАВЛЕНЫ В КОДЕ СО СМЕЩЕНИЕМ И ПРИНИМАЮТ ЗНАЧЕНИЯ В ОТРЕЗКЕ [1,254].
            ; ПОСЛЕ СВОПА ПОРЯДОК A БУДЕТ ЛИБО БОЛЬШЕ ЛИБО РАВЕН ПОРЯДКУ B. ЭТО ЗНАЧИТ, ЧТО РАЗНОСТЬ ЭКСПОНЕНТ ЛЕЖИТ В ОТРЕЗКЕ [0,253].
            ; ИЗ ВСЕГО ЭТОГО СЛЕДУЕТ, ЧТО НЕТ НЕОБХОДИМОСТИ ВЫЧИСЛЯТЬ КОРРЕКТНЫЙ ДОП. КОД В ДВОЙНОЙ СЕТКЕ (СМ. ОБОСНОВАНИЕ В ДОКЕ).
            ;
            ; ЗДЕСЬ МОЖЕТ ПОТРЕБОВАТЬСЯ ОКРУЛЕНИЕ ДО S-БИТА ПРИ ДЕНОРМАЛИЗАЦИИ МАНТИССЫ B.
            MOV R17,EXPA0               ; КОПИРУЕМ ЭКСПОНЕНТУ A.
            MOV R16,EXPB0               ; КОПИРУЕМ ЭКСПОНЕНТУ B.
            COM R16                     ; ВЫЧИСЛЯЕМ ПСЕВДО ДОП. КОД ЭКСПОНЕНТЫ B.
            INC R16                     ;
            ADD R17,R16                 ; EXP(A)-EXP(B)=0? R17 ТЕПЕРЬ СОДЕРЖИТ РАЗНОСТЬ ЭКСПОНЕНТ В ОТРЕЗКЕ [1,253].
            BREQ CHOOSEOP               ; ДА, ПОРЯДКИ РАВНЫ, ВЫРАВНИВАНИЕ НЕ ТРЕБУЕТСЯ.
            LDI R16,31                  ; НЕТ, ВЫЯСНЯЕМ, В КАКОМ ОТРЕЗКЕ ЛЕЖИТ РАЗНОСТЬ: [1,30] ИЛИ [31,253].
            COM R16                     ; ФОРМИРУЕМ ДОП. КОД ЧИСЛА -31 В ПРЕДЕЛАХ БАЙТА. (НЕОБХОДИМОСТИ В ДВОЙНОЙ СЕТКЕ НЕТ. ОБОСНОВАНИЕ ЕСТЬ В ДОКЕ).
            INC R16                     ;
            ADD R16,R17                 ; (EXP(A)-EXP(B))-31<0? (ЕСЛИ ИСТИННАЯ РАЗНОСТЬ В ДВОЙНОЙ СЕТКЕ ОТРИЦАТЕЛЬНАЯ, ТО БИТА ПЕРЕНОСА ИЗ МЛАДШЕГО БАЙТА НЕ БУДЕТ).
            BRCC SHIFTMANTB             ; ДА, РАЗНОСТЬ В ОТРЕЗКЕ [1,30], СДВИГАЕМ МАНТИССУ B И ФОРМИРУЕМ S-БИТ.
            CLR MANTB0                  ; НЕТ, РАЗНОСТЬ В ОТРЕЗКЕ [31,253].
            CLR MANTB1                  ; ПРОСТО УСТАНАВЛИВАЕМ ЗНАЧЕНИЕ МАНТИССЫ B КАК 2^-31 (ОКРУГЛЕНИЕ ДО S-БИТА).
            CLR MANTB2                  ;
            LDI R16,0b00000001          ;
            MOV R7,R16                  ;
            RJMP CHOOSEOP               ;

            ;
            ; ПОШАГОВЫЙ СДВИГ МАНТИССЫ B НА РАЗНОСТЬ ЭКСПОНЕНТ ВПРАВО.
            ;
            ; РАЗНОСТЬ ЭКСПОНЕНТ ЗДЕСЬ ПРИНИМАЕТ ЗНАЧЕНИЯ В ОТРЕЗКЕ [1,30].
            ; ЕСЛИ ЗА ПРЕДЕЛАМИ RGS-ЗОНЫ ОКАЗАЛСЯ ХОТЯ БЫ ОДИН ЕДИНИЧНЫЙ БИТ, ТО ПРОИСХОДИТ УСТАНОВКА S-БИТА.
SHIFTMANTB: CLR R16                     ; R16 БУДЕТ ХРАНИТЬ В LSB ЗНАЧЕНИЕ БИТА ПЕРЕНОСА ПОСЛЕ КАЖДОГО СДВИГА.
            CLC                         ;
            ROR MANTB2                  ; СДВИГАЕМ МАНТИССУ B ВПРАВО НА 1 РАЗРЯД ВМЕСТЕ С RGS-БИТАМИ.
            ROR MANTB1                  ;
            ROR MANTB0                  ;
            ROR R7                      ;
            ROL R16                     ; ИЗВЛЕКАЕМ БИТА ПЕРЕНОСА В R16.
            OR R7,R16                   ; ЕСЛИ C!=0, ЗНАЧИТ ЗА ПРЕДЕЛАМИ RGS ОКАЗАЛСЯ ЕДИНИЧНЫЙ БИТ, ЗНАЧИТ УСТАНАВЛИВАЕМ S-БИТ.

            DEC R17                     ; МАНТИССА B СДВИНУТА НА РАЗНОСТЬ ПОРЯДКОВ?
            BREQ CHOOSEOP               ; ДА, ПЕРЕХОДИМ К ВЫБОРУ АРИФМЕТИЧЕСКОЙ ОПЕРАЦИИ.
            RJMP SHIFTMANTB             ; НЕТ, СДВИГАЕМ ДАЛЬШЕ.

            ;
            ; ВЫБОР АРИФМЕТИЧЕСКОЙ ОПЕРАЦИИ.
CHOOSEOP:   EOR R1,R0                   ; SIGN(A)=SIGN(B)?
            BRNE DIFF                   ; НЕТ, ЗНАКИ РАЗНЫЕ, ПЕРЕХОДИМ К ВЫЧИТАНИЮ.
                                        ; ДА, ВЫЧИСЛЯЕМ СУММУ.

            ;
            ; ВЫЧИСЛЕНИЕ СУММЫ МОДУЛЕЙ МАНТИСС.
            ;
            ; ЗДЕСЬ ВОЗМОЖНО ТОЛЬКО ПЕРЕПОЛНЕНИЕ РЕЗУЛЬТАТА.
            ; МАНТИССА СУММЫ ЗАПИСЫВАЕТСЯ НА МЕСТО МАНТИССЫ A.
SUM:        ADD R6,R7                   ; СКЛАДЫВАЕМ МАНТИССЫ A И B.
            ADD R8,R12                  ; У МАНТИССЫ A RGS-ЗОНА ВСЕГДА НУЛЕВАЯ, ПОЭТОМУ БИТ ПЕРЕНОСА НЕ ВОЗМОЖЕН.
            ADC R9,R13                  ;
            ADC R10,R14                 ;
                                        ; ПЕРЕПОЛНЕНИЕ ЕСТЬ?
            BRCC ROUNDSUM               ; НЕТ, ПЕРЕХОДИМ К ОКРУГЛЕНИЮ.
            ROR R10                     ; ДА, НОРМАЛИЗУЕМ МАНТИССУ ВПРАВО.
            ROR R9                      ;
            ROR R8                      ;
            ROR R6                      ;
            CLR R16                     ; УСТАНАВЛИВАЕМ S-БИТ, ЕСЛИ ПРИ НОРМАЛИЗАЦИИ БЫЛ ПОТЕРЯН ЕДИНИЧНЫЙ БИТ.
            ROL R16                     ; 
            OR R6,R16                   ;
            INC EXPA0                   ; КОРРЕКТИРУЕМ ЭКСПОНЕНТУ. В ХУДШЕМ СЛУЧАЕ ЭКСПОНЕНТА РАВНА 254 ПОЭТОМУ БИТА ПЕРЕНОСА В СТАРШИЙ БАЙТ НЕ БУДЕТ.
            RJMP ROUNDSUM               ;
            
            ;
            ; ВЫЧИСЛЕНИЕ РАЗНОСТИ МОДУЛЕЙ МАНТИСС.
            ;
            ; ЗДЕСЬ В ХУДШЕМ СЛУЧАЕ ВОЗМОЖНА ДЕНОРМАЛИЗАЦИЯ РЕЗУЛЬТАТА ВПРАВО В ОТРЕЗКЕ [0,24]
            ; ПРИ A=1 И B=((2^24)-1)*2^-23*2^-1.
DIFF:       COM R7                      ; ВЫЧИСЛЯЕМ ПСЕВДО ДОП. КОД МАНТИССЫ B. ЭТО ДОПОЛНЕНИЕ ДО 2 ВМЕСТО 4.
            COM MANTB0                  ; РЕЗУЛЬТАТ ВСЕГДА ПОЛОЖИТЕЛЬНЫЙ, ПОЭТОМУ НЕТ НЕОБХОДИМОСТИ В ИСТИННОМ ДОП. КОДЕ.
            COM MANTB1                  ; В ДОП. БИТЕ СЛЕВА ВСЕГДА БУДЕТ ЕДИНИЦА, А ИЗ МЛАДШЕЙ ЧАСТИ ВСЕГДА БУДЕТ БИТ ПЕРЕНОСА,
            COM MANTB2                  ; ЗАНУЛЯЮЩИЙ РАЗРЯД ИСТИННОГО ДОП. КОДА.
            LDI R16,1                   ;
            ADD R7,R16                  ;
            CLR R16                     ;
            ADC MANTB0,R16              ;
            ADC MANTB1,R16              ;
            ADC MANTB2,R16              ;

            LDI SREGACC,0b00000010      ; МАСКА ДЛЯ Z-ФЛАГА.
            ADD R6,R7                   ; СКЛАДЫВАЕМ RGS-РЕГИСТРЫ.
            IN R16,SREG                 ; ИЗВЛЕКАЕМ ИЗ РЕГИСТРА СТАТУСА ТОЛЬКО Z-ФЛАГ.
            AND SREGACC,R16             ;
            ADD MANTA0,MANTB0           ; СКЛАДЫВАЕМ СЛЕДУЮЩУЮ ПАРУ БАЙТ МАНТИСС. (У МАНТИССЫ A RGS-ЗОНА ВСЕГДА НУЛЕВАЯ, ПОЭТОМУ БИТ ПЕРЕНОСА ИЗ ПРЕДЫДУЩЕЙ ОПЕРАЦИИ НЕ ВОЗМОЖЕН.)
            IN R16,SREG                 ;
            AND SREGACC,R16             ;
            ADC MANTA1,MANTB1           ; СКЛАДЫВАЕМ СЛЕДУЮЩУЮ ПАРУ БАЙТ.
            IN R16,SREG                 ;
            AND SREGACC,R16             ;
            ADC MANTA2,MANTB2           ; СКЛАДЫВАЕМ ПОСЛЕДНЮЮ ПАРУ БАЙТ.
            IN R16,SREG                 ;
            AND SREGACC,R16             ; РЕЗУЛЬТАТ НУЛЕВОЙ? (SREGACC=STATUS0^STATUS1^STATUS2^STATUS3^0b00000010, ГДЕ STATUS<N>-РЕГИСТР СТАТУСА ПОСЛЕ СЛОЖЕНИЯ ОЧЕРЕДНОЙ ПАРЫ БАЙТ МАНТИСС.)
            BRNE SETZERO1               ; ДА, УСТАНАВЛИВАЕМ ПОЛОЖИТЕЛЬНЫЙ НОЛЬ. (ЕСЛИ ФЛАГ Z БЫЛ УСТАНОВЛЕН ДЛЯ КАЖДОЙ ПАРЫ БАЙТ, ТО SREGACC ОКАЖЕТСЯ НЕНУЛЕВЫМ).

            SBRC MANTA2,7               ; МАНТИССА РАЗНОСТИ ДЕНОРМАЛИЗОВАНА?
            RJMP ROUNDSUM               ; НЕТ, МАНТИССА НОРМАЛИЗОВАНА, ПЕРЕХОДИМ К ОКРУГЛЕНИЮ.
                                        ; ДА, ВЫПОЛНЯЕМ НОРМАЛИЗАЦИЮ И КОРРЕКЦИЮ ЭКСПОНЕНТЫ.
            CLR R16                     ; СЧЕТЧИК СТЕПЕНИ ДЕНОРМАЛИЗАЦИИ.
            LDI R17,255                 ; ШАГ СЧЕТЧИКА R17=-1. ФОРМИРУЕМ СЧЕТЧИК СРАЗУ В ДОП. КОДЕ.
NORM:       CLC                         ;
            ROL R6                      ; НОРМАЛИЗУЕМ ВЛЕВО.
            ROL MANTA0                  ;
            ROL MANTA1                  ;
            ROL MANTA2                  ;
            ADD R16,R17                 ; DEC R16.
            SBRS MANTA2,7               ; МАНТИССА РАЗНОСТИ НОРМАЛИЗОВАЛАСЬ?
            RJMP NORM                   ; НЕТ, ПРОДОЛЖАЕМ СДВИГ.
            ADD EXPA0,R16               ; ДА, КОРРЕКТИРУЕМ ЭКСПОНЕНТУ: EXPA-K, ГДЕ K - СТЕПЕНЬ ДЕНОРМАЛИЗАЦИИ.
            ADC EXPA1,R17               ; R17,R16 - РАСШИРИЛИ ДОП. КОД R16 ДО ДВУХ БАЙТ (ВОСПОЛЬЗОВАЛИСЬ ТЕМ, ЧТО R17 УЖЕ СОДЕРЖИТ 255).

            ;
            ; ОКРУГЛЕНИЕ.
            ;
            ; ПОСЛЕ СДВИГА R-БИТА ПРОИСХОДИТ ПРОВЕРКА C- И Z-БИТОВ В РЕГИСТРЕ СТАТУСА.
            ; ЕСЛИ Z=0 ПОСЛЕ СДВИГА, ТО ЭТО СИТУАЦИЯ СИММЕТРИЧНОГО ОКРУГЛЕНИЯ, ИНАЧЕ - ОКРУГЛЕНИЕ В БОЛЬШУЮ СТОРОНУ.
ROUNDSUM:   MOV R16,R6                  ; КОПИРУЕМ RGS.
            CLC                         ;
            ROL R16                     ; R-БИТ РАВЕН НУЛЮ?
            BRCC CHECKEXP2              ; ДА, RGS=000|001|010|011. ОТБРАСЫВАЕМ RGS, ОШИБКА ERR<ULP/2.
            BREQ HALFWAY1               ; НЕТ, RGS=ULP/2=100, СИММЕТРИЧНОЕ ОКРУГЛЕНИЕ.
            LDI R16,1                   ; НЕТ, RGS=101|110|111.
            RJMP ADDULP                 ; ОТБРАСЫВАЕМ RGS И ПРИБАВЛЯЕМ ULP. ОШИБКА ERR<ULP/2.

HALFWAY1:   LDI R16,1                   ; ИЗВЛЕКАЕМ ЗНАЧЕНИЕ РАЗРЯДА ULP.
            AND R16,R8                  ;
ADDULP:     ADD R8,R16                  ; ПРИБАВЛЯЕМ ULP.
            CLR R16                     ; ЕСЛИ ЗНАЧЕНИЕ НЕЧЕТНОЕ, ТО ULP=1, И РЕЗУЛЬТАТ СТАНЕТ ЧЕТНЫМ.
            ADC R9,R16                  ; ЕСЛИ ЗНАЧЕНИЕ УЖЕ ЧЕТНОЕ, ТО ULP=0, И ПРИБАВЛЕНИЕ НУЛЯ НЕ ИЗМЕНИТ РЕЗУЛЬТАТ.
            ADC R10,R16                 ; ЕСТЬ ПЕРЕПОЛНЕНИЕ?
            BRCC CHECKEXP2              ; НЕТ, ПЕРЕХОДИМ К ПРОВЕРКЕ ЭКСПОНЕНТЫ.
            ROR MANTA2                  ; ДА, НОРМАЛИЗУЕМ МАНТИССУ A. ПОСКОЛЬКУ ПЕРЕПОЛНЕНИЕ ПРИ ОКРУГЛЕНИИ, ДВА МЛАДШИХ БАЙТА МАНТИССЫ УЖЕ НУЛЕВЫЕ.
            INC EXPA0                   ; КОРРЕКТИРУЕМ ЭКСПОНЕНТУ. 

            ;
            ; ПРОВЕРКА ЭКСПОНЕНТЫ НА ПЕРЕПОЛНЕНИЕ/АНТИПЕРЕПОЛНЕНИЕ.
            ;
            ; ЭКСПОНЕНТА В КОДЕ СО СМЕЩЕНИЕМ ПРИНИМАЕТ ЗНАЧЕНИЯ В ОТРЕЗКЕ [-22,255].
            ; ЕСЛИ ЕСТЬ ПЕРЕПОЛНЕНИЕ, ТО ЭКСПОНЕНТА РАВНА 255 И ВЫЧИТАНИЕ ЕЁ ИЗ 255 ДАСТ НОЛЬ.
            ; ЕСЛИ НЕТ ПЕРЕПОЛНЕНИЯ, ТО ВЫЧИТАНИЕ ЭКСПОНЕНТЫ ИЗ 255 ДАСТ ПОЛОЖИТЕЛЬНОЕ ЗНАЧЕНИЕ.
            ; ЕСЛИ ЕСТЬ АНТИПЕРЕПОЛНЕНИЕ, ТО ЭКСПОНЕНТА ПРИНИМАЕТ ЗНАЧЕНИЯ В ОТРЕЗКЕ [-22,0] И ВЫЧИТАНИЕ ЕДИНИЦЫ ИЗ ЭКСПОНЕНТЫ ВСЕГДА ДАСТ ОТРИЦАТЕЛЬНОЕ ЗНАЧЕНИЕ.
            ; ЕСЛИ НЕТ АНТИПЕРЕПОЛНЕНИЯ, ТО, ПОСКОЛЬКУ ПЕРЕПОЛНЕНИЕ УЖЕ ИСКЛЮЧЕНО, ЭКСПОНЕНТА ЛЕЖИТ В [1,254] И ВЫЧИТАНИЕ ЕДИНИЦЫ ВСЕГДА ДАСТ ПОЛОЖИТЕЛЬНОЕ ЗНАЧЕНИЕ.
CHECKEXP2:  LDI R17,255                 ; ЗАПИСЫВАЕМ 255 В ДВА БАЙТА.
            LDI R18,0                   ;

            MOV R21,EXPA0               ; КОПИРУЕМ РАСШИРЕННУЮ ЭКСПОНЕНТУ A.
            MOV R22,EXPA1               ;

            COM R21                     ; ВЫЧИСЛЯЕМ ДОП. КОД ЭКСПОНЕНТЫ В ДВУХ БАЙТАХ.
            COM R22                     ;
            LDI R16,1                   ;
            ADD R21,R16                 ;
            CLR R16                     ;
            ADC R22,R16                 ;

            ADD R17,R21                 ; 255-EXP(A).
            IN STATUS0,SREG             ; СОХРАНЯЕМ ФЛАГИ ПОСЛЕ СЛОЖЕНИЯ МЛАДШИХ БАЙТ.
            ADC R18,R22                 ;
            IN STATUS1,SREG             ; СОХРАНЯЕМ ФЛАГИ ПОСЛЕ СЛОЖЕНИЯ СТАРШИХ БАЙТ.

            AND STATUS0,STATUS1         ; РЕЗУЛЬТАТ НУЛЕВОЙ, ЕСЛИ ФЛАГ Z БЫЛ УСТАНОВЛЕН ДЛЯ КАЖДОГО БАЙТА.
            SBRC STATUS0,SREG_Z         ; 255-EXP(A)=0?
            IJMP                        ; ДА, ПЕРЕПОЛНЕНИЕ, ПРЫЖОК НА ОБРАБОТЧИК ОШИБОК, УКАЗАННЫЙ В РЕГИСТРЕ Z.
            LDI R16,255                 ; НЕТ, ПРОВЕРЯЕМ НА АНТИПЕРЕПОЛНЕНИЕ.
            LDI R17,255                 ;
            ADD R16,EXPA0               ; EXP(A)-1.
            ADC R17,EXPA1               ; РЕЗУЛЬТАТ ОТРИЦАТЕЛЬНЫЙ?
            BRMI SETZERO1               ; ДА, АНТИПЕРЕПОЛНЕНИЕ, ЭКСПОНЕНТА ЛЕЖИТ В [0,-22] И НЕ ПРЕДСТАВИМА. ВОЗВРАЩАЕМ НОЛЬ.
                                        ; НЕТ, ЭКСПОНЕНТА ЛЕЖИТ В [1,254] И ПРЕДСТАВИМА В ОДИНАРНОМ FLOAT.

            ;
            ; УПАКОВКА СУММЫ.
            ROL MANTA0                  ; ВЫДВИГАЕМ ЦЕЛОЧИСЛЕННУЮ ЕДИНИЦУ МАНТИССЫ СУММЫ В БИТ ПЕРЕНОСА.
            ROL MANTA1                  ;
            ROL MANTA2                  ;
            ROL RSIGN                   ; ВЫДВИГАЕМ ЗНАК В БИТ ПЕРЕНОСА.
            ROR EXPA0                   ; ВДВИГАЕМ ЗНАК В MSB ЭКСПОНЕНТЫ И ВЫДВИГАЕМ LSB ЭКСПОНЕНТЫ В БИТ ПЕРЕНОСА.
            ROR MANTA2                  ; ВОССТАНАВЛИВАЕМ ИСХОДНЫЕ БИТЫ МАНТИССЫ,
            ROR MANTA1                  ; ВДВИГАЯ В MSB СТАРШЕГО БАЙТА МАНТИССЫ LSB ЭКСПОНЕНТЫ ВМЕСТО ЦЕЛОЧИСЛЕННОЙ ЕДИНИЦЫ.
            ROR MANTA0                  ;

            RJMP EXIT1
            
            ; ВЫХОД.
EXIT1:      RET

            ;
            ; УСТАНОВКА РЕЗУЛЬТАТА В НОЛЬ.
            ;
            ; ВЫПОЛНЯЕТСЯ В СЛЕДУЮЩИХ СЛУЧАЯХ:
            ; - АНТИПЕРЕПОЛНЕНИЕ РЕЗУЛЬТАТА ДЛЯ ЛЮБОЙ ОПЕРАЦИИ.
            ; - ДЕЛИМОЕ РАВНО НУЛЮ.
            ; - ХОТЯ БЫ ОДИН СОМНОЖИТЕЛЬ РАВЕН НУЛЮ.
            ; - ОБА СЛАГАЕМЫХ РАВНЫ НУЛЮ.
SETZERO1:   CLR MANTA0
            CLR MANTA1
            CLR MANTA2
            CLR EXPA0
            RJMP EXIT1

;
; ПРЕОБРАЗУЕТ ЧИСЛО В ФОРМАТЕ ПЛАВАЮЩЕЙ ТОЧКИ В ЦЕЛОЕ.
;
; РАБОТАЕТ ТОЛЬКО С ПОЛОЖИТЕЛЬНЫМИ НОРМАЛИЗОВАННЫМИ ДЕСЯТИЧНЫМИ ЧИСЛАМИ В ОТРЕЗКЕ [1,10).
; ТАКИМ ОБРАЗОМ, ВОЗВРАЩАЕТ ЦЕЛОЧИСЛЕННОЕ ЗНАЧЕНИЕ В ОТРЕЗКЕ [1,9] В ПРЕДЕЛАХ БАЙТА.
; 
; АРГУМЕНТЫ:
;   - NUM - ЧИСЛО. ОЖИДАЕТСЯ В РЕГИСТРАХ: R11, R10, R9, R8.
;
; РЕЗУЛЬТАТ: ЦЕЛАЯ ЧАСТЬ NUM. ПОМЕЩАЕТСЯ В R8.
            .DEF A0=R8                  ;
            .DEF A1=R9                  ;
            .DEF A2=R10                 ;
            .DEF A3=R11                 ;

            .DEF STATUS=R21             ; РЕГИСТР СТАТУСА.

FTOI:       ROL A2                      ; РАСПАКОВЫВАЕМ NUM.
            ROL A3                      ; A3=EXP(NUM). ПОСКОЛЬКУ NUM ЛЕЖИТ В [1,10), ТО ВСЕ БИТЫ ЦЕЛОЙ ЧАСТИ В НОРМАЛИЗОВАННОЙ МАНТИССЕ
            SEC                         ; ПОЛНОСТЬЮ ЛЕЖАТ В СТАРШЕМ БАЙТЕ МАНТИССЫ И НЕТ НЕОБХОДИМОСТИ СДВИГАТЬ МЛАДШИЕ.
            ROR A2                      ;
           
            CLR A0                      ; A0 НЕ СОДЕРЖИТ БИТОВ ЦЕЛОЙ ЧАСТИ И НАМ НЕ ИНТЕРЕСЕН. ОН БУДЕТ СОДЕРЖАТЬ ЦЕЛУЮ ЧАСТЬ ДЕСЯТИЧНОГО ЗНАЧЕНИЯ NUM.
            LDI R16,-127                ; A3=EXP(NUM)-127. ЭКСПОНЕНТА ЛЕЖИТ В [127,127+3], ЗНАЧИТ РАЗНОСТЬ ВСЕГДА > 0, ДОСТАТОЧНО ДОП. КОДА В ПРЕДЕЛАХ БАЙТА.
            ADD A3,R16                  ; ЭКСПОНЕНТА НУЛЕВАЯ? (ЕСЛИ НУЛЕВАЯ, ТО ЦЕЛАЯ ЧАСТЬ МАНТИССЫ УЖЕ ПРЕДСТАВЛЯЕТ ИСТИННУЮ ЦЕЛУЮ ЧАСТЬ ДЕСЯТИЧНОГО ЗНАЧЕНИЯ, КОТОРАЯ РАВНА ЕДИНИЦЕ.)
            BREQ SHFTMSB                ; ДА, ДЕЛАЕМ ФИНАЛЬНЫЙ СДВИГ.
            MOV R16,A3                  ; НЕТ, УСТАНАВЛИВАЕМ СЧЕТЧИК ЦИКЛА И РАСКРЫВАЕМ ЭКСПОНЕНТУ, ДЕНОРМАЛИЗУЯ МАНТИССУ ВЛЕВО.
DENORM:     ROL A2                      ; A<<1
            ROL A0                      ;
            DEC R16                     ; МАНТИССА ДЕНОРМАЛИЗОВАНА ВЛЕВО НА ВЕЛИЧИНУ ЭКСПОНЕНТЫ?
            BREQ SHFTMSB                ; ДА, ДЕЛАЕМ ФИНАЛЬНЫЙ СДВИГ.
            RJMP DENORM                 ; НЕТ, ПРОДОЛЖАЕМ СДВИГ.

SHFTMSB:    ROL A2                      ; A0=INT(NUM). (MSB МАНТИССЫ СОДЕРЖИТ LSB ИСТИННОЙ ЦЕЛОЙ ЧАСТИ - ВЫДВИГАЕМ ЕГО В A0.)
            ROL A0                      ;

            RET

;
; ПРЕОБРАЗУЕТ ОДНОБАЙТОВОЕ ЦЕЛОЕ ЧИСЛО В ЧИСЛО В ФОРМАТЕ ПЛАВАЮЩЕЙ ТОЧКИ.
;
; АРГУМЕНТЫ:
;   - NUM - ЦЕЛОЕ ЧИСЛО. ОЖИДАЕТСЯ В РЕГИСТРЕ: R8.
;
; РЕЗУЛЬТАТ: ЧИСЛО В ФОРМАТЕ ПЛАВАЮЩЕЙ ТОЧКИ, ПОМЕЩАЕТСЯ В R11, R10, R9, R8.
            .DEF A0=R8                  ;
            .DEF A1=R9                  ;
            .DEF A2=R10                 ;
            .DEF A3=R11                 ;

            .DEF STATUS=R21             ; РЕГИСТР СТАТУСА.

SETZERO3:   CLR A0                      ; A=0.0F.
            CLR A1                      ;
            CLR A2                      ;
            CLR A3                      ;
            RET                         ;

ITOF:       AND A0,A0                   ; NUM=0?
            BREQ SETZERO3               ; ДА, ВОЗВРАЩАЕМ 0.0F.

            CLR A1                      ; МЛАДШИЕ БАЙТЫ МАНТИССЫ
            CLR A2                      ;
            LDI R16,-1                  ; БАЙТ ЭКСПОНЕНТЫ. ИНИЦИАЛИЗИРУЕМ В -1 ДЛЯ ХОЛОСТОГО ИНКРЕМЕНТА ПРИ ПЕРВОМ СДВИГЕ.
            MOV A3,R16                  ;

            CLC                         ; A2 НУЛЕВОЙ, ПОЭТОМУ ПОСЛЕДНИЙ СДВИГ A2 ВСЕГДА ЗАНУЛЯЕТ БИТ ПЕРЕНОСА - ОЧИЩАТЬ НА КАЖДОЙ ИТЕРАЦИИ НЕ НУЖНО.
NORM0:      INC A3                      ; СОВМЕЩАЕМ LSB ЦЕЛОГО ЧИСЛА С MSB МАНТИССЫ,
            ROR A0                      ; ПОЛУЧАЯ, ПО СУТИ, ДЕНОРМАЛИЗОВАННУЮ ВЛЕВО МАНТИССУ.
            IN STATUS,SREG              ; ЗАПОМИНАЕМ ФЛАГ Z ДЛЯ A0.
            ROR A2                      ; 
            SBRS STATUS,SREG_Z          ; МАНТИССА НОРМАЛИЗОВАНА? (ЕСЛИ ИЗНАЧАЛЬНО A0=1, ТО ОН ЗАНУЛИТСЯ, А МАНТИССА СРАЗУ ОКАЖЕТСЯ НОРМАЛИЗОВАННОЙ.)
            RJMP NORM0                  ; НЕТ, ПРОДОЛЖАЕМ НОРМАЛИЗАЦИЮ.
                                        ; ДА, ПАКУЕМ FLOAT.
            LDI R16,127                 ; СОХРАНЯЕМ ЭКСПОНЕНТУ В КОДЕ СО СМЕЩЕНИЕМ.
            ADD A3,R16                  ;

                                        ; УБИРАЕМ У МАНТИССЫ ЦЕЛОЧИСЛЕННУЮ ЕДИНИЦУ.
            ROL A2                      ; ВХОДНОЕ ЧИСЛО РАЗМЕРОМ В БАЙТ, ПОЭТОМУ ВСЕ НЕНУЛЕВЫЕ БИТЫ УЖЕ ВМЕЩАЮТСЯ В A2, A0 И A1 РАВНЫ НУЛЮ.

            CLC                         ; РЕЗУЛЬТАТ БУДЕТ ПОЛОЖИТЕЛЬНЫМ - РАЗРЯД ЗНАКА НУЛЕВОЙ.
            ROR A3                      ; ПРИДВИГАЕМ ЭКСПОНЕНТУ К МАНТИССЕ БЕЗ ЕДИНИЦЫ.

            ROR A2                      ; РАЗМЕЩАЕМ LSB ЭКСПОНЕНТЫ В MSB МАНТИССЫ.

            RET

;
; КОНВЕРТИРУЕТ НОРМАЛИЗОВАННОЕ ДЕСЯТИЧНОЕ ЧИСЛО В ФОРМАТЕ FLOAT В ASCII-СТРОКУ.
;
; В ОСНОВЕ ЛЕЖИТ АЛГОРИТМ, РЕАЛИЗОВАННЫЙ В Z88DK, НО С УПРОЩЕНИЯМИ ДЛЯ ПОДДЕРЖКИ ТОЛЬКО НОРМАЛИЗОВАННЫХ ДЕСЯТИЧНЫХ ЧИСЕЛ.
; [https://github.com/z88dk/z88dk/blob/aa60b9c9e4bab3318b9b10e919919058a4d3aaee/libsrc/math/cimpl/ftoa.c]
;
; ОСНОВНАЯ ИДЕЯ АЛГОРИТМА - МЫ ИГНОРИРУЕМ ТОТ ФАКТ, ЧТО ДЕСЯТИЧНОЕ ПРЕДСТАВЛЕНИЕ
; ИСХОДНОЙ ДВОИЧНОЙ ДРОБИ ИСКАЖАЕТСЯ ПРИ ЕЁ МАСШТАБИРОВАНИИ.
; СЛЕДСТВИЕ ЭТОГО ДОПУЩЕНИЯ - НЕ ВСЕ ДЕСЯТИЧНЫЕ ЦИФРЫ В СТРОКЕ ОКАЗЫВАЮТСЯ ИСТИННЫМИ.
; ПРИ ОКРУГЛЕНИИ ДЕСЯТИЧНОГО СТРОКОВОГО ПРЕДСТАВЛЕНИЯ РАЗРЯДЫ ПРОСТО ОТБРАСЫВАЮТСЯ.
;
; АРГУМЕНТЫ:
;   - NUM - ЧИСЛО. ОЖИДАЕТСЯ В РЕГИСТРАХ: R11, R10, R9, R8.
;   - PRECISION - КОЛИЧЕСТВО ЦИФР ПОСЛЕ ТОЧКИ. ОЖИДАЕТСЯ В РЕГИСТРЕ R12.
;   - STR - УКАЗАТЕЛЬ НА ОБЛАСТЬ SRAM, КУДА БУДЕТ ЗАПИСАНА ASCII-СТРОКА. ОЖИДАЕТСЯ В XH:XL.
            .EQU TEN0=0x00              ; 10.0F.
            .EQU TEN1=0x00              ;
            .EQU TEN2=0x20              ;
            .EQU TEN3=0x41              ;

            .DEF A0=R8                  ; ПЕРВЫЙ ОПЕРАНД ЛЮБОЙ АРИФМЕТИЧЕСКОЙ ОПЕРАЦИИ: FDIV32,FMUL32,FADD32,FSUB32.
            .DEF A1=R9                  ;
            .DEF A2=R10                 ;
            .DEF A3=R11                 ;

            .DEF B0=R12                 ; ВТОРОЙ ОПЕРАНД ЛЮБОЙ АРИФМЕТИЧЕСКОЙ ОПЕРАЦИИ: FDIV32,FMUL32,FADD32,FSUB32.
            .DEF B1=R13                 ;
            .DEF B2=R14                 ;
            .DEF B3=R15                 ;

            ;
            ; ФОРМИРОВАНИЕ СТРОКИ "0" В СЛУЧАЕ, КОГДА NUM=0.0F.
SETZERO2:   LDI R16,0x30                ;
            ST X+,R16                   ; *STR++='0'.
            RJMP EXITFTOAN              ;

FTOAN:      CLR R16                     ;
            OR R16,A0                   ;
            OR R16,A1                   ;
            OR R16,A2                   ;
            OR R16,A3                   ; NUM=0?
            BREQ SETZERO2               ; ДА, ФОРМИРУЕМ ФИКСИРОВАННУЮ СТРОКУ "0.0".

            PUSH R12                    ; БЭКАПИМ PRECISION, Т.К. ОН НАХОДИТСЯ В ОДНОМ ИЗ ВХОДНЫХ РЕГИСТРОВ АРИФМЕТИЧЕСКИХ ОПЕРАЦИЙ.

            LDI R16,0b10000000          ; ИЗВЛЕКАЕМ ЗНАК NUM.
            AND R16,A3                  ; NUM>0?
            BREQ GETINT                 ; ДА, NUM УЖЕ ПОЛОЖИТЕЛЬНЫЙ, ПРОДОЛЖАЕМ.
            EOR A3,R16                  ; НЕТ, ВЫЧИСЛЯЕМ МОДУЛЬ NUM=|NUM| И
            LDI R16,0x2D                ; НАЧИНАЕМ СТРОКУ СО ЗНАКА '-'.
            ST X+,R16                   ; *STR++='-'.

            ;
            ; ИЗВЛЕЧЕНИЕ ЦИФРЫ ЦЕЛОЙ ЧАСТИ.
GETINT:     PUSH A3                     ; БЭКАПИМ ИСХОДНЫЙ NUM.
            PUSH A2                     ;
            PUSH A1                     ;
            PUSH A0                     ;
            CALL FTOI                   ; A0=DIGIT=INT(NUM).
            
            LDI R16,0x30                ; *STR++=ASCII(DIGIT).
            ADD R16,A0                  ;
            ST X+,R16                   ;

            CALL ITOF                   ; A=FDIGIT=FLOAT(DIGIT). ИЗВЛЕЧЕННУЮ ЦИФРУ ИМЕЕМ ТЕПЕРЬ НЕ КАК INT, А КАК ЧИСЛО В FLOAT32.

            MOV B0,A0                   ; B=A=FDIGIT.
            MOV B1,A1                   ;
            MOV B2,A2                   ;
            MOV B3,A3                   ;

            POP A0                      ; A=NUM.
            POP A1                      ;
            POP A2                      ;
            POP A3                      ;

            CALL FSUB32                 ; A=NUM=FSUB32(NUM,FDIGIT). ТЕПЕРЬ ИЗ NUM УДАЛЕН ЦЕЛОЧИСЛЕННЫЙ РАЗРЯД, ЦИФРУ КОТОРОГО МЫ ИЗВЛЕКЛИ.

            ;
            ; ДОБАВЛЕНИЕ ДЕСЯТИЧНОЙ ТОЧКИ.
            LDI R16,0x2E                ; *STR++='.'.
            ST X+,R16                   ;

            ;
            ; ИЗВЛЕЧЕНИЕ ДРОБНЫХ ДЕСЯТИЧНЫХ РАЗРЯДОВ.
            ;
            ; ВХОДНОЕ ЗНАЧЕНИЕ NUM<1.
            ; ДВОИЧНАЯ ЭКСПОНЕНТА ПОСЛЕ УМНОЖЕНИЯ НА 10 ЛЕЖИТ В [-123,3]
            ; ИЛИ [4,130] В КОДЕ СО СМЕЩЕНИЕМ.
GETFRAC:    LDI R16,TEN0                ; B=10.0F.
            LDI R17,TEN1                ;
            LDI R18,TEN2                ;
            LDI R19,TEN3                ;
            MOV B0,R16                  ;
            MOV B1,R17                  ;
            MOV B2,R18                  ;
            MOV B3,R19                  ;

            CALL FMUL32                 ; A=NUM'=FMUL32(NUM,10.0F). ПОСЛЕ GETINT - A=NUM, NUM<1.

            PUSH A3                     ; БЭКАПИМ NUM',
            PUSH A2                     ; ПОСКОЛЬКУ ДАЛЕЕ БУДЕМ РАСПАКОВЫВАТЬ ЕГО ЭКСПОНЕНТУ.
            PUSH A1                     ;
            PUSH A0                     ;

            ROL A2                      ; ЕСЛИ ЭКСПОНЕНТА ЛЕЖИТ В [127,130],
            ROL A3                      ; ТО РАЗНОСТЬ ПОЛОЖИТЕЛЬНАЯ И ВСЕГДА ДАСТ БИТ ПЕРЕНОСА
            LDI R16,-127                ; В СТАРШИЙ БАЙТ, ГДЕ ЗАНУЛЯТСЯ БИТЫ ИСТИННОГО ДОП. КОДА -127.
            ADD R16,A3                  ; NUM' ЛЕЖИТ В [0,1)? (ЕСЛИ NUM' РАВЕН НУЛЮ, ТО ЭКСПОНЕНТА РАВНА НУЛЮ (В КОДЕ СО СМЕЩЕНИЕМ), ЧТО ТАКЖЕ ДАСТ ОТРИЦАТЕЛЬНУЮ РАЗНОСТЬ, ПОЭТОМУ И ЭТО УСЛОВИЕ ОКАЗЫВАЕТСЯ УЖЕ ПОКРЫТЫМ.)
            BRCS ASCIIDIG1              ; НЕТ, В ЦЕЛОЙ ЧАСТИ ДЕСЯТИЧНЫЙ ДРОБНЫЙ РАЗРЯД, ОПРЕДЕЛЯЕМ ЕГО ЦИФРУ.
            LDI R16,0x30                ; ДА, ОЧЕРЕДНОЙ ДРОБНЫЙ РАЗРЯД НУЛЕВОЙ, УСТАНАВЛИВАЕМ ЦИФРУ НОЛЬ.
            ST X+,R16                   ; *STR++='0'.

            POP A0                      ; A=NUM'.
            POP A1                      ; ВОССТАНАВЛИВАЕМ СОСТОЯНИЕ, ОЖИДАЕМОЕ В COND1.
            POP A2                      ; В СТЕКЕ - PRECISION.
            POP A3                      ;

            RJMP COND1                  ;

ASCIIDIG1:  POP A0                      ; A=NUM', СЕЙЧАС NUM' - ДЕСЯТИЧНАЯ НОРМАЛИЗОВАННАЯ ДРОБЬ.
            POP A1                      ; ВОССТАНАВЛИВАЕМ ИСХОДНОЕ ЗНАЧЕНИЕ,
            POP A2                      ; НЕ ПОВРЕЖДЕННОЕ РАСПАКОВКОЙ ЭКСПОНЕНТЫ.
            POP A3                      ;

            PUSH A3                     ; СНОВА БЭКАПИМ NUM',
            PUSH A2                     ; ПОСКОЛЬКУ ДАЛЕЕ НАМ НУЖНО БУДЕТ
            PUSH A1                     ; УДАЛИТЬ ИЗ НЕГО ЦЕЛУЮ ЧАСТЬ.
            PUSH A0                     ;

            CALL FTOI                   ; A0=DIGIT=INT(NUM').

            LDI R16,0x30                ; *STR++=ASCII(DIGIT).
            ADD R16,A0                  ;
            ST X+,R16                   ;

            CALL ITOF                   ; A=FDIGIT=FLOAT(DIGIT).

            MOV B0,A0                   ; B=A=FDIGIT.
            MOV B1,A1                   ;
            MOV B2,A2                   ;
            MOV B3,A3                   ;

            POP A0                      ; A=NUM'.
            POP A1                      ;
            POP A2                      ;
            POP A3                      ;

                                        ; УБИРАЕМ ИЗВЛЕЧЕННЫЙ ДРОБНЫЙ РАЗРЯД ИЗ ЦЕЛОЙ ЧАСТИ NUM'.
            CALL FSUB32                 ; A=NUM=FSUB32(NUM',FDIGIT). ТЕПЕРЬ СНОВА NUM<1.

COND1:      POP R16                     ; R16=PRECISION.
            DEC R16                     ; PRECISION--. ИЗВЛЕКЛИ ЗАДАННОЕ ЧИСЛО ДРОБНЫХ РАЗРЯДОВ?
            BREQ EXITFTOAN              ; ДА, STR СОДЕРЖИТ ДЕСЯТИЧНЫЕ ЦИФРЫ ЧИСЛА NUM, СТЕК - АДРЕС ВОЗВРАТА.
            PUSH R16                    ; НЕТ, СНОВА БЭКАПИМ PRECISION И
            RJMP GETFRAC                ; ИЗВЛЕКАЕМ СЛЕДУЮЩИЙ ДЕСЯТИЧНЫЙ ДРОБНЫЙ РАЗРЯД.

EXITFTOAN:  LDI R16,0                   ;
            ST X,R16                    ; ДОБАВЛЯЕМ КОНЕЦ СТРОКИ '\0'.
            RET

;
; ФОРМИРУЕТ ASCII-СТРОКУ С ДЕСЯТИЧНЫМ ПРЕДСТАВЛЕНИЕМ ПЕРЕМЕННОЙ ТИПА FLOAT В ЭКСПОНЕНЦИАЛЬНОЙ ФОРМЕ.
;
; ЕСЛИ ЧИСЛО УЖЕ НОРМАЛИЗОВАНО ДЕСЯТИЧНО, ТО ПРОСТО ВЫПОЛНЯЕТСЯ КОНВЕРТАЦИЯ В СТРОКУ ЧЕРЕЗ FTOAN
; С УЧЁТОМ ОГРАНИЧЕНИЯ НА МАКСИМАЛЬНУЮ ДЛИНУ СТРОКИ MAXLEN.
;
; ИНАЧЕ ВЫПОЛНЯЕТСЯ ДЕСЯТИЧНАЯ НОРМАЛИЗАЦИЯ ЧИСЛА, ЗАТЕМ ПРОИСХОДИТ КОНВЕРТАЦИЯ НОРМАЛИЗОВАННОГО ЧИСЛА
; В СТРОКУ ЧЕРЕЗ FTOAN, НО С ОГРАНИЧЕННЫМ КОЛИЧЕСТВОМ ЗНАКОВ ПОСЛЕ ТОЧКИ, ТАКИМ, ЧТОБЫ ДЛИНА РЕЗУЛЬТИРУЮЩЕЙ
; СТРОКИ (ВМЕСТЕ СО ЗНАКОМ МИНУСА, ДЕСЯТИЧНОЙ ТОЧКОЙ И ЭКСПОНЕНТОЙ) НЕ ПРЕВЫСИЛА MAXLEN.
;
; АРГУМЕНТЫ:
;   - NUM - ЧИСЛО. ОЖИДАЕТСЯ В РЕГИСТРАХ: R11, R10, R9, R8.
;   - MAXLEN - МАКСИМАЛЬНАЯ ДЛИНА ВЫХОДНОЙ СТРОКИ. ОЖИДАЕТСЯ В РЕГИСТРЕ R12. СЕЙЧАС ОЖИДАЕТСЯ ЗНАЧЕНИЕ 16 - КОЛ-ВО СИМВОЛОВ В LCD 1602.
;   - STR - УКАЗАТЕЛЬ НА ОБЛАСТЬ SRAM, КУДА БУДЕТ ЗАПИСАНА ASCII-СТРОКА. ОЖИДАЕТСЯ В XH:XL.
            .DEF EXP=R0                 ; ПОКАЗАТЕЛЬ СТЕПЕНИ В ЭКСПОНЕНЦИАЛЬНОЙ ЗАПИСИ.

            .DEF A0=R8                  ; ПЕРВЫЙ ОПЕРАНД ЛЮБОЙ АРИФМЕТИЧЕСКОЙ ОПЕРАЦИИ: FDIV32,FMUL32,FADD32,FSUB32.
            .DEF A1=R9                  ; ТАКЖЕ - ВХОДНОЙ ОПЕРАНД NUM.
            .DEF A2=R10                 ;
            .DEF A3=R11                 ;

            .DEF MAXLEN=R12             ; МАКСИМАЛЬНАЯ ДЛИНА ВЫХОДНОЙ СТРОКИ С ДЕСЯТИЧНЫМ ПРЕДСТАВЛЕНИЕМ NUM.

            .DEF B0=R12                 ; ВТОРОЙ ОПЕРАНД ЛЮБОЙ АРИФМЕТИЧЕСКОЙ ОПЕРАЦИИ: FDIV32,FMUL32,FADD32,FSUB32.
            .DEF B1=R13                 ;
            .DEF B2=R14                 ;
            .DEF B3=R15                 ;

            .DEF TMP0=R22               ; МОЖЕТ БЫТЬ ИСПОЛЬЗОВАН ДЛЯ ВРЕМЕННОГО ХРАНЕНИЯ FLOAT32.
            .DEF TMP1=R23               ;
            .DEF TMP2=R24               ;
            .DEF TMP3=R25               ;
            
FTOAE:      PUSH MAXLEN                 ; БЭКАПИМ MAXLEN.

            CLR EXP                     ; EXP=0.

            PUSH A3                     ; БЭКАПИМ СТАРШИЕ ДВА БАЙТА NUM.
            PUSH A2                     ;
            ROL A2                      ; РАСПАКОВЫВАЕМ ЭКСПОНЕНТУ NUM.
            ROL A3                      ;
            LDI R16,-127                ;
            ADD R16,A3                  ;
            POP A2                      ; ВОССТАНАВЛИВАЕМ СТАРШИЕ ДВА БАЙТА NUM ВМЕСТО ТЕХ, КОТОРЫЕ "ПОСТРАДАЛИ" ПРИ РАСПАКОВКЕ ЭКСПОНЕНТЫ.
            POP A3                      ; ЭКСПОНЕНТА В КОДЕ СО СМЕЩЕНИЕМ ЛЕЖИТ В [1,126]? 
            BRMI NORMLFT                ; ДА, ЗНАЧИТ ИСТИННАЯ ЭКСПОНЕНТА ЛЕЖИТ В [-126,-1], А ЭТО ЗНАЧИТ, ЧТО NUM<1 И INT(NUM)=0 - НОРМАЛИЗУЕМ ВЛЕВО.

NORMRGHT:   PUSH A3                     ; НЕТ, NUM>=1, ЗНАЧИТ NUM ЛИБО УЖЕ НОРМАЛИЗОВАН, ЛИБО ДЕНОРМАЛИЗОВАН ВЛЕВО (ТОГДА НОРМАЛИЗУЕМ ВПРАВО).
            PUSH A2                     ; БЭКАПИМ ТЕКУЩЕЕ ЗНАЧЕНИЕ NUM.
            PUSH A1                     ; ВОЗМОЖНО, ЧТО ОНО УЖЕ НОРМАЛИЗОВАНО.
            PUSH A0                     ;

            LDI R16,TEN0                ; B=10.0F.
            LDI R17,TEN1                ;
            LDI R18,TEN2                ;
            LDI R19,TEN3                ;
            MOV B0,R16                  ;
            MOV B1,R17                  ;
            MOV B2,R18                  ;
            MOV B3,R19                  ;

            PUSH EXP                    ;
            CALL FDIV32                 ; A=NUM=FDIV32(NUM,10.0F).
            POP EXP                     ;

            PUSH A3                     ; БЭКАПИМ СТАРШИЕ ДВА БАЙТА NUM.
            PUSH A2                     ;
            ROL A2                      ; РАСПАКОВЫВАЕМ ЭКСПОНЕНТУ NUM.
            ROL A3                      ;
            LDI R16,-127                ;
            ADD R16,A3                  ;
            POP A2                      ; ВОССТАНАВЛИВАЕМ СТАРШИЙ БАЙТ NUM, ИСКАЖЕННЫЙ ИЗВЛЕЧЕНИЕМ ЭКСПОНЕНТЫ.
            POP A3                      ; ЭКСПОНЕНТА В КОДЕ СО СМЕЩЕНИЕМ ЛЕЖИТ В [1,126]?
            BRMI RESTNORM               ; ДА, ЗНАЧИТ ИСТИННАЯ ЭКСПОНЕНТА ЛЕЖИТ В [-126,-1], А ЭТО ЗНАЧИТ, ЧТО NUM<1 И ПРЕДЫДУЩЕЕ ЗНАЧЕНИЕ ДО ДЕЛЕНИЯ НА 10 УЖЕ БЫЛО НОРМАЛИЗОВАННЫМ.
            
            INC EXP                     ; НЕТ, NUM>=1, ЗНАЧИТ ПРЕДЫДУЩЕЕ ЗНАЧЕНИЕ НЕ БЫЛО НОРМАЛИЗОВАННЫМ. ЗАПОМИНАЕМ ОЧЕРЕДНОЕ ПОНИЖЕНИЕ ПОРЯДКА NUM.

            POP R16                     ; УДАЛЯЕМ ПРЕДЫДУЩЕЕ ЗНАЧЕНИЕ NUM.
            POP R16                     ;
            POP R16                     ;
            POP R16                     ;
            RJMP NORMRGHT               ;

RESTNORM:   POP A0                      ; ВОССТАНАВЛИВАЕМ ПОСЛЕДНЕЕ ЗНАЧЕНИЕ NUM, КОТОРОЕ УЖЕ НОРМАЛИЗОВАНО.
            POP A1                      ;
            POP A2                      ;
            POP A3                      ;
            RJMP CONVMANT               ;

NORMLFT:    CLR R16                     ;
            OR R16,A0                   ;
            OR R16,A1                   ;
            OR R16,A2                   ;
            OR R16,A3                   ; NUM=0.0F?
            BREQ CONVMANT               ; ДА, NUM=0.0F - FTOAN ОБРАБОТАЕТ НОЛЬ КОРРЕКТНО И ВЕРНЕТ СТРОКУ С СИМВОЛОМ НУЛЯ. EXP ТОЖЕ ОСТАЁТСЯ РАВЕН НУЛЮ. 

            LDI R16,TEN0                ; B=10.0F.
            LDI R17,TEN1                ;
            LDI R18,TEN2                ;
            LDI R19,TEN3                ;
            MOV B0,R16                  ;
            MOV B1,R17                  ;
            MOV B2,R18                  ;
            MOV B3,R19                  ;

            PUSH EXP                    ;
            CALL FMUL32                 ; A=NUM=FMUL32(NUM,10.0F).
            POP EXP                     ;
            INC EXP                     ; EXP++.

            PUSH A3                     ;
            PUSH A2                     ;
            ROL A2                      ;
            ROL A3                      ;
            LDI R16,-127                ;
            ADD R16,A3                  ;
            POP A2                      ; ВОССТАНАВЛИВАЕМ NUM.
            POP A3                      ; NUM>=1?
            BRMI NORMLFT                ; НЕТ, ПРОДОЛЖАЕМ НОРМАЛИЗАЦИЮ.

            LDI R16,0b10000000          ; EXP=-EXP. ПРЕДСТАВЛЯЕМ ОТРИЦАТЕЛЬНУЮ ЭКСПОНЕНТУ В ПРЯМОМ КОДЕ.
            OR EXP,R16                  ;

            ;
            ; КОНВЕРТАЦИЯ ДЕСЯТИЧНОЙ МАНТИССЫ В СТРОКУ.
            ;
            ; NOTE: МЫ НОРМАЛИЗОВАЛИ NUM (ЕСЛИ ОН НЕ БЫЛ НОРМАЛИЗОВАН ИЗНАЧАЛЬНО) И ЭТО ЗНАЧЕНИЕ ПРЕДСТАВЛЯЕТ ТЕПЕРЬ
            ; МАНТИССУ В ДЕСЯТИЧНОЙ ЭКСПОНЕНЦИАЛЬНОЙ ЗАПИСИ.
CONVMANT:   POP MAXLEN                  ; ИЗВЛЕКАЕМ АРГУМЕНТ MAXLEN.

            AND EXP,EXP                 ; EXP=0?
            BREQ CHKSGN                 ; ДА, ЧИСЛО NUM УЖЕ НОРМАЛИЗОВАНО, ЭКСПОНЕНЦИАЛЬНАЯ ФОРМА НЕ ТРЕБУЕТСЯ.

            LDI R16,-4                  ; НЕТ, РЕЗЕРВИРУЕМ В СТРОКЕ 4 МЕСТА ПОД ЭКСПОНЕНТУ: E{+|-}00.
            ADD MAXLEN,R16              ; MAXLEN=MAXLEN-4.

CHKSGN:     LDI R16,0b10000000          ; МАСКА ЗНАКА.
            AND R16,A3                  ; NUM<0?
            BRNE NUMNEG                 ; ДА, РЕЗЕРВИРУЕМ В ВЫХОДНОЙ СТРОКЕ ОДИН СИМВОЛ ПОД '-'.
            
            LDI R16,-2                  ; НЕТ, РЕЗЕРВИРУЕМ ТОЛЬКО ДВА МЕСТА ПОД ЦИФРУ ЦЕЛОЙ ЧАСТИ И ТОЧКУ.
            ADD MAXLEN,R16              ; MAXLEN=MAXLEN-2.
            RJMP CALLFTOAN              ;

NUMNEG:     LDI R16,-2-1                ; ДВА МЕСТА ПОД ЦИФРУ ЦЕЛОЙ ЧАСТИ И ТОЧКУ И ЕЩЕ ОДНО МЕСТО - ПОД СИМВОЛ МИНУСА '-'.
            ADD MAXLEN,R16              ; MAXLEN=(MAXLEN-2)-1.

CALLFTOAN:  PUSH EXP                    ;
            CALL FTOAN                  ; STR=FTOAN(NUM,MAXLEN). MAXLEN ПОСЛЕ ВЫЧИСЛЕНИЙ ФАКТИЧЕСКИ СОДЕРЖИТ PRECISION,
            POP EXP                     ; КОТОРЫЙ ГАРАНТИРУЕТ, ЧТО НЕ БУДЕТ ПРЕВЫШЕНИЯ ИСХОДНОГО ЗНАЧЕНИЯ MAXLEN.

            AND EXP,EXP                 ; EXP=0?
            BREQ EXITFTOAE              ; ДА, ВЫХОДИМ.

            LDI R16,'E'                 ; НЕТ, ФОРМИРУЕМ ЭКСПОНЕНЦИАЛЬНУЮ ЗАПИСЬ.
            ST X+,R16                   ; STR+='E'.

            ROL EXP                     ; EXP<0? (ОТРИЦАТЕЛЬНАЯ ЭКСПОНЕНТА ПРЕДСТАВЛЕНА В ПРЯМОМ КОДЕ).
            BRCC SETPLUS                ; НЕТ, EXP>0, УСТАНАВЛИВАЕМ ЗНАК '+'.
            LDI R16,'-'                 ; ДА, УСТАНАВЛИВАЕМ ЗНАК '-'.
            ST X+,R16                   ;
            RJMP EXPTOSTR               ;
SETPLUS:    LDI R16,'+'                 ;
            ST X+,R16                   ;

            ;
            ; КОНВЕРТАЦИЯ ЭКСПОНЕНТЫ В СТРОКУ.
            ;
            ; ЕСЛИ ЭКСПОНЕНТА НЕ РАВНА НУЛЮ, ТО МОДУЛЬ ЭКСПОНЕНТЫ ЛЕЖИТ В [1,38].
            ; ЭТО ЗНАЧИТ, ЧТО НЕПОЛНОЕ ЧАСТНОЕ ОТ ДЕЛЕНИЯ НА 10 НЕ ПРЕВЫШАЕТ 3 (0b00000011).
            ; А ОСТАТОК ПО ОПРЕДЕЛЕНИЮ МЕНЬШЕ ДЕЛИТЕЛЯ И ЛЕЖИТ В [0,9].
            ; ТАКИМ ОБРАЗОМ, ПОСЛЕ ДЕЛЕНИЯ ЭКСПОНЕНТЫ НА 10 НЕПОЛНОЕ ЧАСТНОЕ СОДЕРЖИТ СТАРШУЮ ДЕСЯТИЧНУЮ ЦИФРУ ЭКСПОНЕНТЫ,
            ; А ОСТАТОК - МЛАДШУЮ.
EXPTOSTR:   CLC                         ; EXP=|EXP|.
            ROR EXP                     ;

            LDI R18,2                   ; ПОСКОЛЬКУ ЧАСТНОЕ НЕ БОЛЬШЕ 3, ТО КОЛИЧЕСТВО ПРОВЕРЯЕМЫХ ДВОИЧНЫХ ЦИФР РАВНО ДВУМ.

            CLR R17                     ; ЗДЕСЬ ФОРМИРУЮТСЯ ЦИФРЫ ЧАСТНОГО.

            LDI R16,-(10*2)             ; Q[I]=2=0b00000010. СРАЗУ ФОРМИРУЕМ В ДОП. КОДЕ.
REPEAT:     ADD EXP,R16                 ; EXP-(10*Q[I])>=0?
            BRPL SET1                   ; ДА, ЦИФРА ЧАСТНОГО Q[I] РАВНА ЕДИНИЦЕ.
            RJMP SET0                   ; НЕТ, ЦИФРА Q[I] РАВНА НУЛЮ.

SET1:       SEC                         ; УСТАНАВЛИВАЕМ ТЕКУЩИЙ РАЗРЯД ЧАСТНОГО В 1.
            ROL R17                     ;

            DEC R18                     ; ОПРЕДЕЛЕНЫ ОБЕ ДВОИЧНЫЕ ЦИФРЫ ЧАСТНОГО?
            BREQ SETDECDIG              ; ДА, ЧАСТНОЕ СОДЕРЖИТ СТАРШУЮ ДЕСЯТИЧНУЮ ЦИФРУ ЭКСПОНЕНТА, А EXP - МЛАДШУЮ.
            LDI R16,-(10*1)             ; НЕТ, ОПРЕДЕЛЯЕМ МЛАДШУЮ ЦИФРУ ЧАСТНОГО.
            RJMP REPEAT                 ; Q[I]=1=0b00000001.

SET0:       CLC                         ; УСТАНАВЛИВАЕМ ТЕКУЩИЙ РАЗРЯД ЧАСТНОГО В 0.
            ROL R17                     ;

            DEC R18                     ; ОПРЕДЕЛЕНЫ ОБЕ ДВОИЧНЫЕ ЦИФРЫ ЧАСТНОГО?
            BREQ RESTREM                ; ДА, ЧАСТНОЕ СОДЕРЖИТ СТАРШУЮ ДЕСЯТИЧНУЮ ЦИФРУ ЭКСПОНЕНТА, А EXP ПОСЛЕ ВОССТАНОВЛЕНИЯ ОСТАТКА - МЛАДШУЮ.
            LDI R16,10                  ; НЕТ, ОПРЕДЕЛЯЕМ МЛАДШУЮ ЦИФРУ ЧАСТНОГО.
            RJMP REPEAT                 ; НОВЫЙ ОСТАТОК ВЫЧИСЛЯЕТСЯ БЕЗ ВОССТАНОВЛЕНИЯ: (EXP+20)-10=EXP+10.
            
RESTREM:    LDI R16,10                  ; ВОССТАНАВЛИВАЕМ ПОСЛЕДНИЙ ПОЛОЖИТЕЛЬНЫЙ ОСТАТОК.
            ADD EXP,R16                 ;

SETDECDIG:  LDI R16,0x30                ; R16='0'.

            OR R17,R16                  ; ФОРМИРУЕМ ASCII-КОД СТАРШЕЙ ДЕСЯТИЧНОЙ ЦИФРЫ ЭКСПОНЕНТЫ.
            ST X+,R17                   ; ДОБАВЛЯЕМ В СТРОКУ.
            
            OR EXP,R16                  ; ФОРМИРУЕМ ASCII-КОД МЛАДШЕЙ ДЕСЯТИЧНОЙ ЦИФРЫ ЭКСПОНЕНТЫ.
            ST X+,EXP                   ; ДОБАВЛЯЕМ В СТРОКУ.

            LDI R16,0                   ; R16='\0'.
            ST X,R16                    ; ДОБАВЛЯЕМ КОНЕЦ СТРОКИ.

EXITFTOAE:  RET

;
; ПРЕОБРАЗУЕТ ASCII-СТРОКУ С ДЕСЯТИЧНОЙ ДРОБЬЮ В БИНАРНЫЙ FLOAT.
;
; В ОСНОВЕ ЛЕЖИТ ОЧЕНЬ ПРОСТОЙ И НЕТОЧНЫЙ АЛГОРИТМ ИЗ [KERNIGHAN & RITCHIE, THE C PROGRAMMING LANGUAGE].
;
; ОСНОВНАЯ ИДЕЯ ТА ЖЕ, ЧТО И ДЛЯ FTOA - МЫ ПРОСТО ИГНОРИРУЕМ ТОТ ФАКТ, ЧТО ДЕСЯТИЧНОЕ ПРЕДСТАВЛЕНИЕ
; ИСХОДНОЙ ДВОИЧНОЙ ДРОБИ ИСКАЖАЕТСЯ ПРИ ЕЁ МАСШТАБИРОВАНИИ И УМНОЖАЕМ ДВОИЧНУЮ ДРОБЬ НА 10 ТАК,
; СЛОВНО МЫ НЕПОСРЕДСТВЕННО УМНОЖАЕМ ЕЁ ДЕСЯТИЧНОЕ ПРЕДСТАВЛЕНИЕ, ИГНОРИРУЯ ИСКАЖЕНИЯ НЕКОТОРЫХ РАЗРЯДОВ
; НОВОГО ДЕСЯТИЧНОГО ПРЕДСТАВЛЕНИЯ ОТМАСШТАБИРОВАННОЙ ДВОИЧНОЙ ДРОБИ.
;
; NOTE: ПОСКОЛЬКУ В ТЕКУЩЕЙ РЕАЛИЗАЦИИ НЕТ ПОДДЕРЖКИ ОТРИЦАТЕЛЬНОГО НУЛЯ, ТО ПРИ ПОЛУЧЕНИИ НА ВХОД
; СТРОКИ "-0" ПРОИСХОДИТ ФОРМИРОВАНИЕ ПОЛОЖИТЕЛЬНОГО НУЛЯ.
;
; NOTE:
; ИСКЛЮЧЕНИЕ ПРИ ДЕЛЕНИИ НА НОЛЬ ЗДЕСЬ НЕВОЗМОЖНО.
; А ПЕРЕПОЛНЕНИЕ МОЖЕТ ПРОИЗОЙТИ ТОЛЬКО В СЛЕДУЮЩИХ СЛУЧАЯХ:
;   - ПЕРЕПОЛНЕНИЕ NUM В FMUL32 ПРИ ОБРАБОТКЕ ЦЕЛОЙ ЧАСТИ.
;   - ПЕРЕПОЛНЕНИЕ NUM В FMUL32 ПРИ ОБРАБОТКЕ ДРОБНОЙ ЧАСТИ.
;   - ПЕРЕПОЛНЕНИЕ OVERSCALE В FMUL32 ПРИ ОБРАБОТКЕ ДРОБНОЙ ЧАСТИ.
; 
; ПЕРЕПОЛНЕНИЕ NUM В FADD32 ПРИ ОБРАБОТКЕ ЦЕЛОЙ ЧАСТИ НЕ МОЖЕТ ПРОИЗОЙТИ.
; ДОКАЗАТЕЛЬСТВО:
; ДОПУСТИМ, ЧТО ЭТО НЕ ТАК, ТОГДА СУЩЕСТВУЕТ ТАКОЕ ЦЕЛОЕ ЧИСЛО, КОТОРОЕ НЕ ДАЁТ ПЕРЕПОЛНЕНИЯ
; ПРИ МАСШТАБИРОВАНИИ, КОГДА МЫ ИЗВЛЕКАЕМ ПОСЛЕДНИЙ РАЗРЯД - РАЗРЯД ЕДИНИЦ, НО ПРИ ЭТОМ ДАЁТ ПЕРЕПОЛНЕНИЕ
; ПРИ ПРИБАВЛЕНИИ ЭТОГО РАЗРЯДА К ОТМАСШТАБИРОВАННОМУ NUM.
;
; ЕЩЕ ЗАМЕТИМ, ЧТО МАКСИМАЛЬНЫЙ ПОРЯДОК ВХОДНОЙ ЧИСЛОВОЙ СТРОКИ - 10^38.
; ТО ЕСТЬ, ЛЮБЫЕ ЧИСЛА, КОЛИЧЕСТВО ЦИФР В ЗАПИСИ КОТОРЫХ ПРЕВЫШАЕТ 39, БУДУТ ДАВАТЬ ПЕРЕПОЛНЕНИЕ,
; ПОЭТОМУ ОНИ СРАЗУ ИСКЛЮЧАЮТСЯ ИЗ РАССМОТРЕНИЯ.
; 
; ВОЗЬМЕМ ТЕПЕРЬ ЗНАЧЕНИЕ 340282430000000000000000000000000000000, ОНО ДАЁТ ПЕРЕПОЛНЕНИЕ В FMUL32
; УЖЕ ПРИ АНАЛИЗЕ САМОГО МЛАДШЕГО РАЗРЯДА. СЛЕДОВАТЕЛЬНО, ИНТЕРЕСУЮЩЕЕ НАС ЗНАЧЕНИЕ (ЕСЛИ ОНО СУЩЕСТВУЕТ)
; МЕНЬШЕ ДАННОГО.
; ВОЗЬМЕМ ТЕПЕРЬ ЗНАЧЕНИЕ НА ЕДИНИЦУ МЕНЬШЕ - 340282429999999999999999999999999999999.
; ОНО НЕ ДАЕТ ПЕРЕПОЛНЕНИЯ В FMUL32, НО ОНО НЕ ДАЁТ ПЕРЕПОЛНЕНИЯ И В FADD32, КОГДА МЫ ПРИБАВЛЯЕМ ЦИФРУ ИЗ
; РАЗРЯДА ЕДИНИЦ ПОСЛЕ МАСШТАБИРОВАНИЯ NUM (И ПРИБАВЛЯЕМ МЫ МАСКИМАЛЬНОЕ ЗНАЧЕНИЕ - 9).
; СЛЕДОВАТЕЛЬНО, ЕСЛИ ЗНАЧЕНИЕ, КОТОРОЕ ДАЁТ ПЕРЕПОЛНЕНИЕ ТОЛЬКО В FADD32, СУЩЕСТВУЕТ, ТО
; ОНО ЯВНО ДОЛЖНО БЫТЬ МЕНЬШЕ ПЕРВОГО (ЧТОБЫ НЕ ДАВАТЬ ПЕРЕПОЛНЕНИЯ В FMUL32), НО ПРИ ЭТОМ
; ОНО ДОЛЖНО БЫТЬ БОЛЬШЕ ВТОРОГО (ЧТОБЫ ДАВАТЬ ПЕРЕПОЛНЕНИЕ ПРИ ПРИБАВЛЕНИИ ЧИСЛА ИЗ РАЗРЯДА ЕДИНИЦ).
; НО МЕЖДУ 340282429999999999999999999999999999999 И 340282430000000000000000000000000000000
; НЕ СУЩЕСТВУЕТ ДРУГИХ ЦЕЛЫХ ЧИСЕЛ, Т.Е. ТАКОГО ЗНАЧЕНИЯ ПОПРОСТУ НЕ СУЩЕСТВУЕТ.
; 
; ПЕРЕПОЛНЕНИЕ NUM В FADD32 ПРИ ОБРАБОТКЕ ДРОБНОЙ ЧАСТИ НЕ МОЖЕТ ПРОИЗОЙТИ ПО ТЕМ ЖЕ СООБРАЖЕНИЯМ:
; ДОСТАТОЧНО ЗАМЕТИТЬ, ЧТО КОЛИЧЕСТВО ЦИФР В ДРОБНОЙ ЧАСТИ НЕ ДОЛЖНО ПРЕВЫШАТЬ 38, ЧТОБЫ
; НЕ БЫЛО ПЕРЕПОЛНЕНИЯ OVERSCALE И ПО АНАЛОГИИ НАЧАТЬ РАССМОТРЕНИЕ С ДРОБИ 3.40282430000000000000000000000000000000.
; БОЛЕЕ ДЕТАЛЬНЫЕ РАССУЖДЕНИЯ ОТНОСИТЕЛЬНО ГРАНИЧНЫХ ВХОДНЫХ ЗНАЧЕНИЙ ДЕСЯТИЧНЫХ ЧИСЛОВЫХ СТРОК МОЖНО НАЙТИ
; В ОСНОВНОЙ ДОКЕ.
;
; АРГУМЕНТЫ:
;   - STR - УКАЗАТЕЛЬ НА ASCII-СТРОКУ С НУЛЁМ В КОНЦЕ. ОЖИДАЕТСЯ В XH:XL.
; 
; РЕЗУЛЬТАТ:
;   - NUM - ЧИСЛО В ФОРМАТЕ ПЛАВАЮЩЕЙ ТОЧКИ, ПОМЕЩАЕТСЯ В R11, R10, R9, R8.
            .EQU ONE0=0x00              ; 1.0F.
            .EQU ONE1=0x00              ;
            .EQU ONE2=0x80              ;
            .EQU ONE3=0x3F              ;

            .DEF A0=R8                  ; ПЕРВЫЙ ОПЕРАНД ЛЮБОЙ АРИФМЕТИЧЕСКОЙ ОПЕРАЦИИ: FDIV32,FMUL32,FADD32,FSUB32.
            .DEF A1=R9                  ;
            .DEF A2=R10                 ;
            .DEF A3=R11                 ;

            .DEF B0=R12                 ; ВТОРОЙ ОПЕРАНД ЛЮБОЙ АРИФМЕТИЧЕСКОЙ ОПЕРАЦИИ: FDIV32,FMUL32,FADD32,FSUB32.
            .DEF B1=R13                 ;
            .DEF B2=R14                 ;
            .DEF B3=R15                 ;

            .DEF TMP0=R22               ; МОЖЕТ БЫТЬ ИСПОЛЬЗОВАН ДЛЯ ВРЕМЕННОГО ХРАНЕНИЯ FLOAT32.
            .DEF TMP1=R23               ;
            .DEF TMP2=R24               ;
            .DEF TMP3=R25               ;

ATOF:       PUSH ZL                     ; БЭКАПИМ АДРЕС ОБРАБОТЧИКА ИСКЛЮЧЕНИЙ ВО ВНЕШНЕМ КОДЕ,
            PUSH ZH                     ; ПОСКОЛЬКУ СНАЧАЛА МЫ ПЕРЕХВАТЫВАЕМ ИСКЛЮЧЕНИЕ ЗДЕСЬ, ВНУТРИ ATOF.

            LDI ZL,LOW(FLOATERR0)       ; УСТАНАВЛИВАЕМ ОБРАБОТЧИК ИСКЛЮЧЕНИЙ ДЛЯ ПЕРВОГО FMUL32.
            LDI ZH,HIGH(FLOATERR0)      ;
            RJMP INITNUM                ;
FLOATERR0:  POP R16                     ; ВЫБРАСЫВАЕМ АДРЕС ВОЗВРАТА.
            POP R16                     ;
            POP R16                     ; ВЫБРАСЫВАЕМ DIGIT.
            POP R16                     ; ВЫБРАСЫВАЕМ SIGN.
            POP ZH                      ; ВОССТАНАВЛИВАЕМ АДРЕС ОБРАБОТЧИКА ИСКЛЮЧЕНИЙ ВО ВНЕШНЕМ КОДЕ.
            POP ZL                      ; В СТЕКЕ ОСТАЛСЯ ТОЛЬКО АДРЕС ВОЗВРАТА ВО ВНЕШНЕМ КОДЕ ПОСЛЕ ВЫЗОВА ATOF.
            IJMP                        ; ПЕРЕДАЁМ УПРАВЛЕНИЕ ВО ВНЕШНИЙ ОБРАБОТЧИК ИСКЛЮЧЕНИЙ.            

INITNUM:    CLR A0                      ; A=NUM=0.0F.
            CLR A1                      ;
            CLR A2                      ;
            CLR A3                      ;

            ;
            ; ОПРЕДЕЛЕНИЕ ЗНАКА ЧИСЛА.
            LD R16,X                    ;
            LDI R17,'-'                 ;
            EOR R16,R17                 ; ПЕРВЫЙ СИМВОЛ ЧИСЛОВОЙ СТРОКИ - МИНУС?
            BREQ MINUS                  ; ДА, ФОРМИРУЕМ ОТРИЦАТЕЛЬНЫЙ ЗНАК РЕЗУЛЬТАТА И ПРОПУСКАЕМ ПЕРВЫЙ СИМВОЛ.
            CLR R16                     ; НЕТ, ЗНАК NUM БУДЕТ ПОЛОЖИТЕЛЬНЫМ - MSB СТАРШЕГО БАЙТА NUM БУДЕТ НУЛЕВЫМ.
            PUSH R16                    ;
            RJMP GETINT1                ;

MINUS:      LD R16,X+                   ; ПРОПУСКАЕМ ЗНАК МИНУСА И СМЕЩАЕМСЯ К СЛЕДУЮЩЕМУ СИМВОЛУ.
            LDI R16,0b10000000          ; MSB СТАРШЕГО БАЙТА NUM БУДЕТ СОДЕРЖАТЬ ЕДИНИЦУ.
            PUSH R16                    ; СОХРАНЯЕМ SIGN В СТЕКЕ ДО КОНЦА ВЫЧИСЛЕНИЙ.

            ;
            ; ФОРМИРОВАНИЕ ЦЕЛОЙ ЧАСТИ.
GETINT1:    LD R16,X+                   ; R16=DIGIT=*STR++.
            AND R16,R16                 ; ПРОЧИТАЛИ КОНЕЦ СТРОКИ?
            BREQ EXITATOF               ; ДА, ВЫХОДИМ.
            LDI R17,0x2E                ; НЕТ.
            EOR R17,R16                 ; ПРОЧИТАЛИ ТОЧКУ?
            BREQ GETFRAC1               ; ДА, ПЕРЕХОДИМ К ДРОБНОЙ ЧАСТИ.
                                        ; НЕТ, ПРОДОЛЖАЕМ ФОРМИРОВАТЬ ЦЕЛУЮ ЧАСТЬ.
            LDI R17,TEN0                ; B=10.0F
            LDI R18,TEN1                ;
            LDI R19,TEN2                ;
            LDI R20,TEN3                ;
            MOV B0,R17                  ;
            MOV B1,R18                  ;
            MOV B2,R19                  ;
            MOV B3,R20                  ;

            PUSH R16                    ; ЕСЛИ ЭТО НЕ ПЕРВАЯ ЦИФРА, ЗНАЧИТ ПОРЯДОК NUM ВЫШЕ, ЧЕМ МЫ ПРЕДПОЛОЖИЛИ.
            CALL FMUL32                 ; A=NUM=FMUL32(NUM,10.0F).
            POP R16                     ;

            PUSH A3                     ; БЭКАПИМ NUM.
            PUSH A2                     ;
            PUSH A1                     ;
            PUSH A0                     ;

            LDI R17,0x0F                ; ИЗВЛЕКАЕМ ИЗ ASCII КОДА ЦИФРЫ ОБОЗНАЧАЕМОЕ ЕЮ ЧИСЛО.
            AND R16,R17                 ; R16=DIGIT-0x30.
            MOV A0,R16                  ; R8=DIGIT.
            CALL ITOF                   ; A=FDIGIT=FLOAT(DIGIT).
            MOV B0,A0                   ; B=FDIGIT.
            MOV B1,A1                   ;
            MOV B2,A2                   ;
            MOV B3,A3                   ;

            POP A0                      ; A=NUM.
            POP A1                      ;
            POP A2                      ;
            POP A3                      ;

                                        ; ПРЕДПОЛАГАЕМ, ЧТО ПРОЧИТАННАЯ ЦИФРА ПОСЛЕДНЯЯ В ЦЕЛОЙ ЧАСТИ И Т.О. ПРЕДСТАВЛЯЕТ РАЗРЯД ЕДИНИЦ.
            CALL FADD32                 ; A=NUM=NUM+FDIGIT.

            RJMP GETINT1

            ;
            ; ВЫХОДИМ ИЗ ATOF.
EXITATOF:   CLR R16                     ;
            OR R16,A0                   ;
            OR R16,A1                   ;
            OR R16,A2                   ;
            OR R16,A3                   ; НОЛЬ?
            BRNE SETSIGN                ; НЕТ, УСТАНАВЛИВАЕМ ЗНАК.
            POP R16                     ; ДА, УДАЛЯЕМ ЗНАК ИЗ СТЕКА.
            POP R16                     ; УДАЛЯЕМ АДРЕС ОБРАБОТЧИКА ИСКЛЮЧЕНИЙ.
            POP R16                     ;
            RET                         ; ВОЗВРАЩАЕМ ПОЛОЖИТЕЛЬНЫЙ НОЛЬ.

SETSIGN:    POP R16                     ; R16=SIGN.
            EOR A3,R16                  ; УСТАНАВЛИВАЕМ ЗНАК NUM.

            POP R16                     ; ATOF ОТРАБОТАЛ БЕЗ ИСКЛЮЧЕНИЙ.
            POP R16                     ; АДРЕС ОБРАБОТЧИКА ИСКЛЮЧЕНИЙ В ВЫЗЫВАЮЩЕМ КОДЕ БОЛЬШЕ НЕ НУЖЕН - УДАЛЯЕМ ЕГО ИЗ СТЕКА.
            RET                         ; В СТЕКЕ ОСТАЛСЯ ТОЛЬКО АДРЕС ВОЗВРАТА ПОСЛЕ ATOF.

            ;
            ; ФОРМИРОВАНИЕ ДРОБНОЙ ЧАСТИ.
DWNSCALE:   POP B0                      ; B=OVERSCALE.
            POP B1                      ;
            POP B2                      ;
            POP B3                      ;
                                        
                                        ; ВОССТАНАВЛИВАЕМ ИСТИННЫЙ ПОРЯДКА ЧИСЛА NUM ПОСЛЕ ИЗВЛЕЧЕНИЯ ДРОБНОЙ ЧАСТИ.
            CALL FDIV32                 ; A=NUM=FDIV32(NUM,OVERSCALE).

            RJMP EXITATOF               ;

GETFRAC1:   LDI R16,ONE3                ; OVERSCALE=1.0F.
            LDI R17,ONE2                ;
            LDI R18,ONE1                ;
            LDI R19,ONE0                ;
            PUSH R16                    ;
            PUSH R17                    ;
            PUSH R18                    ;
            PUSH R19                    ;

            LDI ZL,LOW(FLOATERR1)       ; УСТАНАВЛИВАЕМ ОБРАБОТЧИК ИСКЛЮЧЕНИЙ ДЛЯ ВТОРОГО FMUL32, КОТОРЫЙ МАСШТАБИРУЕТ NUM.
            LDI ZH,HIGH(FLOATERR1)      ; ЭТОТ ЖЕ ОБРАБОТЧИК КОРРЕКТНО СРАБОТАЕТ ПРИ ПЕРЕПОЛНЕНИИ НА ТРЕТЬЕМ FMUL32, КОТОРЫЙ МАСШТАБИРУЕТ OVERSCALE.
            RJMP GETFRAC2               ;
FLOATERR1:  POP R16                     ; ВЫБРАСЫВАЕМ АДРЕС ВОЗВРАТА.
            POP R16                     ;
            POP R16                     ; ВЫБРАСЫВАЕМ DIGIT.
            POP R16                     ; ВЫБРАСЫВАЕМ 4 БАЙТА КОНСТАНТЫ 1.0F В ФОРМАТЕ FLOAT32 (В СЛУЧАЕ ПЕРЕПОЛНЕНИЯ ПРИ МАСШТАБИРОВАНИИ NUM - ВТОРОЙ FMUL32)
            POP R16                     ; ИЛИ 4 БАЙТА С ИЗБЫТКОМ ОТМАСШТАБИРОВАННОГО NUM (В СЛУЧАЕ ПЕРЕПОЛНЕНИЯ ПРИ МАСШТАБИРОВАНИИ OVERSCALE - ТРЕТИЙ FMUL32).
            POP R16                     ; NOTE: КОНЕЧНО, МОЖНО СРАЗУ "СПУСТИТЬ" УКАЗАТЕЛЬ СТЕКА В НУЖНОЕ МЕСТО, А НЕ ДЕЛАТЬ POP ДЛЯ КАЖДОГО ЭЛЕМЕНТА. НО ЭТОТ СПОСОБ ВЫБРАН ДЛЯ ПРОСТОТЫ И НАГЛЯДНОСТИ.
            POP R16                     ;
            POP R16                     ; ВЫБРАСЫВАЕМ SIGN.
            POP ZH                      ; ВОССТАНАВЛИВАЕМ АДРЕС ОБРАБОТЧИКА ИСКЛЮЧЕНИЙ ВО ВНЕШНЕМ КОДЕ.
            POP ZL                      ; В СТЕКЕ ОСТАЛСЯ ТОЛЬКО АДРЕС ВОЗВРАТА ВО ВНЕШНЕМ КОДЕ ПОСЛЕ ВЫЗОВА ATOF.
            IJMP                        ; ПЕРЕДАЁМ УПРАВЛЕНИЕ ВО ВНЕШНИЙ ОБРАБОТЧИК ИСКЛЮЧЕНИЙ.

GETFRAC2:   LD R16,X+                   ; R16=DIGIT=*STR++.
            AND R16,R16                 ; ПРОЧИТАЛИ КОНЕЦ СТРОКИ?
            BREQ DWNSCALE               ; ДА, ВОССТАНАВЛИВАЕМ ПОРЯДОК NUM.
                                        ; НЕТ, ПРОДОЛЖАЕМ ИЗВЛЕКАТЬ ДРОБНЫЕ РАЗРЯДЫ.
            LDI R17,TEN0                ; B=10.0F.
            LDI R18,TEN1                ;
            LDI R19,TEN2                ;
            LDI R20,TEN3                ;
            MOV B0,R17                  ;
            MOV B1,R18                  ;
            MOV B2,R19                  ;
            MOV B3,R20                  ;

            PUSH R16                    ; ЗАВЫШАЕМ ПОРЯДОК NUM, ЧТОБЫ ТЕКУЩАЯ ЦИФРА ПРЕДСТАВЛЯЛА РАЗРЯД ЕДИНИЦ.
            CALL FMUL32                 ; A=NUM=FMUL32(NUM,10.0F).
            POP R16                     ;

            POP TMP0                    ; TMP=OVERSCALE.
            POP TMP1                    ;
            POP TMP2                    ;
            POP TMP3                    ;

            PUSH A3                     ; БЭКАПИМ NUM.
            PUSH A2                     ;
            PUSH A1                     ;
            PUSH A0                     ;

            PUSH R16                    ; БЭКАПИМ DIGIT.

            MOV A0,TMP0                 ; A=TMP=OVERSCALE.
            MOV A1,TMP1                 ;
            MOV A2,TMP2                 ;
            MOV A3,TMP3                 ;

            LDI R16,TEN0                ; B=10.0F.
            LDI R17,TEN1                ;
            LDI R18,TEN2                ;
            LDI R19,TEN3                ;
            MOV B0,R16                  ;
            MOV B1,R17                  ;
            MOV B2,R18                  ;
            MOV B3,R19                  ; 

                                        ; ОТСЛЕЖИВАЕМ СТЕПЕНЬ ЗАВЫШЕНИЯ ИСТИННОГО ПОРЯДКА NUM.
            CALL FMUL32                 ; A=OVERSCALE=FMUL32(OVERSCALE,10.0F).
            MOV TMP0,A0                 ; TMP=A=OVERSCALE.
            MOV TMP1,A1                 ;
            MOV TMP2,A2                 ;
            MOV TMP3,A3                 ;

            POP R16                     ; R16=DIGIT.

            POP A0                      ; A=NUM.
            POP A1                      ;
            POP A2                      ;
            POP A3                      ;

            PUSH TMP3                   ; БЭКАПИМ OVERSCALE.
            PUSH TMP2                   ;
            PUSH TMP1                   ;
            PUSH TMP0                   ;

            PUSH A3                     ; БЭКАПИМ NUM.
            PUSH A2                     ;
            PUSH A1                     ;
            PUSH A0                     ;

            LDI R17,0x0F                ; ИЗВЛЕКАЕМ ИЗ ASCII КОДА ЦИФРЫ ОБОЗНАЧАЕМОЕ ЕЮ ЧИСЛО.
            AND R16,R17                 ; R16=DIGIT-0x30.
            MOV A0,R16                  ; R8=DIGIT.
            CALL ITOF                   ; A=FDIGIT=FLOAT(DIGIT).
            MOV B0,A0                   ; B=FDIGIT.
            MOV B1,A1                   ;
            MOV B2,A2                   ;
            MOV B3,A3                   ;

            POP A0                      ; A=NUM.
            POP A1                      ;
            POP A2                      ;
            POP A3                      ;

            CALL FADD32                 ; A=NUM=NUM+FDIGIT.

            RJMP GETFRAC2               ;
