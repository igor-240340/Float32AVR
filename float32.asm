;
; FLOAT32AVR
; БИБЛИОТЕКА ПОДПРОГРАММ ДЛЯ РАБОТЫ С ЧИСЛАМИ В ФОРМАТЕ ПЛАВАЮЩЕЙ ТОЧКИ ОДИНАРНОЙ ТОЧНОСТИ.
; КРОМЕ АРИФМЕТИКИ СОДЕРЖИТ ВСПОМОГАТЕЛЬНЫЕ ПОДПРОГРАММЫ ДЛЯ КОНВЕРТАЦИИ ASCII-FLOAT-ASCII.
;
; Copyright (c) 2024 IGOR VOYTENKO <igor.240340@gmail.com>
;
; ЧАСТИЧНАЯ СОВМЕСТИМОСТЬ С IEEE 754:
; - НЕ РЕАЛИЗОВАНЫ СПЕЦ. ЗНАЧЕНИЯ: INF, NAN.
; - НЕ РЕАЛИЗОВАНЫ ДЕНОРМАЛИЗОВАННЫЕ ЧИСЛА.
; - РЕАЛИЗОВАН ТОЛЬКО ОДИН РЕЖИМ ОКРУГЛЕНИЯ: К БЛИЖАЙШЕМУ/К ЧЕТНОМУ.
; - РЕАЛИЗОВАН ТОЛЬКО ПОЛОЖИТЕЛЬНЫЙ НОЛЬ.
;
; ТЕМ НЕ МЕНЕЕ, ГРАНИЧНЫЕ ЗНАЧЕНИЯ ЭКСПОНЕНТЫ -127 И 128 (0 И 255 В КОДЕ СО СМЕЩЕНИЕМ)
; ОСТАЮТСЯ ЗАРЕЗЕРВИРОВАННЫМИ ДЛЯ СПЕЦ. ЗНАЧЕНИЙ И ДЕНОРМАЛИЗОВАННЫХ ЧИСЕЛ
; ЧТОБЫ МОЖНО БЫЛО ДОВЕСТИ ДО ПОЛНОЙ СОВМЕСТИМОСТИ В БУДУЩЕМ
; А ТАКЖЕ ДЛЯ УДОБСТВА ТЕСТИРОВАНИЯ И СРАВНЕНИЯ С ЭТАЛОННОЙ IEEE 754 РЕАЛИЗАЦИЕЙ ПРЯМО СЕЙЧАС.
;
; ОБРАБОТКА ИСКЛЮЧИТЕЛЬНЫХ СИТУАЦИЙ.
; В СЛУЧАЕ ВОЗНИКНОВЕНИЯ ИСКЛЮЧИТЕЛЬНОЙ СИТУАЦИИ (ДЕЛЕНИЕ НА НОЛЬ, ПЕРЕПОЛНЕНИЕ)
; ПРОИСХОДИТ ПРЫЖОК НА АДРЕС, КОТОРЫЙ ДОЛЖЕН БЫТЬ ПРЕДВАРИТЕЛЬНО ЗАГРУЖЕН В Z-РЕГИСТР ПЕРЕД ВЫЗОВОМ ПОДПРОГРАММЫ.
            ;
            ; БАЙТЫ ИСХОДНОЙ МАНТИССЫ ДЕЛИМОГО,
            ; РАСШИРЕННЫЕ GUARD-БАЙТОМ ДЛЯ БЕЗОПАСНОГО СДВИГА ВЛЕВО.
            .DEF MANTA0=R8              
            .DEF MANTA1=R9              
            .DEF MANTA2=R10             
            .DEF MANTAG=R2              

            ;
            ; БАЙТЫ ИСХОДНОЙ МАНТИССЫ ДЕЛИТЕЛЯ,
            ; РАСШИРЕННЫЕ GUARD-БАЙТОМ ДЛЯ ФОРМИРОВАНИЯ ДОП. КОДА ОТРИЦАТЕЛЬНОЙ МАНТИССЫ.
            .DEF MANTB0=R12             
            .DEF MANTB1=R13             
            .DEF MANTB2=R14             
            .DEF MANTBG=R3              

            ;
            ; БАЙТЫ ДОП. КОДА ОТРИЦАТЕЛЬНОЙ МАНТИССЫ ДЕЛИТЕЛЯ.
            .DEF MANTB0NEG=R4
            .DEF MANTB1NEG=R5
            .DEF MANTB2NEG=R6
            .DEF MANTBGNEG=R7

            ;
            ; РАСШИРЕННЫЕ ЭКСПОНЕНТЫ.
            .DEF EXPA0=R11                  ; ПЕРВЫЙ ОПЕРАНД. 
            .DEF EXPA1=R20                  ;
            .DEF EXPR0=R11                  ; РЕЗУЛЬТАТ
            .DEF EXPR1=R20                  ;
            .DEF EXPB0=R15                  ; ВТОРОЙ ОПЕРАНД
            .DEF EXPB1=R21                  ;

            ;
            ; БАЙТЫ МАНТИССЫ ЧАСТНОГО.
            .DEF Q0=R22
            .DEF Q1=R23
            .DEF Q2=R24
            .DEF Q3=R25

            .EQU QDIGITS=24+2               ; КОЛИЧЕСТВО ЦИФР ЧАСТНОГО К ВЫЧИСЛЕНИЮ: 24 + R + G + S (S ОПРЕДЕЛЯЕТСЯ ВНЕ ЦИКЛА).

            .DEF STEPS=R17                  ; СЧЕТЧИК ЦИКЛА.

            .EQU RGSMASK=0b00000111         ; МАСКА ДЛЯ ИЗВЛЕЧЕНИЯ RGS-БИТОВ ПРИ ОКРУГЛЕНИИ.
            .DEF RGSBITS=R18                ; ДОПОЛНИТЕЛЬНЫЕ БИТЫ МАНТИССЫ ЧАСТНОГО + STICKY-БИТ ДЛЯ КОРРЕКТНОГО ОКРУГЛЕНИЯ.

            .DEF RSIGN=R0                   ; ЗНАК РЕЗУЛЬТАТА (ЧАСТНОЕ/ПРОИЗВЕДЕНИЕ/АЛГЕБРАИЧЕСКАЯ СУММА).

            ;
            ; МАНТИССА ПРОИЗВЕДЕНИЯ.
            .DEF MANTP0=R17
            .DEF MANTP1=R18
            .DEF MANTP2=R19
            .DEF MANTP3=R23
            .DEF MANTP4=R24
            .DEF MANTP5=R25
            .DEF GUARD=R7                  ; GUARD-РЕГИСТР ДЛЯ ВРЕМЕННОГО ХРАНЕНИЯ R-БИТА МАНТИССЫ ПРОИЗВЕДЕНИЯ.

            .DEF STATUS0=R5                ; РЕГИСТР СТАТУСА ПОСЛЕ ОПЕРАЦИИ НАД МЛАДШИМ БАЙТОМ.
            .DEF STATUS1=R6                ; РЕГИСТР СТАТУСА ПОСЛЕ ОПЕРАЦИИ НАД СТАРШИМ БАЙТОМ.
            .DEF SREGACC=R17               ; РЕГИСТР СТАТУСА ПОСЛЕ НЕСКОЛЬКИХ ОПЕРАЦИЙ. НАПРИМЕР, ПОБИТОВОЕ И РЕГИСТРА STATUS.

;
; ДЕЛИТ ДВА ЧИСЛА
; ПО СХЕМЕ С НЕПОДВИЖНЫМ ДЕЛИТЕЛЕМ БЕЗ ВОССТАНОВЛЕНИЯ ОСТАТКА.
;
; ДЕЛИМОЕ ОЖИДАЕТСЯ В РЕГИСТРАХ: R11, R10, R9, R8.
; ДЕЛИТЕЛЬ ОЖИДАЕТСЯ В РЕГИСТРАХ: R15, R14, R13, R12. 
; ЧАСТНОЕ ПОМЕЩАЕТСЯ НА МЕСТО ДЕЛИМОГО: R11, R10, R9, R8.
FDIV32:     ;
            ; ФИЛЬТРАЦИЯ ОПЕРАНДОВ.
            CLR R16                     ;
            OR R16,R8                   ;
            OR R16,R9                   ;
            OR R16,R10                  ;
            OR R16,R11                  ;
            IN R16,SREG                 ;
            SBRC R16,SREG_Z             ; ДЕЛИМОЕ РАВНО НУЛЮ?            
            RJMP SETZERO                ; ДА, ВОЗВРАЩАЕМ НОЛЬ.

            CLR R16                     ; НЕТ, ПРОВЕРЯЕМ ДЕЛИТЕЛЬ.
            OR R16,R12                  ;
            OR R16,R13                  ;
            OR R16,R14                  ;
            OR R16,R15                  ;
            IN R16,SREG                 ; 
            SBRC R16,SREG_Z             ; ДЕЛИТЕЛЬ РАВЕН НУЛЮ?
            IJMP                        ; ДА, ВЫБРАСЫВАЕМ ОШИБКУ.
            
            ;
            ; ОПРЕДЕЛЕНИЕ ЗНАКА ЧАСТНОГО.
            MOV RSIGN,R11               ; КОПИРУЕМ СТАРШИЙ БАЙТ ДЕЛИМОГО.
            MOV R1,R15                  ; КОПИРУЕМ СТАРШИЙ БАЙТ ДЕЛИТЕЛЯ.
            LDI R16,0b10000000          ; ЗАГРУЖАЕМ МАСКУ ЗНАКА.
            AND RSIGN,R16               ; ИЗВЛЕКАЕМ ЗНАК ДЕЛИМОГО.
            AND R1,R16                  ; ИЗВЛЕКАЕМ ЗНАК ДЕЛИТЕЛЯ.
            EOR RSIGN,R1                ; ОПРЕДЕЛЯЕМ ЗНАК ЧАСТНОГО.

            ;
            ; РАСПАКОВКА ДЕЛИМОГО.
            ROL R10                     ; MSB МАНТИССЫ ДЕЛИМОГО СОДЕРЖИТ LSB ЭКСПОНЕНТЫ. СДВИГАЕМ ЕГО В БИТ ПЕРЕНОСА.
            ROL R11                     ; ИЗБАВЛЯЕМСЯ ОТ ЗНАКА ДЕЛИМОГО И ВОССТАНАВЛИВАЕМ МЛАДШИЙ БИТ ЭКСПОНЕНТЫ.
            ROR R10                     ; ВОЗВРАЩАЕМ НА МЕСТО СТАРШИЙ БАЙТ МАНТИССЫ ДЕЛИМОГО.
            OR R10,R16                  ; ВОССТАНАВЛИВАЕМ СКРЫТУЮ ЕДИНИЦУ МАНТИССЫ.

            ;
            ; РАСПАКОВКА ДЕЛИТЕЛЯ.
            ROL R14                     ; ТО ЖЕ САМОЕ ДЛЯ ДЕЛИТЕЛЯ.
            ROL R15                     ; 
            ROR R14                     ; 
            OR R14,R16                  ;

            ;
            ; ВЫЧИСЛЕНИЕ ЭКСПОНЕНТЫ ЧАСТНОГО.
            CLR EXPA1
            CLR EXPB1
            
            COM EXPB0                   ; ФОРМИРУЕМ ДОП. КОД ЭКСПОНЕНТЫ ДЕЛИТЕЛЯ.
            COM EXPB1                   ;
            LDI R16,1                   ; 
            ADD EXPB0,R16               ; 
            LDI R16,0                   ;
            ADC EXPB1,R16               ;

            ADD EXPA0,EXPB0             ; EXPA=EXPA-EXPB.
            ADC EXPA1,EXPB1             ;
            LDI R16,127                 ; ВОССТАНАВЛИВАЕМ РЕЗУЛЬТАТ В КОДЕ СО СМЕЩЕНИЕМ.
            ADD EXPA0,R16               ; 
            LDI R16,0                   ;
            ADC EXPA1,R16               ;
            
            ;
            ; ФОРМИРОВАНИЕ ДОП. КОДА МАНТИССЫ ДЕЛИТЕЛЯ.
            CLR MANTAG                  ;
            CLR MANTBG                  ;

            MOV MANTB0NEG,MANTB0        ; КОПИРУЕМ ПОЛОЖИТЕЛЬНУЮ МАНТИССУ ДЕЛИТЕЛЯ.
            MOV MANTB1NEG,MANTB1        ;
            MOV MANTB2NEG,MANTB2        ;
            MOV MANTBGNEG,MANTBG        ;

            COM MANTB0NEG               ; ПОСКОЛЬКУ 2^N-|B|=(2^N-1-|B|)+1=COM(|B|)+1,
            COM MANTB1NEG               ; ТО ИНВЕРТИРУЕМ БИТЫ ПОЛОЖИТЕЛЬНОЙ МАНТИССЫ
            COM MANTB2NEG               ;
            COM MANTBGNEG               ;

            LDI R16,1                   ; И ПРИБАВЛЯЕМ ЕДИНИЦУ,
            ADD MANTB0NEG,R16           ; НЕ ЗАБЫВАЯ ПРО ВОЗМОЖНОЕ ПОЯВЛЕНИЕ БИТА ПЕРЕНОСА.
            LDI R16,0                   ;
            ADC MANTB1NEG,R16           ; 
            ADC MANTB2NEG,R16           ; 
            ADC MANTBGNEG,R16           ;

            ;
            ; ВЫЧИСЛЕНИЕ МАНТИССЫ ЧАСТНОГО.
            LDI STEPS,QDIGITS           ; КОЛИЧЕСТВО ШАГОВ РАВНО КОЛИЧЕСТВУ ВЫЧИСЛЯЕМЫХ ЦИФР ЧАСТНОГО.
            CLR Q0                      ; ЗАНУЛЯЕМ МАНТИССУ ЧАСТНОГО.
            CLR Q1                      ;
            CLR Q2                      ;
            CLR Q3                      ;

SUBMANTB:   ADD MANTA0,MANTB0NEG        ; ВЫЧИТАЕМ ИЗ МАНТИССЫ ДЕЛИМОГО ИЛИ ОСТАТКА
            ADC MANTA1,MANTB1NEG        ; МАНТИССУ ДЕЛИТЕЛЯ,
            ADC MANTA2,MANTB2NEG        ; УМНОЖЕННУЮ НА ВЕС
            ADC MANTAG,MANTBGNEG        ; ОЧЕРЕДНОЙ ЦИФРЫ ЧАСТНОГО.

CALCDIGIT:  IN R16,SREG                 ;
            SBRS R16,SREG_N             ; ОСТАТОК ОТРИЦАТЕЛЬНЫЙ?
            SBR Q0,1                    ; НЕТ, УСТАНАВЛИВАЕМ ТЕКУЩУЮ ЦИФРУ ЧАСТНОГО В 1.

            DEC STEPS                   ; ВЫЧИСЛЕНЫ ВСЕ ЦИФРЫ ЧАСТНОГО?
            BREQ RESTPOSREM             ; ДА, ВОССТАНАВЛИВАЕМ ПОСЛЕДНИЙ ПОЛОЖИТЕЛЬНЫЙ ОСТАТОК.

            CLC                         ; ОСВОБОЖДАЕМ И ЗАНУЛЯЕМ LSB ДЛЯ СЛЕДУЮЩЕЙ ЦИФРЫ ЧАСТНОГО.
            ROL Q0                      ;
            ROL Q1                      ; 
            ROL Q2                      ;
            ROL Q3                      ;

            CLC                         ; СДВИГАЕМ ОСТАТОК ВЛЕВО ВМЕСТЕ С ВИРТУАЛЬНОЙ
            ROL MANTA0                  ; РАЗРЯДНОЙ СЕТКОЙ, КОТОРАЯ ПРИВЯЗАНА К НЕМУ.
            ROL MANTA1                  ; НЕПОДВИЖНАЯ МАНТИССА ДЕЛИТЕЛЯ В ЭТОЙ СЕТКЕ
            ROL MANTA2                  ; СТАНЕТ ЭКВИВАЛЕНТНА УМНОЖЕННОЙ НА ВЕС СЛЕДУЮЩЕЙ
            ROL MANTAG                  ; МЛАДШЕЙ ЦИФРЫ ЧАСТНОГО, КОТОРУЮ МЫ БУДЕМ ВЫЯСНЯТЬ.

            IN R16,SREG                 ;
            SBRS R16,SREG_N             ; ОСТАТОК ПОЛОЖИТЕЛЬНЫЙ?
            RJMP SUBMANTB               ; ДА, ОТНИМАЕМ МАНТИССУ ДЕЛИТЕЛЯ.
            ADD MANTA0,MANTB0           ; НЕТ, ПРИБАВЛЯЕМ МАНТИССУ ДЕЛИТЕЛЯ.
            ADC MANTA1,MANTB1           ;
            ADC MANTA2,MANTB2           ;
            ADC MANTAG,MANTBG           ;
            RJMP CALCDIGIT              ; ОПРЕДЕЛЯЕМ СЛЕДУЮЩУЮ ЦИФРУ ЧАСТНОГО.

RESTPOSREM: IN R16,SREG                 ;
            SBRS R16,SREG_N             ; ПОСЛЕДНИЙ ОСТАТОК УЖЕ ПОЛОЖИТЕЛЬНЫЙ?
            RJMP CALCSTICKY             ; ДА, ПЕРЕХОДИМ К ВЫЧИСЛЕНИЮ STICKY-БИТА.
            ADD MANTA0,MANTB0           ; НЕТ, ВОССТАНАВЛИВАЕМ ДО ПОСЛЕДНЕГО ПОЛОЖИТЕЛЬНОГО.
            ADC MANTA1,MANTB1           ;
            ADC MANTA2,MANTB2           ;
            ADC MANTAG,MANTBG           ;

            ;
            ; ВЫЧИСЛЕНИЕ STICKY-БИТА ДЛЯ КОРРЕКТНОГО ОКРУГЛЕНИЯ К БЛИЖАЙШЕМУ.
            ;
            ; ЕСЛИ ОСТАТОК НЕНУЛЕВОЙ, ЗНАЧИТ СПРАВА ОТ ЧАСТНОГО СУЩЕСТВУЮТ НЕНУЛЕВЫЕ БИТЫ.
            ; S=1, R>0
            ; S=0, R=0
CALCSTICKY: COM MANTA0                  ; ВЫЧИСЛЕНИЕ ДОП. КОДА ОСТАТКА.
            COM MANTA1                  ; ИНВЕРТИРУЕМ ОСТАТОК: 2^N-1-A < 2^N (ДЛЯ ВСЕХ ЗНАЧЕНИЙ A).
            COM MANTA2                  ; ПРИБАВЛЯЕМ ЕДИНИЦУ: 2^N-1-A+1=2^N-A < 2^N (ТОЛЬКО ДЛЯ НЕНУЛЕВЫХ A).
            COM MANTAG                  ; СЛЕДОВАТЕЛЬНО, ТОЛЬКО ПРИ НУЛЕВОМ ОСТАТКЕ
            LDI R16,1                   ; ИЗ СТАРШЕГО БАЙТА БУДЕТ ЕДИНИЦА ПЕРЕНОСА.
            ADD MANTA0,R16              ; А ЭТО ЗНАЧИТ, ЧТО S=NOT(C).
            LDI R16,0                   ;
            ADC MANTA1,R16              ;
            ADC MANTA2,R16              ;
            ADC MANTAG,R16              ;

            IN R16,SREG                 ; КОНВЕРТИРУЕМ БИТ ПЕРЕНОСА В S-БИТ.
            LDI R17,1                   ; 
            EOR R16,R17                 ;
            OUT SREG,R16                ;

            ROL Q0                      ; ДОБАВЛЯЕМ СПРАВА К МАНТИССЕ ЧАСТНОГО ЗНАЧЕНИЕ S-БИТА.
            ROL Q1                      ; 
            ROL Q2                      ;
            ROL Q3                      ;

            ;
            ; НОРМАЛИЗАЦИЯ МАНТИССЫ ЧАСТНОГО.
            ;
            ; МАНТИССА ЧАСТНОГО ЛЕЖИТ В ИНТЕРВАЛЕ (0.5, 2)
            ; ПОЭТОМУ ДЕНОРМАЛИЗАЦИЯ ВОЗМОЖНА ТОЛЬКО НА 1 РАЗРЯД ВПРАВО.
            SBRC Q3,2                   ; ЦЕЛОЧИСЛЕННАЯ ЕДИНИЦА В ЧАСТНОМ ЕСТЬ?
            RJMP CHECKEXP               ; ДА, ЧАСТНОЕ НОРМАЛИЗОВАНО, ПРОВЕРЯЕМ ЭКСПОНЕНТУ.
            CLC                         ; НЕТ, НОРМАЛИЗУЕМ ВЛЕВО НА 1 РАЗРЯД.
            ROL Q0                      ;
            ROL Q1                      ;
            ROL Q2                      ;
            ROL Q3                      ;
                                        
            LDI R16,0xFF                ; УМЕНЬШАЕМ ЭКСПОНЕНТУ ЧАСТНОГО НА 1.
            LDI R17,0XFF                ;
            ADD EXPR0,R16               ;
            ADC EXPR1,R17               ;

            ;
            ; ПРОВЕРКА ЭКСПОНЕНТЫ НА ПЕРЕПОЛНЕНИЕ/АНТИПЕРЕПОЛНЕНИЕ.
            ;
            ; ПЕРЕПОЛНЕНИЕ: EXP > 127+127=254. ПО СТАНДАРТУ - УСТАНОВКА INF. ТЕКУЩАЯ РЕАЛИЗАЦИЯ - ВЫБРОС ИСКЛЮЧЕНИЯ.
            ; АНТИПЕРЕПОЛНЕНИЕ: EXP < -126+127=1. ПО СТАНДАРТУ - ПЕРЕХОД К ДЕНОРМАЛИЗОВАННОМУ ЧИСЛУ. ТЕКУЩАЯ РЕАЛИЗАЦИЯ - УСТАНОВКА ЧАСТНОГО В НОЛЬ.
CHECKEXP:   MOV R18,EXPR0               ; КОПИРУЕМ РАСШИРЕННУЮ ЭКСПОНЕНТУ ЧАСТНОГО.
            MOV R19,EXPR1               ;

            LDI R16,255                 ; ФОРМИРУЕМ -1 В ДОП. КОДЕ.
            LDI R17,255                 ; 
            ADD R16,R18                 ; ЕСЛИ ИСТИННАЯ ЭКСПОНЕНТА МЕНЬШЕ МИНИМАЛЬНОГО ПРЕДСТАВИМОГО ЗНАЧЕНИЯ (-126),
            ADC R17,R19                 ; ТО В КОДЕ СО СМЕЩЕНИЕМ ПОСЛЕ ВЫЧИТАНИЯ ЕДИНИЦЫ БУДЕТ ПОЛУЧЕНО ОТРИЦАТЕЛЬНОЕ ЧИСЛО.
            IN R16,SREG                 ; 
            SBRC R16,SREG_N             ; ЭКСПОНЕНТА В ПРЯМОМ КОДЕ МЕНЬШЕ -126?
            RJMP SETZERO                ; ДА, АНТИПЕРЕПОЛНЕНИЕ, ВОЗВРАЩАЕМ НОЛЬ.
                                        ; 
            LDI R16,1                   ; НЕТ, ПРОВЕРЯЕМ ЭКСПОНЕНТУ НА ПЕРЕПОЛНЕНИЕ.
            LDI R17,0                   ; ЕСЛИ ИСТИННАЯ ЭКСПОНЕНТА БОЛЬШЕ МАКСИМАЛЬНОГО ПРЕДСТАВИМОГО ЗНАЧЕНИЯ (127),
            ADD R16,R18                 ; ТО В КОДЕ СО СМЕЩЕНИЕМ ПОСЛЕ ПРИБАВЛЕНИЯ ЕДИНИЦЫ СТАРШИЙ БАЙТ РАСШИРЕННОЙ ЭКСПОНЕНТЫ
            ADC R17,R19                 ; БУДЕТ ОТЛИЧЕН ОТ НУЛЯ.
            COM R17                     ; ЕСЛИ СТАРШИЙ БАЙТ СОДЕРЖИТ НОЛЬ,
            LDI R16,1                   ; ТО ВЫЧИСЛЕНИЕ ДОП. КОДА ДАСТ НОЛЬ.
            ADD R16,R17                 ; ЭКСПОНЕНТА В ПРЯМОМ КОДЕ МЕНЬШЕ 128?
            BREQ ROUND                  ; ДА, ПЕРЕПОЛНЕНИЯ НЕТ, ПЕРЕХОДИМ К ОКРУГЛЕНИЮ.
            IJMP                        ; НЕТ, ПЕРЕПОЛНЕНИЕ, ПРЫЖОК НА ОБРАБОТЧИК ОШИБОК, УКАЗАННЫЙ В Z.

            ;
            ; ОКРУГЛЕНИЕ К БЛИЖАЙШЕМУ.
            ;
            ; ВОЗМОЖНЫЕ СОЧЕТАНИЯ БИТОВ RS. ДЛЯ КРАТКОСТИ GUARD-БИТ ЗДЕСЬ НЕ УЧИТЫВАЕТСЯ, ИЛЛЮСТРИРУЕТСЯ САМА ИДЕЯ ОКРУГЛЕНИЯ.
            ; RS
            ; --
            ; 00: ТОЧНОЕ ЗНАЧЕНИЕ. |ERR| = 0.
            ; 01: ОТБРАСЫВАЕМ. |ERR| < 2^-24=2^-23/2=ULP/2. ОШИБКА МЕНЬШЕ ПОЛОВИНЫ ВЕСА ПОСЛЕДНЕГО РАЗРЯДА МАНТИССЫ ОДИНАРНОЙ ТОЧНОСТИ.
            ; 10: ЕСЛИ ТАКАЯ СИТУАЦИЯ ИМЕЕТ МЕСТО, ТО ДЕЛИМОЕ ИМЕЕТ НЕНУЛЕВЫЕ РАЗРЯДЫ ЗА ПРЕДЕЛАМИ ДОСТУПНОЙ СЕТКИ, ЧТО НЕ ВОЗМОЖНО В НАШЕМ СЛУЧАЕ (ОБОСНОВАНИЕ - В ДОКАХ).
            ; 11: ОТБРАСЫВАЕМ И ПРИБАВЛЯЕМ 2^-23. |ERR| < 2^-24=ULP/2.
            ;
            ; КОММЕНТАРИИ К ПОСЛЕДНЕМУ СЛУЧАЮ:
            ; Q - ИСТИННАЯ МАНТИССА ЧАСТНОГО (БЕСКОНЕЧНАЯ ТОЧНОСТЬ).
            ; Q' - ОКРУГЛЕННОЕ ЗНАЧЕНИЕ.
            ; Q' = Q-(2^-24+A)+2^-23, ГДЕ A - БИТЫ ЗА ПРЕДЕЛАМИ СЕТКИ ВПРАВО ОТ R, ИНДИКАТОРОМ КОТОРЫХ ЯВЛЯЕТСЯ S-БИТ, СЛЕДОВАТЕЛЬНО, A < 2^-24.
            ; 2^-23 = 2^-24+2^-24 = 2^-24+(A+B), ГДЕ (A+B) = 2^-24, НО A > 0, СЛЕДОВАТЕЛЬНО B < 2^-24.
            ; ТОГДА МОЖЕМ ЗАПИСАТЬ Q' = Q-2^-24-A+2^-24+A+B = Q+B, ГДЕ B < 2^-24.
            ; ПОЭТОМУ В ПОСЛЕДНЕМ СЛУЧАЕ |ERR| < 2^-24=ULP/2.
ROUND:      MOV RGSBITS,Q0              ; ИЗВЛЕКАЕМ RGS-БИТЫ ИЗ МЛАДШЕГО БАЙТА МАНТИССЫ ЧАСТНОГО.
            LDI R16,RGSMASK             ;
            AND RGSBITS,R16             ;

            LDI STEPS,3                 ; ОТБРАСЫВАЕМ RGS-БИТЫ В МАНТИССЕ ЧАСТНОГО.
RSHIFT3:    CLC                         ; МЫ ВЫЧИСЛЯЛИ 26 ЦИФР ЧАСТНОГО + S-БИТ,
            ROR Q3                      ; ПОЭТОМУ ПОСЛЕ СДВИГА ВСЕ ЦИФРЫ МАНТИССЫ ЧАСТНОГО
            ROR Q2                      ; ПОМЕСТЯТСЯ В ТРЕХ МЛАДШИХ БАЙТАХ.
            ROR Q1                      ;
            ROR Q0                      ;
            DEC STEPS                   ;
            BRNE RSHIFT3                ;

            LDI R16,0xFC                ; ЕСЛИ В RGS УСТАНОВЛЕН БИТ R И ЕСТЬ НЕНУЛЕВЫЕ БИТЫ СПРАВА ОТ НЕГО,
            ADD RGSBITS,R16             ; ТОГДА В RGS НАХОДИТСЯ ЧИСЛО БОЛЬШЕ 4, А ЗНАЧИТ, ОТБРАСЫВАЯ RGS
            IN R16,SREG                 ; МЫ ПОЛУЧАЕМ ОШИБКУ БОЛЬШЕ ULP/2.
            SBRC R16, SREG_N            ; ОТБРОСИЛИ БОЛЬШЕ ULP/2?
            RJMP PACK                   ; НЕТ, ПАКУЕМ ЧАСТНОЕ.

            LDI R16,1                   ; ДА, ПРИБАВЛЯЕМ 2^-23.
            ADD Q0,R16                  ; ПЕРЕПОЛНЕНИЯ ПРИ ЭТОМ НЕ БУДЕТ (БОЛЕЕ ДЕТАЛЬНОЕ ОБОСНОВАНИЕ - В ДОКАХ).
            LDI R16,0                   ; НОРМАЛИЗОВАННАЯ МАНТИССА, КОТОРАЯ ДАСТ ПЕРЕПОЛНЕНИЕ - БОЛЬШЕ МАКСИМАЛЬНОЙ ВОЗМОЖНОЙ НОРМАЛИЗОВАННОЙ МАНТИССЫ,
            ADC Q1,R16                  ; А ДЕНОРМАЛИЗОВАННАЯ МАНТИССА, КОТОРАЯ ДАСТ ПОСЛЕ НОРМАЛИЗАЦИИ ПЕРЕПОЛНЕНИЕ,
            ADC Q2,R16                  ; МОЖЕТ БЫТЬ ПОЛУЧЕНА ТОЛЬКО ЕСЛИ ДЕЛИМОЕ ИМЕЕТ НЕНУЛЕВЫЕ РАЗРЯДЫ ЗА ПРЕДЕЛАМИ ОДИНАРНОЙ ТОЧНОСТИ, ЧТО НЕВОЗМОЖНО В НАШЕМ СЛУЧАЕ.

            ;
            ; УПАКОВКА ЗНАКА, МАНТИССЫ И ЭКСПОНЕНТЫ ЧАСТНОГО И ЗАПИСЬ НА МЕСТО ДЕЛИМОГО.
            ; НОРМАЛИЗОВАННАЯ И ОКРУГЛЕННАЯ МАНТИССА ЧАСТНОГО ТЕПЕРЬ ЗАНИМАЕТ 3 МЛАДШИХ БАЙТАХ.
PACK:       ROL Q0                      ; СДВИГАЕМ МАНТИССУ ВЛЕВО, УБИРАЯ ЦЕЛОЧИСЛЕННУЮ ЕДИНИЦУ.
            ROL Q1                      ;
            ROL Q2                      ;

            CLC                         ; ВЫДВИГАЕМ ВПРАВО LSB ЭКСПОНЕНТЫ В РАЗРЯД ПЕРЕНОСА,
            ROR EXPR0                   ; ОДНОВРЕМЕННО ОСВОБОЖДАЯ MSB ПОД ЗНАК.

            ROR Q2                      ; ВОЗВРАЩАЕМ МАНТИССУ НА МЕСТО
            ROR Q1                      ; С LSB ЭКСПОНЕНТЫ ВМЕСТО ЦЕЛОЧИСЛЕННОЙ ЕДИНИЦЫ.
            ROR Q0                      ;

            OR EXPR0,RSIGN              ; УСТАНАВЛИВАЕМ РАЗРЯД ЗНАКА.

            ;
            ; ЗАПИСЬ МАНТИССЫ ЧАСТНОГО НА МЕСТО ДЕЛИМОГО.
            MOV MANTA0,Q0
            MOV MANTA1,Q1
            MOV MANTA2,Q2

            RJMP EXIT

;
; УМНОЖАЕТ ДВА ЧИСЛА
; ПО СХЕМЕ С НЕПОДВИЖНЫМ МНОЖИТЕЛЕМ.
;
; МНОЖИМОЕ ОЖИДАЕТСЯ В РЕГИСТРАХ: R11, R10, R9, R8.
; МНОЖИТЕЛЬ ОЖИДАЕТСЯ В РЕГИСТРАХ: R15, R14, R13, R12. 
; ПРОИЗВЕДЕНИЕ ПОМЕЩАЕТСЯ НА МЕСТО МНОЖИМОГО: R11, R10, R9, R8.
FMUL32:     ;
            ; ФИЛЬТРАЦИЯ ОПЕРАНДОВ.
            CLR R16                     ;
            OR R16,R8                   ;
            OR R16,R9                   ;
            OR R16,R10                  ;
            OR R16,R11                  ;
            IN R16,SREG                 ; 
            SBRC R16,SREG_Z             ; МНОЖИМОЕ РАВНО НУЛЮ?
            RJMP SETZERO                ; ДА, ВОЗВРАЩАЕМ НОЛЬ.

            CLR R16                     ; НЕТ, ПРОВЕРЯЕМ МНОЖИТЕЛЬ.
            OR R16,R12                  ;
            OR R16,R13                  ;
            OR R16,R14                  ;
            OR R16,R15                  ;
            IN R16,SREG                 ; 
            SBRC R16,SREG_Z             ; МНОЖИТЕЛЬ РАВЕН НУЛЮ?
            RJMP SETZERO                ; ДА, ВОЗВРАЩАЕМ НОЛЬ.

            ;
            ; ОПРЕДЕЛЕНИЕ ЗНАКА ПРОИЗВЕДЕНИЯ.
            MOV RSIGN,R11               ; КОПИРУЕМ СТАРШИЙ БАЙТ МНОЖИМОГО.
            MOV R1,R15                  ; КОПИРУЕМ СТАРШИЙ БАЙТ МНОЖИТЕЛЯ.
            LDI R16,0b10000000          ; ЗАГРУЖАЕМ МАСКУ ЗНАКА.
            AND RSIGN,R16               ; ИЗВЛЕКАЕМ ЗНАК МНОЖИМОГО.
            AND R1,R16                  ; ИЗВЛЕКАЕМ ЗНАК МНОЖИТЕЛЯ.
            EOR RSIGN,R1                ; ОПРЕДЕЛЯЕМ ЗНАК ПРОИЗВЕДЕНИЯ.

            ;
            ; РАСПАКОВКА МНОЖИМОГО.
            ROL R10                     ; MSB МАНТИССЫ СОДЕРЖИТ LSB ЭКСПОНЕНТЫ. СДВИГАЕМ ЕГО В БИТ ПЕРЕНОСА.
            ROL R11                     ; ИЗБАВЛЯЕМСЯ ОТ ЗНАКА И ВОССТАНАВЛИВАЕМ МЛАДШИЙ БИТ ЭКСПОНЕНТЫ.
            SEC                         ; ВОССТАНАВЛИВАЕМ СКРЫТУЮ ЕДИНИЦУ МАНТИССЫ.
            ROR R10                     ; ВОЗВРАЩАЕМ НА МЕСТО СТАРШИЙ БАЙТ МАНТИССЫ.

            ;
            ; РАСПАКОВКА МНОЖИТЕЛЯ.
            ROL R14                     ; ТО ЖЕ САМОЕ ЧТО И ДЛЯ МНОЖИМОГО.
            ROL R15                     ; 
            SEC                         ;
            ROR R14                     ; 

            ;
            ; ВЫЧИСЛЕНИЕ ЭКСПОНЕНТЫ ПРОИЗВЕДЕНИЯ.
            ;
            ; ПОСКОЛЬКУ ЭКСПОНЕНТЫ ПРЕДСТАВЛЕНЫ В КОДЕ СО СМЕЩЕНИЕМ, ТО
            ; ИХ ЗНАЧЕНИЯ ВСЕГДА ЯВЛЯЮТСЯ ПОЛОЖИТЕЛЬНЫМИ ЧИСЛАМИ В ДИАПАЗОНЕ [1,254].
            CLR EXPA1
            CLR EXPB1
            
            ADD EXPA0,EXPB0             ; EXPA=EXPA+EXPB.
            ADC EXPA1,EXPB1             ; СУММА ЭКСПОНЕНТ СОДЕРЖИТ ИЗБЫТОЧНОЕ ЗНАЧЕНИЕ 127.
            LDI R16,-127                ; НЕОБХОДИМО ОТНЯТЬ ЭТО ЗНАЧЕНИЕ.
            LDI R17,255                 ; ФОРМИРУЕМ ДОП. КОД ДЛЯ -127 В ДВОЙНОЙ СЕТКЕ.
            ADD EXPA0,R16               ; ВОССТАНАВЛИВАЕМ СУММУ ЭКСПОНЕНТ
            ADC EXPA1,R17               ; В КОДЕ СО СМЕЩЕНИЕМ.

            ;
            ; ВЫЧИСЛЕНИЕ МАНТИССЫ ПРОИЗВЕДЕНИЯ.
            LDI R22,24                  ; КОЛИЧЕСТВО ШАГОВ ЦИКЛА РАВНО КОЛИЧЕСТВУ ЦИФР МНОЖИМОГО.

            CLR MANTP0                  ; ЗАНУЛЯЕМ ПРОИЗВЕДЕНИЕ.
            CLR MANTP1                  ;
            CLR MANTP2                  ;
            CLR MANTP3                  ;
            CLR MANTP4                  ;
            CLR MANTP5                  ;

NEXTDIGIT:  ROR MANTA2                  ; ИЗВЛЕКАЕМ ОЧЕРЕДНУЮ ЦИФРУ МНОЖИМОГО.
            ROR MANTA1                  ;
            ROR MANTA0                  ;
                                        
            IN R16,SREG                 ; 
            SBRS R16,SREG_C             ; ЦИФРА РАВНА 1?
            RJMP LOOPCOND0              ; НЕТ, РАВНА 0, МНОЖИТЕЛЬ НЕ ПРИБАВЛЯЕМ.
            ADD MANTP3,MANTB0           ; ДА, ПРИБАВЛЯЕМ МНОЖИТЕЛЬ К АККУМУЛЯТОРУ.
            ADC MANTP4,MANTB1           ; МЛАДШИЕ 3 БАЙТА МНОЖИТЕЛЯ В ДВОЙНОЙ СЕТКЕ НУЛЕВЫЕ,
            ADC MANTP5,MANTB2           ; ПОЭТОМУ ДОСТАТОЧНО СЛОЖИТЬ ТОЛЬКО СТАРШИЕ БАЙТЫ.

LOOPCOND0:  DEC R22                     ; ЭТО БЫЛА ПОСЛЕДНЯЯ ЦИФРА МНОЖИМОГО?
            BREQ CHECKOVF0              ; ДА, МАНТИССА ПРОИЗВЕДЕНИЯ ВЫЧИСЛЕНА, ПРОВЕРЯЕМ ЕЁ НА ПЕРЕПОЛНЕНИЕ.

            ROR MANTP5                  ; НЕТ, ДЕЛИМ АККУМУЛЯТОР НА 2.
            ROR MANTP4                  ;
            ROR MANTP3                  ;
            ROR MANTP2                  ;
            ROR MANTP1                  ;
            ROR MANTP0                  ;            

            RJMP NEXTDIGIT              ; ПЕРЕХОДИМ К СЛЕДУЮЩЕЙ ЦИФРЕ МНОЖИМОГО.

CHECKOVF0:  IN R16,SREG                 ; 
            SBRS R16,SREG_C             ; МАНТИССА ПРОИЗВЕДЕНИЯ ДАЛА ПЕРЕПОЛНЕНИЕ?
            RJMP ROUNDPROD              ; НЕТ, ПЕРЕХОДИМ К ЕЁ ОКРУГЛЕНИЮ.
            ROR MANTP5                  ; ДА, НОРМАЛИЗУЕМ МАНТИССУ ПРОИЗВЕДЕНИЯ ВПРАВО НА 1 РАЗРЯД.
            ROR MANTP4                  ;
            ROR MANTP3                  ;
            ROR MANTP2                  ;
            ROR MANTP1                  ;
            ROR MANTP0                  ;

            LDI R16,1                   ; КОРРЕКТИРУЕМ ЭКСПОНЕНТУ.
            ADD EXPA0,R16               ;
            LDI R16,0                   ;
            ADC EXPA1,R16               ;

            ;
            ; ОКРУГЛЕНИЕ МАНТИССЫ ПРОИЗВЕДЕНИЯ.
            ;
            ; ПОСЛЕ УСТАНОВКИ S-БИТА И ИЗВЛЕЧЕНИЯ ПАРЫ RS
            ; MANTP2 МОЖЕТ СОДЕРЖАТЬ СЛЕДУЮЩИЕ ЗНАЧЕНИЯ:
            ; - 0b11000000
            ; - 0b10000000
            ; - 0b01000000
            ; - 0b00000000
ROUNDPROD:  CLR GUARD
            CLC
            
            ROL MANTP0                  ; СДВИГАЕМ R-БИТ В GUARD-РЕГИСТР.
            ROL MANTP1                  ; ТЕПЕРЬ МЛАДШАЯ ЧАСТЬ СОДЕРЖИТ ТОЛЬКО БИТЫ ПОСЛЕ R.
            ROL MANTP2                  ;
            ROL GUARD                   ;

            COM MANTP0                  ; ЕСЛИ ПОСЛЕ R-БИТА ВСЕ БИТЫ НУЛЕВЫЕ,
            COM MANTP1                  ; ТО ВЫЧИСЛЕНИЕ ДОП. КОДА МЛАДШЕЙ ЧАСТИ
            COM MANTP2                  ; ДАСТ БИТ ПЕРЕНОСА.
            LDI R16,1                   ; ПОЭТОМУ ОТСУТСТВИЕ БИТА ПЕРЕНОСА
            ADD MANTP0,R16              ; ИСПОЛЬЗУЕМ КАК ПРИЗНАК ТОГО,
            LDI R16,0                   ; ЧТО ПОСЛЕ R-БИТА ЕСТЬ ХОТЯ БЫ ОДИН НЕНУЛЕВОЙ БИТ.
            ADC MANTP1,R16              ;
            ADC MANTP2,R16              ;

            IN R16,SREG                 ;
            SBRS R16,SREG_C             ; ПОСЛЕ R-БИТА ЕСТЬ НЕНУЛЕВЫЕ БИТЫ?
            SBR MANTP2,0b10000000       ; ДА, УСТАНАВЛИВАЕМ S-БИТ.

            ROR GUARD                   ; НЕТ, ВСЯ МЛАДШАЯ ЧАСТЬ НУЛЕВАЯ (ВКЛЮЧАЯ S-БИТ, ПОЭТОМУ ЯВНО ОБНУЛЯТЬ S-БИТ НЕТ НЕОБХОДИМОСТИ).
            ROR MANTP2                  ; ВОССТАНАВЛИВАЕМ R-БИТ.
            ROR MANTP1                  ;
            ROR MANTP0                  ;

            LDI R16,0b11000000          ; ИЗВЛЕКАЕМ RS-БИТЫ.
            AND MANTP2,R16              ;

            CLR GUARD                   ; ИНТЕРПРЕТИРУЕМ РЕГИСТР С RS-БИТАМИ КАК ЧИСЛО И ФОРМИРУЕМ ЕГО ДОП. КОД.
            COM MANTP2                  ; ДОП. КОД ФОРМИРУЕМ В ДВОЙНОЙ СЕТКЕ, Т.К. ДЛЯ ПРЕДСТАВЛЕНИЯ В ДОП. КОДЕ
            COM GUARD                   ; ЗНАЧЕНИЙ 0b11000000 И 0b10000000 СО ЗНАКОМ МИНУС
            LDI R16,1                   ; ОДИНАРНОЙ СЕТКИ УЖЕ НЕ ДОСТАТОЧНО.
            ADD MANTP2,R16              ;
            LDI R16,0                   ;
            ADC GUARD,R16               ;

            CLR STATUS0                 ; РАЗНОСТЬ МЕЖДУ ОПОРНЫМ ЗНАЧЕНИМ 0b10000000 И ЧИСЛОВОЙ ИНТЕРПРЕТАЦИЕЙ RS
            CLR STATUS1                 ; ОДНОЗНАЧНО СВЯЗАНА С НАПРАВЛЕНИЕМ ОКРУГЛЕНИЯ (СМ. ДОКУ).
            LDI R16,0b10000000          ; ЗА ПРИЗНАК БЕРЕМ НУЛЕВОЙ РЕЗУЛЬТАТ И ЗНАК ПОЛУЧЕННОЙ РАЗНОСТИ.
            ADD MANTP2,R16              ; 
            IN STATUS0,SREG             ; СОХРАНЯЕМ ФЛАГИ ПОСЛЕ ОПЕРАЦИИ С МЛАДШИМ БАЙТОМ.
            LDI R16,0                   ; 
            ADC GUARD,R16               ;
            IN STATUS1,SREG             ; СОХРАНЯЕМ ФЛАГИ ПОСЛЕ ОПЕРАЦИИ СО СТАРШИМ БАЙТОМ.

            SBRS STATUS1,SREG_N         ; RS=0b11000000? [NOTE: ОТРИЦАТЕЛЬНАЯ РАЗНОСТЬ ВОЗМОЖНА ТОЛЬКО В СИТУАЦИИ 0b10000000-0b11000000.]
            RJMP HALFWAY                ; НЕТ, ПРОВЕРЯЕМ СЛЕДУЮЩИЙ ВАРИАНТ.
            LDI R16,1                   ; ДА, МЛАДШАЯ ЧАСТЬ БОЛЬШЕ ULP/2. ОКРУГЛЯЕМ В БОЛЬШУЮ СТОРОНУ.
            ADD MANTP3,R16              ; ОТБРАСЫВАЕМ МЛАДШУЮ ЧАСТЬ И ПРИБАВЛЯЕТ ULP.
            LDI R16,0                   ; ЭТО ЭКВИВАЛЕНТНО ПРИБАВЛЕНИЮ К МЛАДШЕЙ ЧАСТИ ВЕЛИЧИНЫ МЕНЬШЕ ULP/2,
            ADC MANTP4,R16              ; ПРИВОДЯЩЕМУ К ЗАНУЛЕНИЮ МЛАДШЕЙ ЧАСТИ И ПОЯВЛЕНИЮ БИТА ПЕРЕНОСА В MANTP3.
            ADC MANTP5,R16              ;
            RJMP CHECKOVF1              ;

HALFWAY:    AND STATUS1,STATUS0         ; РАЗНОСТЬ НУЛЕВАЯ, ЕСЛИ ФЛАГ Z БЫЛ УСТАНОВЛЕН ДЛЯ КАЖДОГО БАЙТА.
            SBRS STATUS1,SREG_Z         ; RS=0b10000000?
            RJMP CHECKEXP1              ; НЕТ, RS=0b01000000 ИЛИ RS=0b00000000. МЛАДШАЯ ЧАСТЬ МЕНЬШЕ ULP/2, ПРОСТО ОТБРАСЫВАЕМ ЕЁ. ПЕРЕПОЛНЕНИЕ ПРИ ОКРУГЛЕНИИ НЕ ВОЗМОЖНО - ПРОПУСКАЕМ ПРОВЕРКУ.
            LDI R16,0b00000001          ; ДА, СИММЕТРИЧНОЕ ОКРУГЛЕНИЕ. МЛАДШАЯ ЧАСТЬ РАВНА ULP/2, ОКРУГЛЯЕМ К ЧЕТНОМУ.
            AND R16,MANTP3              ; ИЗВЛЕКАЕМ ULP В R16.
            ADD MANTP3,R16              ; ЕСЛИ ULP=1, ТО СТАРШАЯ ЧАСТЬ НЕЧЕТНАЯ
            LDI R16,0                   ; И ПРИБАВЛЕНИЕ R16 (КОТОРЫЙ СОДЕРЖИТ ТАКЖЕ СОДЕРЖИТ 1) ДАСТ ПЕРЕХОД К ЧЕТНОМУ.
            ADC MANTP4,R16              ; ЕСЛИ ЖЕ ULP=0, ТО ЗНАЧЕНИЕ УЖЕ ЧЕТНОЕ
            ADC MANTP5,R16              ; И ПРИБАВЛЕНИЕ R16 (КОТОРЫЙ ТАКЖЕ СОДЕРЖИТ 0) НИКАКОГО ЭФФЕКТА НЕ ДАСТ, ОСТАВЛЯЯ ЗНАЧЕНИЕ ЧЕТНЫМ.

            ;
            ; ПРОВЕРКА МАНТИССЫ ПРОИЗВЕДЕНИЯ НА ПЕРЕПОЛНЕНИЕ ПОСЛЕ ОКРУГЛЕНИЯ.
CHECKOVF1:  IN R16,SREG                 ; 
            SBRS R16,SREG_C             ; ОКРУГЛЕНИЕ ДАЛО ПЕРЕПОЛНЕНИЕ?
            RJMP CHECKEXP1              ; НЕТ, ПЕРЕХОДИМ К ПРОВЕРКЕ ЭКСПОНЕНТЫ.
            ROR MANTP5                  ; ДА, НОРМАЛИЗУЕМ МАНТИССУ ПРОИЗВЕДЕНИЯ ВПРАВО НА 1 РАЗРЯД.
            ROR MANTP4                  ;
            ROR MANTP3                  ;

            LDI R16,1                   ; КОРРЕКТИРУЕМ ЭКСПОНЕНТУ.
            ADD EXPA0,R16               ;
            LDI R16,0                   ;
            ADC EXPA1,R16               ;

            ;
            ; ПРОВЕРКА ИТОГОВОГО ПРОИЗВЕДЕНИЯ НА ПЕРЕПОЛНЕНИЕ/АНТИПЕРЕПОЛНЕНИЕ ПО ЭКСПОНЕНТЕ.
            ;
            ; ЕСЛИ ЭКСПОНЕНТА МЕНЬШЕ -126 (-126+127=1 В КОДЕ СО СМЕЩЕНИЕМ), ТО ПРОИЗВЕДЕНИЕ СЛИШКОМ МАЛО И МЫ ПЕРЕХОДИМ К НУЛЮ.
            ; ЕСЛИ ЭКСПОНЕНТА БОЛЬШЕ 127 (127+127=254 В КОДЕ СО СМЕЩЕНИЕМ), ТО ПРОИЗВЕДЕНИЕ СЛИШКОМ ВЕЛИКО И МЫ ВЫБРАСЫВАЕМ ИСКЛЮЧЕНИЕ.
CHECKEXP1:  MOV R18,EXPR0               ; КОПИРУЕМ РАСШИРЕННУЮ ЭКСПОНЕНТУ ПРОИЗВЕДЕНИЯ.
            MOV R19,EXPR1               ;

            LDI R16,255                 ; ФОРМИРУЕМ -1 В ДОП. КОДЕ.
            LDI R17,255                 ; 
            ADD R16,R18                 ; ЕСЛИ ИСТИННАЯ ЭКСПОНЕНТА МЕНЬШЕ МИНИМАЛЬНОГО ПРЕДСТАВИМОГО ЗНАЧЕНИЯ (-126),
            ADC R17,R19                 ; ТО В КОДЕ СО СМЕЩЕНИЕМ ПОСЛЕ ВЫЧИТАНИЯ ЕДИНИЦЫ БУДЕТ ПОЛУЧЕНО ОТРИЦАТЕЛЬНОЕ ЧИСЛО.
            IN R16,SREG                 ; 
            SBRC R16,SREG_N             ; ЭКСПОНЕНТА В ПРЯМОМ КОДЕ МЕНЬШЕ -126?
            RJMP SETZERO                ; ДА, АНТИПЕРЕПОЛНЕНИЕ, ВОЗВРАЩАЕМ НОЛЬ.
                                        ; 
            LDI R16,1                   ; НЕТ, ПРОВЕРЯЕМ ЭКСПОНЕНТУ НА ПЕРЕПОЛНЕНИЕ.
            LDI R17,0                   ; ЕСЛИ ИСТИННАЯ ЭКСПОНЕНТА БОЛЬШЕ МАКСИМАЛЬНОГО ПРЕДСТАВИМОГО ЗНАЧЕНИЯ (127),
            ADD R16,R18                 ; ТО В КОДЕ СО СМЕЩЕНИЕМ ПОСЛЕ ПРИБАВЛЕНИЯ ЕДИНИЦЫ СТАРШИЙ БАЙТ РАСШИРЕННОЙ ЭКСПОНЕНТЫ БУДЕТ ОТЛИЧЕН ОТ НУЛЯ.
            ADC R17,R19                 ; ЭКСПОНЕНТА В ПРЯМОМ КОДЕ МЕНЬШЕ 128?
            BREQ PACKPROD               ; ДА, ПЕРЕПОЛНЕНИЯ НЕТ, ПЕРЕХОДИМ К УПАКОВКЕ.
            IJMP                        ; НЕТ, ПЕРЕПОЛНЕНИЕ, ПРЫЖОК НА ОБРАБОТЧИК ОШИБОК, УКАЗАННЫЙ В Z.
            
            ;
            ; УПАКОВКА МАНТИССЫ И ЭКСПОНЕНТЫ ПРОИЗВЕДЕНИЯ.
PACKPROD:   ROL MANTP3                  ; СДВИГАЕМ МАНТИССУ ВЛЕВО, УБИРАЯ ЦЕЛОЧИСЛЕННУЮ ЕДИНИЦУ.
            ROL MANTP4                  ;
            ROL MANTP5                  ;

            CLC                         ; ВЫДВИГАЕМ ВПРАВО LSB ЭКСПОНЕНТЫ В РАЗРЯД ПЕРЕНОСА,
            ROR EXPR0                   ; ОДНОВРЕМЕННО ОСВОБОЖДАЯ MSB ПОД ЗНАК.

            ROR MANTP5                  ; ВОЗВРАЩАЕМ МАНТИССУ НА МЕСТО
            ROR MANTP4                  ; С LSB ЭКСПОНЕНТЫ ВМЕСТО ЦЕЛОЧИСЛЕННОЙ ЕДИНИЦЫ.
            ROR MANTP3                  ;

            OR EXPR0,RSIGN              ; УСТАНАВЛИВАЕМ РАЗРЯД ЗНАКА.

            MOV MANTA0,MANTP3           ; ЗАПИСЬ МАНТИССЫ ПРОИЗВЕДЕНИЯ НА МЕСТО МАНТИССЫ МНОЖИМОГО.
            MOV MANTA1,MANTP4
            MOV MANTA2,MANTP5

            RJMP EXIT

            ; ВЫХОД.
EXIT:       RET

            ;
            ; УСТАНОВКА РЕЗУЛЬТАТА В НОЛЬ.
            ;
            ; ВЫПОЛНЯЕТСЯ В СЛЕДУЮЩИХ СЛУЧАЯХ:
            ; - АНТИПЕРЕПОЛНЕНИЕ РЕЗУЛЬТАТА ДЛЯ ЛЮБОЙ ОПЕРАЦИИ.
            ; - ДЕЛИМОЕ РАВНО НУЛЮ.
            ; - ХОТЯ БЫ ОДИН СОМНОЖИТЕЛЬ РАВЕН НУЛЮ.
            ; - ОБА СЛАГАЕМЫХ РАВНЫ НУЛЮ.
SETZERO:    CLR MANTA0
            CLR MANTA1
            CLR MANTA2
            CLR EXPA0
            RJMP EXIT

;
; ВЫЧИСЛЯЕТ РАЗНОСТЬ ДВУХ ПОЛОЖИТЕЛЬНЫХ ЧИСЕЛ.
;
; УМЕНЬШАЕМОЕ ОЖИДАЕТСЯ В РЕГИСТРАХ: R11, R10, R9, R8.
; ВЫЧИТАЕМОЕ СЛАГАЕМОЕ ОЖИДАЕТСЯ В РЕГИСТРАХ: R15, R14, R13, R12. 
; РАЗНОСТЬ ПОМЕЩАЕТСЯ НА МЕСТО УМЕНЬШАЕМОГО: R11, R10, R9, R8.
FSUB32:     LDI R16,0b10000000          ; B=-B.
            OR B3,R16                   ;
            RJMP FADD32                 ;

;
; СКЛАДЫВАЕТ ДВА ЧИСЛА.
;
; ПЕРВОЕ СЛАГАЕМОЕ ОЖИДАЕТСЯ В РЕГИСТРАХ: R11, R10, R9, R8.
; ВТОРОЕ СЛАГАЕМОЕ ОЖИДАЕТСЯ В РЕГИСТРАХ: R15, R14, R13, R12. 
; СУММА ПОМЕЩАЕТСЯ НА МЕСТО ПЕРВОГО СЛАГАЕМОГО: R11, R10, R9, R8.
FADD32:     ;
            ; СВОП.
            ; УСТАНОВКА НАИБОЛЬШЕГО (ПО МОДУЛЮ) ОПЕРАНДА ПЕРВЫМ.
            MOV R0,R8                   ; КОПИРУЕМ A.
            MOV R1,R9                   ;
            MOV R2,R10                  ;
            MOV R3,R11                  ;

            MOV R4,R12                  ; КОПИРУЕМ B.
            MOV R5,R13                  ;
            MOV R6,R14                  ;
            MOV R7,R15                  ;

            LDI R16,0b01111111          ;
            AND R3,R16                  ; ВЫЧИСЛЯЕМ |A|.
            AND R7,R16                  ; ВЫЧИСЛЯЕМ |B|.

            COM R4                      ; ВЫЧИСЛЯЕМ ДОП. КОД |B|.
            COM R5                      ;
            COM R6                      ;
            COM R7                      ;
            LDI R16,1                   ;
            ADD R4,R16                  ;
            LDI R16,0                   ;
            ADC R5,R16                  ;
            ADC R6,R16                  ;
            ADC R7,R16                  ;

            ADD R4,R0                   ; |A|-|B|. ПЕРЕЗАПИСЫВАЕМ КОПИЮ B,
            ADC R5,R1                   ; КОТОРАЯ УЖЕ И ТАК В ДОП. КОДЕ,
            ADC R6,R2                   ; ЧТОБЫ СОХРАНИТЬ НЕТРОНУТОЙ КОПИЮ A В ПРЯМОМ КОДЕ.
            ADC R7,R3                   ;
                                        ; |A|-|B|>=0?
            BRGE HANDLEZERO             ; ДА, СВОП НЕ НУЖЕН. ПЕРЕХОДИМ К ОБРАБОТКЕ НУЛЕВЫХ ОПЕРАНДОВ.
                                        ; НЕТ, ДЕЛАЕМ СВОП.
            MOV R3,R11                  ; БЭКАПИМ A. НО ПОСКОЛЬКУ РЕГИСТРЫ R0..R3 УЖЕ ХРАНЯТ |A|, ОСТАЕТСЯ ТОЛЬКО ВОССТАНОВИТЬ ЗНАК.
            
            MOV R8,R12                  ; ЗАПИСЫВАЕМ B НА МЕСТО A.
            MOV R9,R13                  ;
            MOV R10,R14                 ;
            MOV R11,R15                 ;

            MOV R12,R0                  ; ВОССТАНАВЛИВАЕМ ИЗ БЭКАПА A НА МЕСТО B.
            MOV R13,R1                  ;
            MOV R14,R2                  ;
            MOV R15,R3                  ;

            ;
            ; ОБРАБОТКА НУЛЕВЫХ ОПЕРАНДОВ.
            ;
            ; ВОЗМОЖНЫЕ СИТУАЦИИ ДО СВОПА (ГДЕ 1 - ЛЮБОЕ НЕНУЛЕВОЕ ЗНАЧЕНИЕ ОПЕРАНДА):
            ; 0,0
            ; 0,1
            ; 1,0
            ; 1,1
            ;
            ; ПОСЛЕ СВОПА ОСТАЮТСЯ ТОЛЬКО СЛЕДУЮЩИЕ ВАРИАНТЫ:
            ; 0,0
            ; 1,0
            ; 1,1
            ;
            ; СЛЕДОВАТЕЛЬНО, ЕСЛИ ПОСЛЕ СВОПА ПЕРВЫЙ ОПЕРАНД НУЛЕВОЙ, ЗНАЧИТ ОБА НУЛЕВЫЕ, РЕЗУЛЬТАТ - НОЛЬ.
            ; ЕСЛИ ВТОРОЙ ОПЕРАНД НУЛЕВОЙ, ЗНАЧИТ ПЕРВЫЙ НЕНУЛЕВОЙ, РЕЗУЛЬТАТ - ПЕРВЫЙ ОПЕРАНД.
HANDLEZERO: CLR R16                     ;
            OR R16,MANTA0               ;
            OR R16,MANTA1               ;
            OR R16,MANTA2               ;
            OR R16,EXPA0                ; A=0?
            BREQ SETZERO                ; ДА, И A И B РАВНЫ НУЛЮ, ВОЗВРАЩАЕМ НОЛЬ.

            CLR R16                     ; НЕТ, ПРОВЕРЯЕМ B.
            OR R16,MANTB0               ;
            OR R16,MANTB1               ;
            OR R16,MANTB2               ;
            OR R16,EXPB0                ; B=0?
            BREQ EXIT                   ; ДА, ВОЗВРАЩАЕМ A (A УЖЕ НАХОДИТСЯ В РЕГИСТРЕ РЕЗУЛЬТАТА).
                                        ; НЕТ, НИ A НИ B НЕ РАВНЫ НУЛЮ, ПРОДОЛЖАЕМ ВЫЧИСЛЕНИЯ.

            ;
            ; ОПРЕДЕЛЕНИЕ ЗНАКА СУММЫ.
            ;
            ; БЕРЕТСЯ ЗНАК ОПЕРАНДА A, КОТОРЫЙ ПОСЛЕ СВОПА УДОВЛЕТВОРЯЕТ ВЫРАЖЕНИЮ |A|>=|B|.
            ; ЕСЛИ |A|>|B| И ЗНАКИ РАЗНЫЕ, ТО ЗНАК РАЗНОСТИ РАВЕН ЗНАКУ НАИБОЛЬШЕГО (ПО МОДУЛЮ) ОПЕРАНДА, Т.Е. A.
            ; ЕСЛИ ЖЕ ЗНАКИ ОДИНАКОВЫЕ, ТО ЗНАК СУММЫ РАВЕН ЗНАКУ ЛЮБОГО ОПЕРАНДА, В Т.Ч. A.
            ; ЕСЛИ |A|=|B| И ЗНАКИ ОДИНАКОВЫЕ, ТО ЗНАК СУММЫ ТАКЖЕ РАВЕН ЗНАКУ ЛЮБОГО ОПЕРАНДА, В Т.Ч. A.
            ; ЕСЛИ ЖЕ ЗНАКИ РАЗНЫЕ, ТО В СИЛУ РАВЕНСТВА МОДУЛЕЙ, РАЗНОСТЬ БУДЕТ РАВНА НУЛЮ И БУДЕТ УСТАНОВЛЕН ПОЛОЖИТЕЛЬНЫЙ ЗНАК, НЕЗАВИСИМО ОТ ЗНАКОВ A И B.
CALCSIGN:   MOV RSIGN,R11               ; КОПИРУЕМ СТАРШИЙ БАЙТ A.
            LDI R16,0b10000000          ; ФОРМИРУЕМ МАСКУ ДЛЯ ИЗВЛЕЧЕНИЯ ЗНАКА, КОТОРЫЙ ХРАНИТСЯ В MSB.
            AND RSIGN,R16               ; ИЗВЛЕКАЕМ ЗНАК A.

            ;
            ; БЭКАП ЗНАКА B.
            ; 
            ; ОН БУДЕТ НУЖЕН ДЛЯ ОПРЕДЕЛЕНИЯ ОПЕРАЦИИ: СЛОЖЕНИЕ ИЛИ ВЫЧИТАНИЕ.
            MOV R1,R15                  ; КОПИРУЕМ СТАРШИЙ БАЙТ B.
            AND R1,R16                  ; ИЗВЛЕКАЕМ ЗНАК B. МАСКА ЗНАКА УЖЕ СОДЕРЖИТСЯ В R16.

            ;
            ; РАСПАКОВКА ОПЕРАНДОВ.
            ROL R8                      ; РАСПАКОВКА A.
            ROL R9                      ;
            ROL R10                     ; ВЫДВИГАЕМ В БИТ ПЕРЕНОСА LSB ЭКСПОНЕНТЫ.
            ROL R11                     ; ВОССТАНАВЛИВАЕМ ЭКСПОНЕНТУ В СТАРШЕМ БАЙТЕ.
            SEC                         ; ВОССТАНАВЛИВАЕМ В МАНТИССЕ A НЕЯВНУЮ ЕДИНИЦУ.
            ROR R10                     ;
            ROR R9                      ;
            ROR R8                      ;

            ROL R12                     ; РАСПАКОВКА B
            ROL R13                     ;
            ROL R14                     ;
            ROL R15                     ;
            SEC                         ;
            ROR R14                     ;
            ROR R13                     ;
            ROR R12                     ;

            ;
            ; РАСШИРЯЕМ ЭКСПОНЕНТУ A НА ОДИН БАЙТ ВЛЕВО.
            CLR EXPA1                   ;

            ;
            ; РАСШИРЕНИЕ МАНТИСС ДО RGS.
            ;
            ; ЭТИ РЕГИСТРЫ СТЫКУЮТСЯ СПРАВА ОТ МАНТИССЫ A И B.
            CLR R6                      ; RGS МАНТИССЫ A.
            CLR R7                      ; RGS МАНТИССЫ B.

            ;
            ; ВЫРАВНИВАНИЕ ПОРЯДКОВ.
            ;
            ; ЭКСПОНЕНТЫ ОБОИХ ОПЕРАНДОВ ПРЕДСТАВЛЕНЫ В КОДЕ СО СМЕЩЕНИЕМ И ПРИНИМАЮТ ЗНАЧЕНИЯ В ОТРЕЗКЕ [1,254].
            ; ПОСЛЕ СВОПА ПОРЯДОК A БУДЕТ ЛИБО БОЛЬШЕ ЛИБО РАВЕН ПОРЯДКУ B. ЭТО ЗНАЧИТ, ЧТО РАЗНОСТЬ ЭКСПОНЕНТ ЛЕЖИТ В ОТРЕЗКЕ [0,253].
            ; ИЗ ВСЕГО ЭТОГО СЛЕДУЕТ, ЧТО НЕТ НЕОБХОДИМОСТИ ВЫЧИСЛЯТЬ КОРРЕКТНЫЙ ДОП. КОД В ДВОЙНОЙ СЕТКЕ (СМ. ОБОСНОВАНИЕ В ДОКЕ).
            ;
            ; ЗДЕСЬ МОЖЕТ ПОТРЕБОВАТЬСЯ ОКРУЛЕНИЕ ДО S-БИТА ПРИ ДЕНОРМАЛИЗАЦИИ МАНТИССЫ B.
            MOV R17,EXPA0               ; КОПИРУЕМ ЭКСПОНЕНТУ A.
            MOV R16,EXPB0               ; КОПИРУЕМ ЭКСПОНЕНТУ B.
            COM R16                     ; ВЫЧИСЛЯЕМ ПСЕВДО ДОП. КОД ЭКСПОНЕНТЫ B.
            INC R16                     ;
            ADD R17,R16                 ; EXP(A)-EXP(B)=0? R17 ТЕПЕРЬ СОДЕРЖИТ РАЗНОСТЬ ЭКСПОНЕНТ В ОТРЕЗКЕ [1,253].
            BREQ CHOOSEOP               ; ДА, ПОРЯДКИ РАВНЫ, ВЫРАВНИВАНИЕ НЕ ТРЕБУЕТСЯ.
            LDI R16,31                  ; НЕТ, ВЫЯСНЯЕМ, В КАКОМ ОТРЕЗКЕ ЛЕЖИТ РАЗНОСТЬ: [1,30] ИЛИ [31,253].
            COM R16                     ; ФОРМИРУЕМ ДОП. КОД ЧИСЛА -31 В ПРЕДЕЛАХ БАЙТА. (НЕОБХОДИМОСТИ В ДВОЙНОЙ СЕТКЕ НЕТ. ОБОСНОВАНИЕ ЕСТЬ В ДОКЕ).
            INC R16                     ;
            ADD R16,R17                 ; (EXP(A)-EXP(B))-31<0? (ЕСЛИ ИСТИННАЯ РАЗНОСТЬ В ДВОЙНОЙ СЕТКЕ ОТРИЦАТЕЛЬНАЯ, ТО БИТА ПЕРЕНОСА ИЗ МЛАДШЕГО БАЙТА НЕ БУДЕТ).
            BRCC SHIFTMANTB             ; ДА, РАЗНОСТЬ В ОТРЕЗКЕ [1,30], СДВИГАЕМ МАНТИССУ B И ФОРМИРУЕМ S-БИТ.
            CLR MANTB0                  ; НЕТ, РАЗНОСТЬ В ОТРЕЗКЕ [31,253].
            CLR MANTB1                  ; ПРОСТО УСТАНАВЛИВАЕМ ЗНАЧЕНИЕ МАНТИССЫ B КАК 2^-31 (ОКРУГЛЕНИЕ ДО S-БИТА).
            CLR MANTB2                  ;
            LDI R16,0b00000001          ;
            MOV R7,R16                  ;
            RJMP CHOOSEOP               ;

            ;
            ; ПОШАГОВЫЙ СДВИГ МАНТИССЫ B НА РАЗНОСТЬ ЭКСПОНЕНТ ВПРАВО.
            ;
            ; РАЗНОСТЬ ЭКСПОНЕНТ ЗДЕСЬ ПРИНИМАЕТ ЗНАЧЕНИЯ В ОТРЕЗКЕ [1,30].
            ; ЕСЛИ ЗА ПРЕДЕЛАМИ RGS-ЗОНЫ ОКАЗАЛСЯ ХОТЯ БЫ ОДИН ЕДИНИЧНЫЙ БИТ, ТО ПРОИСХОДИТ УСТАНОВКА S-БИТА.
SHIFTMANTB: CLR R16                     ; R16 БУДЕТ ХРАНИТЬ В LSB ЗНАЧЕНИЕ БИТА ПЕРЕНОСА ПОСЛЕ КАЖДОГО СДВИГА.
            CLC                         ;
            ROR MANTB2                  ; СДВИГАЕМ МАНТИССУ B ВПРАВО НА 1 РАЗРЯД ВМЕСТЕ С RGS-БИТАМИ.
            ROR MANTB1                  ;
            ROR MANTB0                  ;
            ROR R7                      ;
            ROL R16                     ; ИЗВЛЕКАЕМ БИТА ПЕРЕНОСА В R16.
            OR R7,R16                   ; ЕСЛИ C!=0, ЗНАЧИТ ЗА ПРЕДЕЛАМИ RGS ОКАЗАЛСЯ ЕДИНИЧНЫЙ БИТ, ЗНАЧИТ УСТАНАВЛИВАЕМ S-БИТ.

            DEC R17                     ; МАНТИССА B СДВИНУТА НА РАЗНОСТЬ ПОРЯДКОВ?
            BREQ CHOOSEOP               ; ДА, ПЕРЕХОДИМ К ВЫБОРУ АРИФМЕТИЧЕСКОЙ ОПЕРАЦИИ.
            RJMP SHIFTMANTB             ; НЕТ, СДВИГАЕМ ДАЛЬШЕ.

            ;
            ; ВЫБОР АРИФМЕТИЧЕСКОЙ ОПЕРАЦИИ.
CHOOSEOP:   EOR R1,R0                   ; SIGN(A)=SIGN(B)?
            BRNE DIFF                   ; НЕТ, ЗНАКИ РАЗНЫЕ, ПЕРЕХОДИМ К ВЫЧИТАНИЮ.
                                        ; ДА, ВЫЧИСЛЯЕМ СУММУ.

            ;
            ; ВЫЧИСЛЕНИЕ СУММЫ МОДУЛЕЙ МАНТИСС.
            ;
            ; ЗДЕСЬ ВОЗМОЖНО ТОЛЬКО ПЕРЕПОЛНЕНИЕ РЕЗУЛЬТАТА.
            ; МАНТИССА СУММЫ ЗАПИСЫВАЕТСЯ НА МЕСТО МАНТИССЫ A.
SUM:        ADD R6,R7                   ; СКЛАДЫВАЕМ МАНТИССЫ A И B.
            ADD R8,R12                  ; У МАНТИССЫ A RGS-ЗОНА ВСЕГДА НУЛЕВАЯ, ПОЭТОМУ БИТ ПЕРЕНОСА НЕ ВОЗМОЖЕН.
            ADC R9,R13                  ;
            ADC R10,R14                 ;
                                        ; ПЕРЕПОЛНЕНИЕ ЕСТЬ?
            BRCC ROUNDSUM               ; НЕТ, ПЕРЕХОДИМ К ОКРУГЛЕНИЮ.
            ROR R10                     ; ДА, НОРМАЛИЗУЕМ МАНТИССУ ВПРАВО.
            ROR R9                      ;
            ROR R8                      ;
            ROR R6                      ;
            CLR R16                     ; УСТАНАВЛИВАЕМ S-БИТ, ЕСЛИ ПРИ НОРМАЛИЗАЦИИ БЫЛ ПОТЕРЯН ЕДИНИЧНЫЙ БИТ.
            ROL R16                     ; 
            OR R6,R16                   ;
            INC EXPA0                   ; КОРРЕКТИРУЕМ ЭКСПОНЕНТУ. В ХУДШЕМ СЛУЧАЕ ЭКСПОНЕНТА РАВНА 254 ПОЭТОМУ БИТА ПЕРЕНОСА В СТАРШИЙ БАЙТ НЕ БУДЕТ.
            RJMP ROUNDSUM               ;
            
            ;
            ; ВЫЧИСЛЕНИЕ РАЗНОСТИ МОДУЛЕЙ МАНТИСС.
            ;
            ; ЗДЕСЬ В ХУДШЕМ СЛУЧАЕ ВОЗМОЖНА ДЕНОРМАЛИЗАЦИЯ РЕЗУЛЬТАТА ВПРАВО В ОТРЕЗКЕ [0,24]
            ; ПРИ A=1 И B=((2^24)-1)*2^-23*2^-1.
DIFF:       COM R7                      ; ВЫЧИСЛЯЕМ ПСЕВДО ДОП. КОД МАНТИССЫ B. ЭТО ДОПОЛНЕНИЕ ДО 2 ВМЕСТО 4.
            COM MANTB0                  ; РЕЗУЛЬТАТ ВСЕГДА ПОЛОЖИТЕЛЬНЫЙ, ПОЭТОМУ НЕТ НЕОБХОДИМОСТИ В ИСТИННОМ ДОП. КОДЕ.
            COM MANTB1                  ; В ДОП. БИТЕ СЛЕВА ВСЕГДА БУДЕТ ЕДИНИЦА, А ИЗ МЛАДШЕЙ ЧАСТИ ВСЕГДА БУДЕТ БИТ ПЕРЕНОСА,
            COM MANTB2                  ; ЗАНУЛЯЮЩИЙ РАЗРЯД ИСТИННОГО ДОП. КОДА.
            LDI R16,1                   ;
            ADD R7,R16                  ;
            CLR R16                     ;
            ADC MANTB0,R16              ;
            ADC MANTB1,R16              ;
            ADC MANTB2,R16              ;

            LDI SREGACC,0b00000010      ; МАСКА ДЛЯ Z-ФЛАГА.
            ADD R6,R7                   ; СКЛАДЫВАЕМ RGS-РЕГИСТРЫ.
            IN R16,SREG                 ; ИЗВЛЕКАЕМ ИЗ РЕГИСТРА СТАТУСА ТОЛЬКО Z-ФЛАГ.
            AND SREGACC,R16             ;
            ADD MANTA0,MANTB0           ; СКЛАДЫВАЕМ СЛЕДУЮЩУЮ ПАРУ БАЙТ МАНТИСС. (У МАНТИССЫ A RGS-ЗОНА ВСЕГДА НУЛЕВАЯ, ПОЭТОМУ БИТ ПЕРЕНОСА ИЗ ПРЕДЫДУЩЕЙ ОПЕРАЦИИ НЕ ВОЗМОЖЕН.)
            IN R16,SREG                 ;
            AND SREGACC,R16             ;
            ADC MANTA1,MANTB1           ; СКЛАДЫВАЕМ СЛЕДУЮЩУЮ ПАРУ БАЙТ.
            IN R16,SREG                 ;
            AND SREGACC,R16             ;
            ADC MANTA2,MANTB2           ; СКЛАДЫВАЕМ ПОСЛЕДНЮЮ ПАРУ БАЙТ.
            IN R16,SREG                 ;
            AND SREGACC,R16             ; РЕЗУЛЬТАТ НУЛЕВОЙ? (SREGACC=STATUS0^STATUS1^STATUS2^STATUS3^0b00000010, ГДЕ STATUS<N>-РЕГИСТР СТАТУСА ПОСЛЕ СЛОЖЕНИЯ ОЧЕРЕДНОЙ ПАРЫ БАЙТ МАНТИСС.)
            BRNE SETZERO1               ; ДА, УСТАНАВЛИВАЕМ ПОЛОЖИТЕЛЬНЫЙ НОЛЬ. (ЕСЛИ ФЛАГ Z БЫЛ УСТАНОВЛЕН ДЛЯ КАЖДОЙ ПАРЫ БАЙТ, ТО SREGACC ОКАЖЕТСЯ НЕНУЛЕВЫМ).

            SBRC MANTA2,7               ; МАНТИССА РАЗНОСТИ ДЕНОРМАЛИЗОВАНА?
            RJMP ROUNDSUM               ; НЕТ, МАНТИССА НОРМАЛИЗОВАНА, ПЕРЕХОДИМ К ОКРУГЛЕНИЮ.
                                        ; ДА, ВЫПОЛНЯЕМ НОРМАЛИЗАЦИЮ И КОРРЕКЦИЮ ЭКСПОНЕНТЫ.
            CLR R16                     ; СЧЕТЧИК СТЕПЕНИ ДЕНОРМАЛИЗАЦИИ.
            LDI R17,255                 ; ШАГ СЧЕТЧИКА R17=-1. ФОРМИРУЕМ СЧЕТЧИК СРАЗУ В ДОП. КОДЕ.
NORM:       CLC                         ;
            ROL R6                      ; НОРМАЛИЗУЕМ ВЛЕВО.
            ROL MANTA0                  ;
            ROL MANTA1                  ;
            ROL MANTA2                  ;
            ADD R16,R17                 ; DEC R16.
            SBRS MANTA2,7               ; МАНТИССА РАЗНОСТИ НОРМАЛИЗОВАЛАСЬ?
            RJMP NORM                   ; НЕТ, ПРОДОЛЖАЕМ СДВИГ.
            ADD EXPA0,R16               ; ДА, КОРРЕКТИРУЕМ ЭКСПОНЕНТУ: EXPA-K, ГДЕ K - СТЕПЕНЬ ДЕНОРМАЛИЗАЦИИ.
            ADC EXPA1,R17               ; R17,R16 - РАСШИРИЛИ ДОП. КОД R16 ДО ДВУХ БАЙТ (ВОСПОЛЬЗОВАЛИСЬ ТЕМ, ЧТО R17 УЖЕ СОДЕРЖИТ 255).

            ;
            ; ОКРУГЛЕНИЕ.
            ;
            ; ПОСЛЕ СДВИГА R-БИТА ПРОИСХОДИТ ПРОВЕРКА C- И Z-БИТОВ В РЕГИСТРЕ СТАТУСА.
            ; ЕСЛИ Z=0 ПОСЛЕ СДВИГА, ТО ЭТО СИТУАЦИЯ СИММЕТРИЧНОГО ОКРУГЛЕНИЯ, ИНАЧЕ - ОКРУГЛЕНИЕ В БОЛЬШУЮ СТОРОНУ.
ROUNDSUM:   MOV R16,R6                  ; КОПИРУЕМ RGS.
            CLC                         ;
            ROL R16                     ; R-БИТ РАВЕН НУЛЮ?
            BRCC CHECKEXP2              ; ДА, RGS=000|001|010|011. ОТБРАСЫВАЕМ RGS, ОШИБКА ERR<ULP/2.
            BREQ HALFWAY1               ; НЕТ, RGS=ULP/2=100, СИММЕТРИЧНОЕ ОКРУГЛЕНИЕ.
            LDI R16,1                   ; НЕТ, RGS=101|110|111.
            RJMP ADDULP                 ; ОТБРАСЫВАЕМ RGS И ПРИБАВЛЯЕМ ULP. ОШИБКА ERR<ULP/2.

HALFWAY1:   LDI R16,1                   ; ИЗВЛЕКАЕМ ЗНАЧЕНИЕ РАЗРЯДА ULP.
            AND R16,R8                  ;
ADDULP:     ADD R8,R16                  ; ПРИБАВЛЯЕМ ULP.
            CLR R16                     ; ЕСЛИ ЗНАЧЕНИЕ НЕЧЕТНОЕ, ТО ULP=1, И РЕЗУЛЬТАТ СТАНЕТ ЧЕТНЫМ.
            ADC R9,R16                  ; ЕСЛИ ЗНАЧЕНИЕ УЖЕ ЧЕТНОЕ, ТО ULP=0, И ПРИБАВЛЕНИЕ НУЛЯ НЕ ИЗМЕНИТ РЕЗУЛЬТАТ.
            ADC R10,R16                 ; ЕСТЬ ПЕРЕПОЛНЕНИЕ?
            BRCC CHECKEXP2              ; НЕТ, ПЕРЕХОДИМ К ПРОВЕРКЕ ЭКСПОНЕНТЫ.
            ROR MANTA2                  ; ДА, НОРМАЛИЗУЕМ МАНТИССУ A. ПОСКОЛЬКУ ПЕРЕПОЛНЕНИЕ ПРИ ОКРУГЛЕНИИ, ДВА МЛАДШИХ БАЙТА МАНТИССЫ УЖЕ НУЛЕВЫЕ.
            INC EXPA0                   ; КОРРЕКТИРУЕМ ЭКСПОНЕНТУ. 

            ;
            ; ПРОВЕРКА ЭКСПОНЕНТЫ НА ПЕРЕПОЛНЕНИЕ/АНТИПЕРЕПОЛНЕНИЕ.
            ;
            ; ЭКСПОНЕНТА В КОДЕ СО СМЕЩЕНИЕМ ПРИНИМАЕТ ЗНАЧЕНИЯ В ОТРЕЗКЕ [-22,255].
            ; ЕСЛИ ЕСТЬ ПЕРЕПОЛНЕНИЕ, ТО ЭКСПОНЕНТА РАВНА 255 И ВЫЧИТАНИЕ ЕЁ ИЗ 255 ДАСТ НОЛЬ.
            ; ЕСЛИ НЕТ ПЕРЕПОЛНЕНИЯ, ТО ВЫЧИТАНИЕ ЭКСПОНЕНТЫ ИЗ 255 ДАСТ ПОЛОЖИТЕЛЬНОЕ ЗНАЧЕНИЕ.
            ; ЕСЛИ ЕСТЬ АНТИПЕРЕПОЛНЕНИЕ, ТО ЭКСПОНЕНТА ПРИНИМАЕТ ЗНАЧЕНИЯ В ОТРЕЗКЕ [-22,0] И ВЫЧИТАНИЕ ЕДИНИЦЫ ИЗ ЭКСПОНЕНТЫ ВСЕГДА ДАСТ ОТРИЦАТЕЛЬНОЕ ЗНАЧЕНИЕ.
            ; ЕСЛИ НЕТ АНТИПЕРЕПОЛНЕНИЯ, ТО, ПОСКОЛЬКУ ПЕРЕПОЛНЕНИЕ УЖЕ ИСКЛЮЧЕНО, ЭКСПОНЕНТА ЛЕЖИТ В [1,254] И ВЫЧИТАНИЕ ЕДИНИЦЫ ВСЕГДА ДАСТ ПОЛОЖИТЕЛЬНОЕ ЗНАЧЕНИЕ.
CHECKEXP2:  LDI R17,255                 ; ЗАПИСЫВАЕМ 255 В ДВА БАЙТА.
            LDI R18,0                   ;

            MOV R21,EXPA0               ; КОПИРУЕМ РАСШИРЕННУЮ ЭКСПОНЕНТУ A.
            MOV R22,EXPA1               ;

            COM R21                     ; ВЫЧИСЛЯЕМ ДОП. КОД ЭКСПОНЕНТЫ В ДВУХ БАЙТАХ.
            COM R22                     ;
            LDI R16,1                   ;
            ADD R21,R16                 ;
            CLR R16                     ;
            ADC R22,R16                 ;

            ADD R17,R21                 ; 255-EXP(A).
            IN STATUS0,SREG             ; СОХРАНЯЕМ ФЛАГИ ПОСЛЕ СЛОЖЕНИЯ МЛАДШИХ БАЙТ.
            ADC R18,R22                 ;
            IN STATUS1,SREG             ; СОХРАНЯЕМ ФЛАГИ ПОСЛЕ СЛОЖЕНИЯ СТАРШИХ БАЙТ.

            AND STATUS0,STATUS1         ; РЕЗУЛЬТАТ НУЛЕВОЙ, ЕСЛИ ФЛАГ Z БЫЛ УСТАНОВЛЕН ДЛЯ КАЖДОГО БАЙТА.
            SBRC STATUS0,SREG_Z         ; 255-EXP(A)=0?
            IJMP                        ; ДА, ПЕРЕПОЛНЕНИЕ, ПРЫЖОК НА ОБРАБОТЧИК ОШИБОК, УКАЗАННЫЙ В РЕГИСТРЕ Z.
            LDI R16,255                 ; НЕТ, ПРОВЕРЯЕМ НА АНТИПЕРЕПОЛНЕНИЕ.
            LDI R17,255                 ;
            ADD R16,EXPA0               ; EXP(A)-1.
            ADC R17,EXPA1               ; РЕЗУЛЬТАТ ОТРИЦАТЕЛЬНЫЙ?
            BRMI SETZERO1               ; ДА, АНТИПЕРЕПОЛНЕНИЕ, ЭКСПОНЕНТА ЛЕЖИТ В [0,-22] И НЕ ПРЕДСТАВИМА. ВОЗВРАЩАЕМ НОЛЬ.
                                        ; НЕТ, ЭКСПОНЕНТА ЛЕЖИТ В [1,254] И ПРЕДСТАВИМА В ОДИНАРНОМ FLOAT.

            ;
            ; УПАКОВКА СУММЫ.
            ROL MANTA0                  ; ВЫДВИГАЕМ ЦЕЛОЧИСЛЕННУЮ ЕДИНИЦУ МАНТИССЫ СУММЫ В БИТ ПЕРЕНОСА.
            ROL MANTA1                  ;
            ROL MANTA2                  ;
            ROL RSIGN                   ; ВЫДВИГАЕМ ЗНАК В БИТ ПЕРЕНОСА.
            ROR EXPA0                   ; ВДВИГАЕМ ЗНАК В MSB ЭКСПОНЕНТЫ И ВЫДВИГАЕМ LSB ЭКСПОНЕНТЫ В БИТ ПЕРЕНОСА.
            ROR MANTA2                  ; ВОССТАНАВЛИВАЕМ ИСХОДНЫЕ БИТЫ МАНТИССЫ,
            ROR MANTA1                  ; ВДВИГАЯ В MSB СТАРШЕГО БАЙТА МАНТИССЫ LSB ЭКСПОНЕНТЫ ВМЕСТО ЦЕЛОЧИСЛЕННОЙ ЕДИНИЦЫ.
            ROR MANTA0                  ;

            RJMP EXIT1
            
            ; ВЫХОД.
EXIT1:      RET

            ;
            ; УСТАНОВКА РЕЗУЛЬТАТА В НОЛЬ.
            ;
            ; ВЫПОЛНЯЕТСЯ В СЛЕДУЮЩИХ СЛУЧАЯХ:
            ; - АНТИПЕРЕПОЛНЕНИЕ РЕЗУЛЬТАТА ДЛЯ ЛЮБОЙ ОПЕРАЦИИ.
            ; - ДЕЛИМОЕ РАВНО НУЛЮ.
            ; - ХОТЯ БЫ ОДИН СОМНОЖИТЕЛЬ РАВЕН НУЛЮ.
            ; - ОБА СЛАГАЕМЫХ РАВНЫ НУЛЮ.
SETZERO1:   CLR MANTA0
            CLR MANTA1
            CLR MANTA2
            CLR EXPA0
            RJMP EXIT1

;
; ПРЕОБРАЗУЕТ ЧИСЛО В ФОРМАТЕ ПЛАВАЮЩЕЙ ТОЧКИ В ЦЕЛОЕ.
;
; РАБОТАЕТ ТОЛЬКО С ПОЛОЖИТЕЛЬНЫМИ НОРМАЛИЗОВАННЫМИ ДЕСЯТИЧНЫМИ ЧИСЛАМИ В ОТРЕЗКЕ [1,10).
; ТАКИМ ОБРАЗОМ, ВОЗВРАЩАЕТ ЦЕЛОЧИСЛЕННОЕ ЗНАЧЕНИЕ В ОТРЕЗКЕ [1,9] В ПРЕДЕЛАХ БАЙТА.
; 
; АРГУМЕНТЫ:
;   - NUM - ЧИСЛО. ОЖИДАЕТСЯ В РЕГИСТРАХ: R11, R10, R9, R8.
;
; РЕЗУЛЬТАТ: ЦЕЛАЯ ЧАСТЬ NUM. ПОМЕЩАЕТСЯ В R8.
            .DEF A0=R8                  ;
            .DEF A1=R9                  ;
            .DEF A2=R10                 ;
            .DEF A3=R11                 ;

            .DEF STATUS=R21             ; РЕГИСТР СТАТУСА.

FTOI:       ROL A2                      ; РАСПАКОВЫВАЕМ NUM.
            ROL A3                      ; A3=EXP(NUM). ПОСКОЛЬКУ NUM ЛЕЖИТ В [1,10), ТО ВСЕ БИТЫ ЦЕЛОЙ ЧАСТИ В НОРМАЛИЗОВАННОЙ МАНТИССЕ
            SEC                         ; ПОЛНОСТЬЮ ЛЕЖАТ В СТАРШЕМ БАЙТЕ МАНТИССЫ И НЕТ НЕОБХОДИМОСТИ СДВИГАТЬ МЛАДШИЕ.
            ROR A2                      ;
           
            CLR A0                      ; A0 НЕ СОДЕРЖИТ БИТОВ ЦЕЛОЙ ЧАСТИ И НАМ НЕ ИНТЕРЕСЕН. ОН БУДЕТ СОДЕРЖАТЬ ЦЕЛУЮ ЧАСТЬ ДЕСЯТИЧНОГО ЗНАЧЕНИЯ NUM.
            LDI R16,-127                ; A3=EXP(NUM)-127. ЭКСПОНЕНТА ЛЕЖИТ В [127,127+3], ЗНАЧИТ РАЗНОСТЬ ВСЕГДА > 0, ДОСТАТОЧНО ДОП. КОДА В ПРЕДЕЛАХ БАЙТА.
            ADD A3,R16                  ; ЭКСПОНЕНТА НУЛЕВАЯ? (ЕСЛИ НУЛЕВАЯ, ТО ЦЕЛАЯ ЧАСТЬ МАНТИССЫ УЖЕ ПРЕДСТАВЛЯЕТ ИСТИННУЮ ЦЕЛУЮ ЧАСТЬ ДЕСЯТИЧНОГО ЗНАЧЕНИЯ, КОТОРАЯ РАВНА ЕДИНИЦЕ.)
            BREQ SHFTMSB                ; ДА, ДЕЛАЕМ ФИНАЛЬНЫЙ СДВИГ.
            MOV R16,A3                  ; НЕТ, УСТАНАВЛИВАЕМ СЧЕТЧИК ЦИКЛА И РАСКРЫВАЕМ ЭКСПОНЕНТУ, ДЕНОРМАЛИЗУЯ МАНТИССУ ВЛЕВО.
DENORM:     ROL A2                      ; A<<1
            ROL A0                      ;
            DEC R16                     ; МАНТИССА ДЕНОРМАЛИЗОВАНА ВЛЕВО НА ВЕЛИЧИНУ ЭКСПОНЕНТЫ?
            BREQ SHFTMSB                ; ДА, ДЕЛАЕМ ФИНАЛЬНЫЙ СДВИГ.
            RJMP DENORM                 ; НЕТ, ПРОДОЛЖАЕМ СДВИГ.

SHFTMSB:    ROL A2                      ; A0=INT(NUM). (MSB МАНТИССЫ СОДЕРЖИТ LSB ИСТИННОЙ ЦЕЛОЙ ЧАСТИ - ВЫДВИГАЕМ ЕГО В A0.)
            ROL A0                      ;

            RET

;
; ПРЕОБРАЗУЕТ ОДНОБАЙТОВОЕ ЦЕЛОЕ ЧИСЛО В ЧИСЛО В ФОРМАТЕ ПЛАВАЮЩЕЙ ТОЧКИ.
;
; АРГУМЕНТЫ:
;   - NUM - ЦЕЛОЕ ЧИСЛО. ОЖИДАЕТСЯ В РЕГИСТРЕ: R8.
;
; РЕЗУЛЬТАТ: ЧИСЛО В ФОРМАТЕ ПЛАВАЮЩЕЙ ТОЧКИ, ПОМЕЩАЕТСЯ В R11, R10, R9, R8.
            .DEF A0=R8                  ;
            .DEF A1=R9                  ;
            .DEF A2=R10                 ;
            .DEF A3=R11                 ;

            .DEF STATUS=R21             ; РЕГИСТР СТАТУСА.

SETZERO3:   CLR A0                      ; A=0.0F.
            CLR A1                      ;
            CLR A2                      ;
            CLR A3                      ;
            RET                         ;

ITOF:       AND A0,A0                   ; NUM=0?
            BREQ SETZERO3               ; ДА, ВОЗВРАЩАЕМ 0.0F.

            CLR A1                      ; МЛАДШИЕ БАЙТЫ МАНТИССЫ
            CLR A2                      ;
            LDI R16,-1                  ; БАЙТ ЭКСПОНЕНТЫ. ИНИЦИАЛИЗИРУЕМ В -1 ДЛЯ ХОЛОСТОГО ИНКРЕМЕНТА ПРИ ПЕРВОМ СДВИГЕ.
            MOV A3,R16                  ;

            CLC                         ; A2 НУЛЕВОЙ, ПОЭТОМУ ПОСЛЕДНИЙ СДВИГ A2 ВСЕГДА ЗАНУЛЯЕТ БИТ ПЕРЕНОСА - ОЧИЩАТЬ НА КАЖДОЙ ИТЕРАЦИИ НЕ НУЖНО.
NORM0:      INC A3                      ; СОВМЕЩАЕМ LSB ЦЕЛОГО ЧИСЛА С MSB МАНТИССЫ,
            ROR A0                      ; ПОЛУЧАЯ, ПО СУТИ, ДЕНОРМАЛИЗОВАННУЮ ВЛЕВО МАНТИССУ.
            IN STATUS,SREG              ; ЗАПОМИНАЕМ ФЛАГ Z ДЛЯ A0.
            ROR A2                      ; 
            SBRS STATUS,SREG_Z          ; МАНТИССА НОРМАЛИЗОВАНА? (ЕСЛИ ИЗНАЧАЛЬНО A0=1, ТО ОН ЗАНУЛИТСЯ, А МАНТИССА СРАЗУ ОКАЖЕТСЯ НОРМАЛИЗОВАННОЙ.)
            RJMP NORM0                  ; НЕТ, ПРОДОЛЖАЕМ НОРМАЛИЗАЦИЮ.
                                        ; ДА, ПАКУЕМ FLOAT.
            LDI R16,127                 ; СОХРАНЯЕМ ЭКСПОНЕНТУ В КОДЕ СО СМЕЩЕНИЕМ.
            ADD A3,R16                  ;

                                        ; УБИРАЕМ У МАНТИССЫ ЦЕЛОЧИСЛЕННУЮ ЕДИНИЦУ.
            ROL A2                      ; ВХОДНОЕ ЧИСЛО РАЗМЕРОМ В БАЙТ, ПОЭТОМУ ВСЕ НЕНУЛЕВЫЕ БИТЫ УЖЕ ВМЕЩАЮТСЯ В A2, A0 И A1 РАВНЫ НУЛЮ.

            CLC                         ; РЕЗУЛЬТАТ БУДЕТ ПОЛОЖИТЕЛЬНЫМ - РАЗРЯД ЗНАКА НУЛЕВОЙ.
            ROR A3                      ; ПРИДВИГАЕМ ЭКСПОНЕНТУ К МАНТИССЕ БЕЗ ЕДИНИЦЫ.

            ROR A2                      ; РАЗМЕЩАЕМ LSB ЭКСПОНЕНТЫ В MSB МАНТИССЫ.

            RET

;
; ФОРМИРУЕТ ASCII-СТРОКУ С ДЕСЯТИЧНЫМ ПРЕДСТАВЛЕНИЕМ ПЕРЕМЕННОЙ ТИПА FLOAT.
;
; В ОСНОВЕ ЛЕЖИТ АЛГОРИТМ, РЕАЛИЗОВАННЫЙ В Z88DK, НО С ДОП. УПРОЩЕНИЯМИ.
; [https://github.com/z88dk/z88dk/blob/aa60b9c9e4bab3318b9b10e919919058a4d3aaee/libsrc/math/cimpl/ftoa.c]
;
; ОСНОВНАЯ ИДЕЯ АЛГОРИТМА - МЫ ИГНОРИРУЕМ ТОТ ФАКТ, ЧТО ДЕСЯТИЧНОЕ ПРЕДСТАВЛЕНИЕ
; ИСХОДНОЙ ДВОИЧНОЙ ДРОБИ ИСКАЖАЕТСЯ ПРИ ЕЁ МАСШТАБИРОВАНИИ.
; СЛЕДСТВИЕ ЭТОГО ДОПУЩЕНИЯ - НЕ ВСЕ ДЕСЯТИЧНЫЕ ЦИФРЫ В СТРОКЕ ОКАЗЫВАЮТСЯ ИСТИННЫМИ.
; ПРИ ОКРУГЛЕНИИ ДЕСЯТИЧНОГО СТРОКОВОГО ПРЕДСТАВЛЕНИЯ РАЗРЯДЫ ПРОСТО ОТБРАСЫВАЮТСЯ.
;
; АРГУМЕНТЫ:
;   - NUM - ЧИСЛО. ОЖИДАЕТСЯ В РЕГИСТРАХ: R11, R10, R9, R8.
;   - PRECISION - КОЛИЧЕСТВО ЦИФР ПОСЛЕ ТОЧКИ. ОЖИДАЕТСЯ В РЕГИСТРЕ R12.
;   - STR - УКАЗАТЕЛЬ НА ОБЛАСТЬ SRAM, КУДА БУДЕТ ЗАПИСАНА ASCII-СТРОКА. ОЖИДАЕТСЯ В XH:XL.
            .EQU TEN0=0x00              ; 10.0F.
            .EQU TEN1=0x00              ;
            .EQU TEN2=0x20              ;
            .EQU TEN3=0x41              ;

            .DEF A0=R8                  ; ПЕРВЫЙ ОПЕРАНД ЛЮБОЙ АРИФМЕТИЧЕСКОЙ ОПЕРАЦИИ: FDIV32,FMUL32,FADD32,FSUB32.
            .DEF A1=R9                  ;
            .DEF A2=R10                 ;
            .DEF A3=R11                 ;

            .DEF B0=R12                 ; ВТОРОЙ ОПЕРАНД ЛЮБОЙ АРИФМЕТИЧЕСКОЙ ОПЕРАЦИИ: FDIV32,FMUL32,FADD32,FSUB32.
            .DEF B1=R13                 ;
            .DEF B2=R14                 ;
            .DEF B3=R15                 ;

            .DEF N=R20                  ; КОЛИЧЕСТВО ДЕСЯТИЧНЫХ ЗНАКОВ В ЦЕЛОЙ ЧАСТИ NUM, КОТОРЫЕ НУЖНО ИЗВЛЕЧЬ.

            .DEF STATUS=R21             ; АККУМУЛЯТОР РЕГИСТРА СТАТУСА.

            .DEF TMP0=R22               ; МОЖЕТ БЫТЬ ИСПОЛЬЗОВАН ДЛЯ ВРЕМЕННОГО ХРАНЕНИЯ FLOAT32.
            .DEF TMP1=R23               ;
            .DEF TMP2=R24               ;
            .DEF TMP3=R25               ;

            ;
            ; ФОРМИРОВАНИЕ СТРОКИ "0.0" В СЛУЧАЕ, КОГДА NUM=0.
SETZERO2:   LDI R16,0x30                ;
            LDI R17,0x2E                ;
            ST X+,R16                   ; *STR++='0'.
            ST X+,R17                   ; *STR++='.'.
            ST X+,R16                   ; *STR++='0'.
            RET                         ;

FTOA:       CLR R16                     ;
            OR R16,A0                   ;
            OR R16,A1                   ;
            OR R16,A2                   ;
            OR R16,A3                   ; NUM=0?
            BREQ SETZERO2               ; ДА, ФОРМИРУЕМ ФИКСИРОВАННУЮ СТРОКУ "0.0".

            LDI R16,0b10000000          ; ИЗВЛЕКАЕМ ЗНАК NUM.
            AND R16,A3                  ; NUM>0?
            BREQ CONTINUE               ; ДА, NUM УЖЕ ПОЛОЖИТЕЛЬНЫЙ, ПРОДОЛЖАЕМ.
            EOR A3,R16                  ; НЕТ, ВЫЧИСЛЯЕМ МОДУЛЬ NUM=|NUM| И
            LDI R16,0x2D                ; НАЧИНАЕМ СТРОКУ СО ЗНАКА '-'.
            ST X+,R16                   ; *STR++='-'.

CONTINUE:   PUSH R12                    ; БЭКАПИМ PRECISION, Т.К. ОН НАХОДИТСЯ В ОДНОМ ИЗ ВХОДНЫХ РЕГИСТРОВ АРИФМЕТИЧЕСКИХ ОПЕРАЦИЙ.

            ;
            ; ВЫЧИСЛЕНИЕ ПОРЯДКА ЦЕЛОЧИСЛЕННОГО РАЗРЯДА DORDER, С КОТОРОГО НУЖНО НАЧАТЬ ИЗВЛЕЧЕНИЕ.
            ; ВЫЧИСЛЕНИЕ КОЛИЧЕСТВА РАЗРЯДОВ N=K+1, ГДЕ K-НОМЕР ПОРЯДКА (ПОКАЗАТЕЛЬ СТЕПЕНИ 10).
            ;
            ; ДЛЯ NUM В ИНТЕРВАЛЕ (10,0) МЫ, КАК МИНИМУМ, ИЗВЛЕКАЕМ РАЗРЯД ЕДИНИЦ, ПОЭТОМУ DORDER=1, N=1.
            ; ДЛЯ NUM>=10 DORDER СОДЕРЖИТ ПОРЯДОК НАИБОЛЬШЕГО НЕНУЛЕВОГО РАЗРЯДА.
            PUSH A3                     ; БЭКАПИМ ИСХОДНОЕ ЗНАЧЕНИЕ NUM.
            PUSH A2                     ;
            PUSH A1                     ;
            PUSH A0                     ;

            LDI R16,TEN0                ; B=10.0F.
            LDI R17,TEN1                ;
            LDI R18,TEN2                ;
            LDI R19,TEN3                ;
            MOV B0,R16                  ;
            MOV B1,R17                  ;
            MOV B2,R18                  ;
            MOV B3,R19                  ;

            CALL FDIV32                 ; A=NUMOTEN=FDIV32(NUM,10.0F). ПОНИЖЕНИЕ ДЕСЯТИЧНОГО ПОРЯДКА NUM, ЧТОБЫ ИЗБЕЖАТЬ ПЕРЕПОЛНЕНИЯ ПРИ ВЫЧИСЛЕНИИ DORDER.

            MOV B0,A0                   ; B=A=NUMOTEN.
            MOV B1,A1                   ;
            MOV B2,A2                   ;
            MOV B3,A3                   ;
            COM B0                      ; B=-NUMOTEN.
            COM B1                      ;
            COM B2                      ;
            COM B3                      ;
            LDI R16,1                   ;
            ADD B0,R16                  ;
            CLR R16                     ;
            ADC B1,R16                  ;
            ADC B2,R16                  ;
            ADC B3,R16                  ;

            LDI R16,0x00                ; A=DORDER=1.0F.
            LDI R17,0x00                ;
            LDI R18,0x80                ;
            LDI R19,0x3F                ;
            MOV A0,R16                  ;
            MOV A1,R17                  ;
            MOV A2,R18                  ;
            MOV A3,R19                  ;

            LDI N,1                     ;

CALCDORDER: PUSH B3                     ; БЭКАПИМ -NUMOTEN.
            PUSH B2                     ;
            PUSH B1                     ;
            PUSH B0                     ;

            LDI STATUS,0b00000010       ; МАСКА Z-ФЛАГА.
            ADD B0,A0                   ; B=DORDER-NUMOTEN.
            IN R16,SREG                 ;
            AND STATUS,R16              ;
            ADC B1,A1                   ;
            IN R16,SREG                 ;
            AND STATUS,R16              ;
            ADC B2,A2                   ;
            IN R16,SREG                 ;
            AND STATUS,R16              ;
            ADC B3,A3                   ;
            IN R16,SREG                 ; ИЗВЛЕКАЕМ ФЛАГИ N И Z. ЕСЛИ ОБА НУЛЕВЫЕ, ЗНАЧИТ DORDER>NUMOTEN.
            LDI R17,0b00000100          ; ДОБАВЛЯЕМ В STATUS МАСКУ ДЛЯ ФЛАГА N.
            OR STATUS,R17               ;
            AND STATUS,R16              ; DORDER>NUMOTEN? (ЕСЛИ ДА, ТО МЫ ЛИБО ИМЕЕМ ПОРЯДОК СТАРШЕГО НЕНУЛЕВОГО РАЗРЯДА NUM, ЛИБО NUM<1, ТОГДА DORDER СОДЕРЖИТ ПОРЯДОК РАЗРЯДА ЕДИНИЦ, КОТОРЫЙ У NUM РАВЕН 0.)
            BREQ RESTORENUM             ; ДА, ВОССТАНАВЛИВАЕМ ИСХОДНЫЙ NUM.
                                        ; НЕТ, DORDER<=NUMOTEN, ПОВЫШАЕМ ПОРЯДОК РАЗРЯДА.
            LDI R16,TEN0                ; B=10.0F.
            LDI R17,TEN1                ;
            LDI R18,TEN2                ;
            LDI R19,TEN3                ;
            MOV B0,R16                  ;
            MOV B1,R17                  ;
            MOV B2,R18                  ;
            MOV B3,R19                  ;

            PUSH N                      ; БЭКАПИМ N.
            CALL FMUL32                 ; A=FMUL32(DORDER,10.0F).
            POP N                       ;

            INC N                       ;

            POP B0                      ; B=-NUMOTEN.
            POP B1                      ;
            POP B2                      ;
            POP B3                      ;

            RJMP CALCDORDER             ;

RESTORENUM: POP R16                     ; УДАЛЯЕМ -NUMOTEN ИЗ СТЕКА.
            POP R16                     ;
            POP R16                     ;
            POP R16                     ;

            MOV B0,A0                   ; B=A=DORDER.
            MOV B1,A1                   ;
            MOV B2,A2                   ;
            MOV B3,A3                   ;

            POP A0                      ; A=NUM.
            POP A1                      ;
            POP A2                      ;
            POP A3                      ;

            ;
            ; ИЗВЛЕЧЕНИЕ ЦИФР ЦЕЛОЙ ЧАСТИ.
            ;
            ; НА ВХОД СРАЗУ МОЖЕТ ПОСТУПИТЬ NUM<1, ТОГДА ORDER=1, N=1 ОПРЕДЕЛЯЮТ ИЗВЛЕЧЕНИЕ НУЛЯ В ЦЕЛОЙ ЧАСТИ.
            ; ПРИ ЭТОМ ПОНЯТНО, ЧТО NUM/DORDER ДАСТ ИСХОДНОЕ ЗНАЧЕНИЕ NUM<1.
            ; ЕЩЁ, ПРИ NUM<1 ДВОИЧНАЯ ЭКСПОНЕНТА МЕНЬШЕ 0 (127 В КОДЕ СО СМЕЩЕНИЕМ).
            ; ПОСЛЕДНЕЕ МОЖНО ИСПОЛЬЗОВАТЬ ДЛЯ ПРОВЕРКИ ТОГО, ЧТО NUM<1.
            ;
            ; В ПРОЦЕССЕ ИЗВЛЕЧЕНИЯ NUM МЕНЯЕТСЯ, ТЕРЯЯ СВОИ СТАРШИЕ РАЗРЯДЫ: NUM'=NUM-DIGIT*DORDER.
            ; ПРИ ЭТОМ, ПОРЯДОК NUM' МОЖЕТ СТАТЬ МЕНЬШЕ DORDER - ЭТО ВОЗМОЖНО, КОГДА В ЦЕЛОЙ ЧАСТИ ЕСТЬ НУЛЕВЫЕ РАЗРЯДЫ.
            ; ТОГДА NUM'/DORDER ДАСТ NUM'<1 И ТЕКУЩИЙ РАЗРЯД ПОРЯДКА DORDER БУДЕТ УСТАНОВЛЕН В '0'.
            ; ДЛЯ ПРОВЕРКИ, ЧТО NUM'<1 МОЖНО ИСПОЛЬЗОВАТЬ ТОТ ЖЕ КРИТЕРИЙ, ЧТО И В ПЕРВОМ СЛУЧАЕ.
            ;
            ; В ОСТАЛЬНЫХ СЛУЧАЯХ ПОРЯДОК NUM' И DORDER СОВПАДАЮТ
            ; И ПОРЯДОК DORDER ОПРЕДЕЛЯЕТ ПОРЯДОК СТАРШЕГО РАЗРЯДА NUM', КОТОРЫЙ ИЗВЛЕКАЕТСЯ НА СЛЕДУЮЩЕЙ ИТЕРАЦИИ.
GETINT:     PUSH A3                     ; БЭКАПИМ ПОСЛЕДНЕЕ ЗНАЧЕНИЕ NUM.
            PUSH A2                     ;
            PUSH A1                     ;
            PUSH A0                     ;

            PUSH B3                     ; БЭКАПИМ ПОСЛЕДНЕЕ ЗНАЧЕНИЕ DORDER.
            PUSH B2                     ;
            PUSH B1                     ;
            PUSH B0                     ;

            PUSH N                      ;
            CALL FDIV32                 ; A=NUM'=FDIV32(NUM,DORDER).
            POP N

            PUSH A3                     ; БЭКАПИМ NUM'.
            PUSH A2                     ; NUM' МОЖЕТ ОКАЗАТЬСЯ >=1,
            PUSH A1                     ; ТОГДА НАМ НУЖНО ЕГО ИСХОДНОЕ ЗНАЧЕНИЕ
            PUSH A0                     ; ДЛЯ ИЗВЛЕЧЕНИЯ ЦЕЛОЙ ЧАСТИ.

            ROL A2                      ; РАСПАКОВЫВАЕМ ДВОИЧНУЮ ЭКСПОНЕНТУ NUM'. ОНА - В КОДЕ СО СМЕЩЕНИЕМ.
            ROL A3                      ;
            LDI R16,-127                ; EXP(NUM')-127. ЗДЕСЬ ДВА РАЗНЫХ УСЛОВИЯ NUM'<1 И NUM'=0 ПРОВЕРЯЮТСЯ ОДНИМ МЕТОДОМ, ПОСКОЛЬКУ ЕСЛИ NUM'=0, ПОЛЕ ЭКСПОНЕНТЫ РАВНО НУЛЮ И ТАКЖЕ ДАСТ ОТРИЦАТЕЛЬНУЮ РАЗНОСТЬ С ЧИСЛОМ 127.
            ADD R16,A3                  ; 0<=NUM'<1? (-127 ПРЕДСТАВЛЕН В ПСЕВДО ДОП. КОДЕ - В ПРЕДЕЛАХ ТОЛЬКО МЛАДШЕГО БАЙТА. ПОЭТОМУ ПРОВЕРКА ЗНАКА - НЕ ПО ФЛАГУ N, А ПО БИТУ ПЕРЕНОСА.)
            BRCS ASCIIDIG               ; НЕТ, ЦЕЛАЯ ЧАСТЬ НЕНУЛЕВАЯ, ФОРМИРУЕМ ЕЁ ЦИФРУ.
            LDI R16,0x30                ; ДА, ЛИБО РАЗРЯД С ПОРЯДКОМ DORDER РАВЕН НУЛЮ ЛИБО ИЗНАЧАЛЬНО 0<=NUM<1 И РАЗРЯД ЕДИНИЦ ЧИСЛА NUM РАВЕН НУЛЮ, УСТАНАВЛИВАЕТ ЦИФРУ '0'.
            ST X+,R16                   ; *STR++='0'.

                                        ; КОГДА МЫ ИДЁМ ПО ВЕТКЕ ASCIIDIG,
                                        ; ТО ПЕРЕД COND ОЖИДАЕТСЯ ТАКОЕ СОСТОЯНИЕ:
                                        ;   - A=NUM (УЖЕ БЕЗ СТАРШЕГО РАЗРЯДА);
                                        ;   - B=DORDER;
                                        ;   - N=N (ИЗВЛЕЧЕН ИЗ СТЕКА);
                                        ;   - STACK=[PRECISION] (СОДЕРЖИТ ТОЛЬКО PRECISIN).
                                        ; ПОЭТОМУ ПРИВОДИМ К ИДЕНТИЧНОМУ СОСТОЯНИЮ.
            POP R16                     ; УДАЛЯЕМ NUM' ИЗ СТЕКА.
            POP R16                     ;
            POP R16                     ;
            POP R16                     ;

            POP B0                      ; B=DORDER.
            POP B1                      ;
            POP B2                      ;
            POP B3                      ;

            POP A0                      ; A=NUM.
            POP A1                      ;
            POP A2                      ;
            POP A3                      ;

            RJMP COND                   ;

ASCIIDIG:   POP A0                      ; A=NUM'.
            POP A1                      ; В ЭТОЙ ВЕТКЕ NUM' - ВСЕГДА НОРМАЛИЗОВАННАЯ ДЕСЯТИЧНАЯ ДРОБЬ В [1,10).
            POP A2                      ;
            POP A3                      ;

            PUSH N                      ;
            CALL FTOI                   ; A0=DIGIT=INT(NUM').
            POP N                       ;

            LDI R16,0x30                ; *STR++=ASCII(DIGIT).
            ADD R16,A0                  ;
            ST X+,R16                   ;

            PUSH N                      ;
            CALL ITOF                   ; A=FDIGIT=FLOAT(DIGIT).
            POP N                       ; ИЗВЛЕЧЕННУЮ ЦИФРУ ИМЕЕМ ТЕПЕРЬ НЕ КАК INT, А КАК ЧИСЛО В FLOAT32.

            POP B0                      ; B=DORDER.
            POP B1                      ;
            POP B2                      ;
            POP B3                      ;

            POP TMP0                    ; TMP=NUM.
            POP TMP1                    ;
            POP TMP2                    ;
            POP TMP3                    ;

            PUSH B3                     ; СНОВА БЭКАПИМ DORDER.
            PUSH B2                     ;
            PUSH B1                     ;
            PUSH B0                     ;

            PUSH TMP3                   ; ТЕПЕРЬ БЭКАПИМ NUM,
            PUSH TMP2                   ; Т.К. ДАЛЕЕ ОН ПОНАДОБИТСЯ В ПЕРВУЮ ОЧЕРЕДЬ.
            PUSH TMP1                   ;
            PUSH TMP0                   ;

            PUSH N                      ;
            CALL FMUL32                 ; A=FMUL32(FDIGIT,DORDER).
            POP N                       ; ИЗВЛЕЧЕННЫЙ ИЗ NUM РАЗРЯД ПОРЯДКА DORDER ИМЕЕМ ТЕПЕРЬ КАК САМОСТОЯТЕЛЬНОЕ ЧИСЛО ПОРЯДКА DORDER.

            MOV B0,A0                   ; B=A=FDIGIT*DORDER.
            MOV B1,A1                   ;
            MOV B2,A2                   ;
            MOV B3,A3                   ;

            POP A0                      ; A=NUM.
            POP A1                      ;
            POP A2                      ;
            POP A3                      ;

            PUSH N                      ;
            CALL FSUB32                 ; A=NUM=FSUB32(NUM,FDIGIT*DORDER).
            POP N                       ; ТЕПЕРЬ ИЗ NUM УДАЛЕН СТАРШИЙ РАЗРЯД ПОРЯДКА DORDER, ЦИФРУ КОТОРОГО МЫ ИЗВЛЕКЛИ.

            POP B0                      ; B=DORDER.
            POP B1                      ; ЕСЛИ ЭТО БЫЛ ПОСЛЕДНИЙ ЦЕЛЫЙ РАЗРЯД,
            POP B2                      ; ТО DORDER=1, ОН НАМ БОЛЬШЕ НЕ НУЖЕН,
            POP B3                      ; И МЫ ПРОСТО УБРАЛИ ЕГО ИЗ СТЕКА ПЕРЕД ИЗВЛЕЧЕНИЕМ ДРОБНЫХ РАЗРЯДОВ.

COND:       DEC N                       ; ВСЕ РАЗРЯДЫ ЦЕЛОЙ ЧАСТИ ИЗВЛЕЧЕНЫ?
            BREQ DECPOINT               ; ДА, ТЕПЕРЬ NUM<1, DORDER=10^0=1 - ДОБАВЛЯЕМ ДЕСЯТИЧНУЮ ТОЧКУ И ПЕРЕХОДИМ К ДРОБНЫМ.
                                        ; НЕТ, DORDER>=10 - ПЕРЕХОДИМ К СЛЕДУЮЩЕМУ МЛАДШЕМУ РАЗРЯДУ. (УЖЕ МОЖЕТ БЫТЬ, ЧТО NUM<1, НО МЫ ДОСТОВЕРНО НЕ ЗНАЕМ, ПОКА НЕ ПЕРЕБЕРЕМ ВСЕ РАЗРЯДЫ, ПОРЯДОК КОТОРЫХ МЕНЬШЕ DORDER.)
            PUSH A3                     ; БЭКАПИМ НОВОЕ ЗНАЧЕНИЕ NUM.
            PUSH A2                     ;
            PUSH A1                     ;
            PUSH A0                     ;

            MOV A0,B0                   ; A=B=DORDER.
            MOV A1,B1                   ;
            MOV A2,B2                   ;
            MOV A3,B3                   ;

            LDI R16,TEN0                ; B=10.0F.
            LDI R17,TEN1                ;
            LDI R18,TEN2                ;
            LDI R19,TEN3                ;
            MOV B0,R16                  ;
            MOV B1,R17                  ;
            MOV B2,R18                  ;
            MOV B3,R19                  ;

            PUSH N                      ;
            CALL FDIV32                 ; A=DORDER=FDIV32(DORDER,10.0F).
            POP N                       ; ПО СУТИ - СМЕЩАЕМ КУРСОР НА СЛЕДУЮЩИЙ МЛАДШИЙ ЦЕЛЫЙ РАЗРЯД NUM.

            MOV B0,A0                   ; B=A=DORDER/10.0F.
            MOV B1,A1                   ;
            MOV B2,A2                   ;
            MOV B3,A3                   ;

            POP A0                      ; A=NUM.
            POP A1                      ;
            POP A2                      ;
            POP A3                      ;
            
            RJMP GETINT                 ;

DECPOINT:   LDI R16,0x2E                ; *STR++='.'.
            ST X+,R16                   ;

            ;
            ; ИЗВЛЕЧЕНИЕ ДРОБНЫХ ДЕСЯТИЧНЫХ РАЗРЯДОВ.
            ;
            ; ВХОДНОЕ ЗНАЧЕНИЕ NUM<1.
            ; ДВОИЧНАЯ ЭКСПОНЕНТА ПОСЛЕ УМНОЖЕНИЯ НА 10 ЛЕЖИТ В [-123,3]
            ; ИЛИ [4,130] В КОДЕ СО СМЕЩЕНИЕМ.
GETFRAC:    LDI R16,TEN0                ; B=10.0F.
            LDI R17,TEN1                ;
            LDI R18,TEN2                ;
            LDI R19,TEN3                ;
            MOV B0,R16                  ;
            MOV B1,R17                  ;
            MOV B2,R18                  ;
            MOV B3,R19                  ;

            CALL FMUL32                 ; A=NUM'=FMUL32(NUM,10.0F). ПОСЛЕ GETINT - A=NUM, NUM<1.

            PUSH A3                     ; БЭКАПИМ NUM',
            PUSH A2                     ; ПОСКОЛЬКУ ДАЛЕЕ БУДЕМ РАСПАКОВЫВАТЬ ЕГО ЭКСПОНЕНТУ.
            PUSH A1                     ;
            PUSH A0                     ;

            ROL A2                      ; КАК И ПРЕЖДЕ, ЕСЛИ ЭКСПОНЕНТА ЛЕЖИТ В [127,130],
            ROL A3                      ; ТО РАЗНОСТЬ ПОЛОЖИТЕЛЬНАЯ И ВСЕГДА ДАСТ БИТ ПЕРЕНОСА
            LDI R16,-127                ; В СТАРШИЙ БАЙТ, ГДЕ ЗАНУЛЯТСЯ БИТЫ ИСТИННОГО ДОП. КОДА -127.
            ADD R16,A3                  ; 0<=NUM'<1? КАК И В GETINT ЛЕВОЕ И ПРАВОЕ УСЛОВИЯ ПРОВЕРЯЮТСЯ ОДНИМ СПОСОБОМ.
            BRCS ASCIIDIG1              ; НЕТ, В ЦЕЛОЙ ЧАСТИ ДЕСЯТИЧНЫЙ ДРОБНЫЙ РАЗРЯД, ОПРЕДЕЛЯЕМ ЕГО ЦИФРУ.
            LDI R16,0x30                ; ДА, ОЧЕРЕДНОЙ ДРОБНЫЙ РАЗРЯД НУЛЕВОЙ, УСТАНАВЛИВАЕМ ЦИФРУ НОЛЬ.
            ST X+,R16                   ; *STR++='0'.

            POP A0                      ; A=NUM'.
            POP A1                      ; ВОССТАНАВЛИВАЕМ СОСТОЯНИЕ, ОЖИДАЕМОЕ В COND1.
            POP A2                      ; В СТЕКЕ - PRECISION.
            POP A3                      ;

            RJMP COND1                  ;

ASCIIDIG1:  POP A0                      ; A=NUM', СЕЙЧАС NUM' - ДЕСЯТИЧНАЯ НОРМАЛИЗОВАННАЯ ДРОБЬ.
            POP A1                      ; ВОССТАНАВЛИВАЕМ ИСХОДНОЕ ЗНАЧЕНИЕ,
            POP A2                      ; НЕ ПОВРЕЖДЕННОЕ РАСПАКОВКОЙ ЭКСПОНЕНТЫ.
            POP A3                      ;

            PUSH A3                     ; СНОВА БЭКАПИМ NUM',
            PUSH A2                     ; ПОСКОЛЬКУ ДАЛЕЕ НАМ НУЖНО БУДЕТ
            PUSH A1                     ; УДАЛИТЬ ИЗ НЕГО ЦЕЛУЮ ЧАСТЬ.
            PUSH A0                     ;

            CALL FTOI                   ; A0=DIGIT=INT(NUM').

            LDI R16,0x30                ; *STR++=ASCII(DIGIT).
            ADD R16,A0                  ;
            ST X+,R16                   ;

            CALL ITOF                   ; A=FDIGIT=FLOAT(DIGIT).

            MOV B0,A0                   ; B=A=FDIGIT.
            MOV B1,A1                   ;
            MOV B2,A2                   ;
            MOV B3,A3                   ;

            POP A0                      ; A=NUM'.
            POP A1                      ;
            POP A2                      ;
            POP A3                      ;

                                        ; УБИРАЕМ ИЗВЛЕЧЕННЫЙ ДРОБНЫЙ РАЗРЯД ИЗ ЦЕЛОЙ ЧАСТИ NUM'.
            CALL FSUB32                 ; A=NUM=FSUB32(NUM',FDIGIT). ТЕПЕРЬ СНОВА NUM<1.

COND1:      POP N                       ; N=PRECISION.
            DEC N                       ; PRECISION--. ИЗВЛЕКЛИ ЗАДАННОЕ ЧИСЛО ДРОБНЫХ РАЗРЯДОВ?
            BREQ EXITFTOA               ; ДА, STR СОДЕРЖИТ ДЕСЯТИЧНЫЕ ЦИФРЫ ЧИСЛА NUM, СТЕК - АДРЕС ВОЗВРАТА.
            PUSH N                      ; НЕТ, СНОВА БЭКАПИМ PRECISION И
            RJMP GETFRAC                ; ИЗВЛЕКАЕМ СЛЕДУЮЩИЙ ДЕСЯТИЧНЫЙ ДРОБНЫЙ РАЗРЯД.

EXITFTOA:   LDI R16,0                   ;
            ST X,R16                    ; ДОБАВЛЯЕМ КОНЕЦ СТРОКИ '\0'.
            RET

;
; ПРЕОБРАЗУЕТ ASCII-СТРОКУ С ДЕСЯТИЧНОЙ ДРОБЬЮ В БИНАРНЫЙ FLOAT.
;
; В ОСНОВЕ ЛЕЖИТ ОЧЕНЬ ПРОСТОЙ И НЕТОЧНЫЙ АЛГОРИТМ ИЗ [KERNIGHAN & RITCHIE, THE C PROGRAMMING LANGUAGE].
;
; ОСНОВНАЯ ИДЕЯ ТА ЖЕ, ЧТО И ДЛЯ FTOA - МЫ ПРОСТО ИГНОРИРУЕМ ТОТ ФАКТ, ЧТО ДЕСЯТИЧНОЕ ПРЕДСТАВЛЕНИЕ
; ИСХОДНОЙ ДВОИЧНОЙ ДРОБИ ИСКАЖАЕТСЯ ПРИ ЕЁ МАСШТАБИРОВАНИИ И УМНОЖАЕМ ДВОИЧНУЮ ДРОБЬ НА 10 ТАК,
; СЛОВНО МЫ НЕПОСРЕДСТВЕННО УМНОЖАЕМ ЕЁ ДЕСЯТИЧНОЕ ПРЕДСТАВЛЕНИЕ, ИГНОРИРУЯ ИСКАЖЕНИЯ НЕКОТОРЫХ РАЗРЯДОВ
; НОВОГО ДЕСЯТИЧНОГО ПРЕДСТАВЛЕНИЯ ОТМАСШТАБИРОВАННОЙ ДВОИЧНОЙ ДРОБИ.
;
; АРГУМЕНТЫ:
;   - STR - УКАЗАТЕЛЬ НА ASCII-СТРОКУ С НУЛЁМ В КОНЦЕ. ОЖИДАЕТСЯ В XH:XL.
; 
; РЕЗУЛЬТАТ:
;   - NUM - ЧИСЛО В ФОРМАТЕ ПЛАВАЮЩЕЙ ТОЧКИ, ПОМЕЩАЕТСЯ В R11, R10, R9, R8.
            .EQU ONE0=0x00              ; 1.0F.
            .EQU ONE1=0x00              ;
            .EQU ONE2=0x80              ;
            .EQU ONE3=0x3F              ;

            .DEF A0=R8                  ; ПЕРВЫЙ ОПЕРАНД ЛЮБОЙ АРИФМЕТИЧЕСКОЙ ОПЕРАЦИИ: FDIV32,FMUL32,FADD32,FSUB32.
            .DEF A1=R9                  ;
            .DEF A2=R10                 ;
            .DEF A3=R11                 ;

            .DEF B0=R12                 ; ВТОРОЙ ОПЕРАНД ЛЮБОЙ АРИФМЕТИЧЕСКОЙ ОПЕРАЦИИ: FDIV32,FMUL32,FADD32,FSUB32.
            .DEF B1=R13                 ;
            .DEF B2=R14                 ;
            .DEF B3=R15                 ;

            .DEF TMP0=R22               ; МОЖЕТ БЫТЬ ИСПОЛЬЗОВАН ДЛЯ ВРЕМЕННОГО ХРАНЕНИЯ FLOAT32.
            .DEF TMP1=R23               ;
            .DEF TMP2=R24               ;
            .DEF TMP3=R25               ;

ATOF:       CLR A0                      ; A=NUM=0.0F.
            CLR A1                      ;
            CLR A2                      ;
            CLR A3                      ;

            ;
            ; ОПРЕДЕЛЕНИЕ ЗНАКА ЧИСЛА.
            LD R16,X                    ;
            LDI R17,'-'                 ;
            EOR R16,R17                 ; ПЕРВЫЙ СИМВОЛ ЧИСЛОВОЙ СТРОКИ - МИНУС?
            BREQ MINUS                  ; ДА, ФОРМИРУЕМ ОТРИЦАТЕЛЬНЫЙ ЗНАК РЕЗУЛЬТАТА И ПРОПУСКАЕМ ПЕРВЫЙ СИМВОЛ.
            CLR R16                     ; НЕТ, ЗНАК NUM БУДЕТ ПОЛОЖИТЕЛЬНЫМ - MSB СТАРШЕГО БАЙТА NUM БУДЕТ НУЛЕВЫМ.
            PUSH R16                    ;
            RJMP GETINT1                ;

MINUS:      LD R16,X+                   ; ПРОПУСКАЕМ ЗНАК МИНУСА И СМЕЩАЕМСЯ К СЛЕДУЮЩЕМУ СИМВОЛУ.
            LDI R16,0b10000000          ; MSB СТАРШЕГО БАЙТА NUM БУДЕТ СОДЕРЖАТЬ ЕДИНИЦУ.
            PUSH R16                    ; СОХРАНЯЕМ SIGN В СТЕКЕ ДО КОНЦА ВЫЧИСЛЕНИЙ.
            
            ;
            ; ФОРМИРОВАНИЕ ЦЕЛОЙ ЧАСТИ.
GETINT1:    LD R16,X+                   ; R16=DIGIT=*STR++.
            AND R16,R16                 ; ПРОЧИТАЛИ КОНЕЦ СТРОКИ?
            BREQ EXITATOF               ; ДА, ВЫХОДИМ.
            LDI R17,0x2E                ; НЕТ.
            EOR R17,R16                 ; ПРОЧИТАЛИ ТОЧКУ?
            BREQ GETFRAC1               ; ДА, ПЕРЕХОДИМ К ДРОБНОЙ ЧАСТИ.
                                        ; НЕТ, ПРОДОЛЖАЕМ ФОРМИРОВАТЬ ЦЕЛУЮ ЧАСТЬ.
            LDI R17,TEN0                ; B=10.0F
            LDI R18,TEN1                ;
            LDI R19,TEN2                ;
            LDI R20,TEN3                ;
            MOV B0,R17                  ;
            MOV B1,R18                  ;
            MOV B2,R19                  ;
            MOV B3,R20                  ;

            PUSH R16                    ; ЕСЛИ ЭТО НЕ ПЕРВАЯ ЦИФРА, ЗНАЧИТ ПОРЯДОК NUM ВЫШЕ, ЧЕМ МЫ ПРЕДПОЛОЖИЛИ.
            CALL FMUL32                 ; A=NUM=FMUL32(NUM,10.0F).
            POP R16                     ;

            PUSH A3                     ; БЭКАПИМ NUM.
            PUSH A2                     ;
            PUSH A1                     ;
            PUSH A0                     ;

            LDI R17,0x0F                ; ИЗВЛЕКАЕМ ИЗ ASCII КОДА ЦИФРЫ ОБОЗНАЧАЕМОЕ ЕЮ ЧИСЛО.
            AND R16,R17                 ; R16=DIGIT-0x30.
            MOV A0,R16                  ; R8=DIGIT.
            CALL ITOF                   ; A=FDIGIT=FLOAT(DIGIT).
            MOV B0,A0                   ; B=FDIGIT.
            MOV B1,A1                   ;
            MOV B2,A2                   ;
            MOV B3,A3                   ;

            POP A0                      ; A=NUM.
            POP A1                      ;
            POP A2                      ;
            POP A3                      ;

                                        ; ПРЕДПОЛАГАЕМ, ЧТО ПРОЧИТАННАЯ ЦИФРА ПОСЛЕДНЯЯ В ЦЕЛОЙ ЧАСТИ И Т.О. ПРЕДСТАВЛЯЕТ РАЗРЯД ЕДИНИЦ.
            CALL FADD32                 ; A=NUM=NUM+FDIGIT.

            RJMP GETINT1

            ;
            ; ВЫХОДИ ИЗ ATOF.
EXITATOF:   POP R16                     ; R16=SIGN.
            EOR A3,R16                  ; УСТАНАВЛИВАЕМ ЗНАК NUM.
            RET

            ;
            ; ФОРМИРОВАНИЕ ДРОБНОЙ ЧАСТИ.
DWNSCALE:   POP B0                      ; B=OVERSCALE.
            POP B1                      ;
            POP B2                      ;
            POP B3                      ;
                                        
                                        ; ВОССТАНАВЛИВАЕМ ИСТИННЫЙ ПОРЯДКА ЧИСЛА NUM ПОСЛЕ ИЗВЛЕЧЕНИЯ ДРОБНОЙ ЧАСТИ.
            CALL FDIV32                 ; A=NUM=FDIV32(NUM,OVERSCALE).

            RJMP EXITATOF               ;

GETFRAC1:   LDI R16,ONE3                ; OVERSCALE=1.0F.
            LDI R17,ONE2                ;
            LDI R18,ONE1                ;
            LDI R19,ONE0                ;
            PUSH R16                    ;
            PUSH R17                    ;
            PUSH R18                    ;
            PUSH R19                    ;

GETFRAC2:   LD R16,X+                   ; R16=DIGIT=*STR++.
            AND R16,R16                 ; ПРОЧИТАЛИ КОНЕЦ СТРОКИ?
            BREQ DWNSCALE               ; ДА, ВОССТАНАВЛИВАЕМ ПОРЯДОК NUM.
                                        ; НЕТ, ПРОДОЛЖАЕМ ИЗВЛЕКАТЬ ДРОБНЫЕ РАЗРЯДЫ.
            LDI R17,TEN0                ; B=10.0F.
            LDI R18,TEN1                ;
            LDI R19,TEN2                ;
            LDI R20,TEN3                ;
            MOV B0,R17                  ;
            MOV B1,R18                  ;
            MOV B2,R19                  ;
            MOV B3,R20                  ;

            PUSH R16                    ; ЗАВЫШАЕМ ПОРЯДОК NUM, ЧТОБЫ ТЕКУЩАЯ ЦИФРА ПРЕДСТАВЛЯЛА РАЗРЯД ЕДИНИЦ.
            CALL FMUL32                 ; A=NUM=FMUL32(NUM,10.0F).
            POP R16                     ;

            POP TMP0                    ; TMP=OVERSCALE.
            POP TMP1                    ;
            POP TMP2                    ;
            POP TMP3                    ;

            PUSH A3                     ; БЭКАПИМ NUM.
            PUSH A2                     ;
            PUSH A1                     ;
            PUSH A0                     ;

            PUSH R16                    ; БЭКАПИМ DIGIT.

            MOV A0,TMP0                 ; A=TMP=OVERSCALE.
            MOV A1,TMP1                 ;
            MOV A2,TMP2                 ;
            MOV A3,TMP3                 ;

            LDI R16,TEN0                ; B=10.0F.
            LDI R17,TEN1                ;
            LDI R18,TEN2                ;
            LDI R19,TEN3                ;
            MOV B0,R16                  ;
            MOV B1,R17                  ;
            MOV B2,R18                  ;
            MOV B3,R19                  ; 

                                        ; ОТСЛЕЖИВАЕМ СТЕПЕНЬ ЗАВЫШЕНИЯ ИСТИННОГО ПОРЯДКА NUM.
            CALL FMUL32                 ; A=OVERSCALE=FMUL32(OVERSCALE,10.0F).
            MOV TMP0,A0                 ; TMP=A=OVERSCALE.
            MOV TMP1,A1                 ;
            MOV TMP2,A2                 ;
            MOV TMP3,A3                 ;

            POP R16                     ; R16=DIGIT.

            POP A0                      ; A=NUM.
            POP A1                      ;
            POP A2                      ;
            POP A3                      ;

            PUSH TMP3                   ; БЭКАПИМ OVERSCALE.
            PUSH TMP2                   ;
            PUSH TMP1                   ;
            PUSH TMP0                   ;

            PUSH A3                     ; БЭКАПИМ NUM.
            PUSH A2                     ;
            PUSH A1                     ;
            PUSH A0                     ;

            LDI R17,0x0F                ; ИЗВЛЕКАЕМ ИЗ ASCII КОДА ЦИФРЫ ОБОЗНАЧАЕМОЕ ЕЮ ЧИСЛО.
            AND R16,R17                 ; R16=DIGIT-0x30.
            MOV A0,R16                  ; R8=DIGIT.
            CALL ITOF                   ; A=FDIGIT=FLOAT(DIGIT).
            MOV B0,A0                   ; B=FDIGIT.
            MOV B1,A1                   ;
            MOV B2,A2                   ;
            MOV B3,A3                   ;

            POP A0                      ; A=NUM.
            POP A1                      ;
            POP A2                      ;
            POP A3                      ;

            CALL FADD32                 ; A=NUM=NUM+FDIGIT.

            RJMP GETFRAC2               ;