;
; Float32AVR - библиотека подпрограмм для работы с числами в формате бинарной плавающей точки одинарной точности.
; Кроме арифметики содержит вспомогательные подпрограммы для конвертации из ASCII и в ASCII.
;
; Copyright (с) 2024 Igor Voytenko <igor.240340@gmail.com>
;
; Частичная совместимость с IEEE 754:
; - Не реализованы спец. значения: inf, nan.
; - Не реализованы денормализованные числа.
; - Реализован только один режим округления: к ближайшему/к четному.
; - Реализован только положительный ноль.
;
; Тем не менее, граничные значения экспоненты -127 и 128 (0 и 255 в коде со смещением)
; остаются зарезервированными для спец. значений и денормализованных чисел
; чтобы можно было довести до полной совместимости в будущем
; а также для удобства тестирования и сравнения с эталонной IEEE 754 реализацией прямо сейчас.
;
; Обработка исключительных ситуаций.
; В случае возникновения исключительной ситуации (деление на ноль, переполнение)
; происходит прыжок на адрес, который должен быть предварительно загружен в Z-регистр перед вызовом подпрограммы.
            ;
            ; Байты исходной мантиссы делимого,
            ; расширенные GUARD-байтом для безопасного сдвига влево.
            .DEF MANTA0=R8              
            .DEF MANTA1=R9              
            .DEF MANTA2=R10             
            .DEF MANTAG=R2              

            ;
            ; Байты исходной мантиссы делителя,
            ; Расширенные GUARD-байтом для формирования доп. кода отрицательной мантиссы.
            .DEF MANTB0=R12             
            .DEF MANTB1=R13             
            .DEF MANTB2=R14             
            .DEF MANTBG=R3              

            ;
            ; Байты доп. кода отрицательной мантиссы делителя.
            .DEF MANTB0NEG=R4
            .DEF MANTB1NEG=R5
            .DEF MANTB2NEG=R6
            .DEF MANTBGNEG=R7

            ;
            ; Расширенные экспоненты.
            .DEF EXPA0=R11                  ; Первый операнд.
            .DEF EXPA1=R20                  ;
            .DEF EXPR0=R11                  ; Результат.
            .DEF EXPR1=R20                  ;
            .DEF EXPB0=R15                  ; Второй операнд.
            .DEF EXPB1=R21                  ;

            ;
            ; Байты мантиссы частного.
            .DEF Q0=R22
            .DEF Q1=R23
            .DEF Q2=R24
            .DEF Q3=R25

            .EQU QDIGITS=24+2               ; Количество цифр частного к вычислению: 24 + R + G + S (S определяется вне цикла).

            .DEF STEPS=R17                  ; Счетчик цикла.

            .EQU RGSMASK=0b00000111         ; Маска для извлечения RGS-битов при округлении.
            .DEF RGSBITS=R18                ; Дополнительные биты мантиссы частного + STICKY-бит для корректного округления.

            .DEF RSIGN=R0                   ; Знак результата (частное/произведение/алгебраическая сумма).

            ;
            ; Мантисса произведения.
            .DEF MANTP0=R17
            .DEF MANTP1=R18
            .DEF MANTP2=R19
            .DEF MANTP3=R23
            .DEF MANTP4=R24
            .DEF MANTP5=R25
            .DEF GUARD=R7                  ; GUARD-регистр для временного хранения R-бита мантиссы произведения.

            .DEF STATUS0=R5                ; Регистр статуса после операции над младшим байтом.
            .DEF STATUS1=R6                ; Регистр статуса после операции над старшим байтом.
            .DEF SREGACC=R17               ; Регистр статуса после нескольких операций. например, побитовое И регистра STATUS.

;
; Делит два числа по схеме с неподвижным делителем без восстановления остатка.
;
; Делимое ожидается в регистрах: R11, R10, R9, R8.
; Делитель ожидается в регистрах: R15, R14, R13, R12. 
; Частное помещается на место делимого: R11, R10, R9, R8.
FDIV32:     ;
            ; Фильтрация операндов.
            CLR R16                     ;
            OR R16,R12                  ;
            OR R16,R13                  ;
            OR R16,R14                  ;
            OR R16,R15                  ;
            IN R16,SREG                 ; 
            SBRC R16,SREG_Z             ; Делитель равен нулю?
            IJMP                        ; Да, выбрасываем ошибку. Делимое при этом может быть как нулевым так и ненулевым - оба варианта некорректны.

            CLR R16                     ; Нет, проверяем делимое.
            OR R16,R8                   ;
            OR R16,R9                   ;
            OR R16,R10                  ;
            OR R16,R11                  ;
            IN R16,SREG                 ;
            SBRC R16,SREG_Z             ; Делимое равно нулю?
            RJMP SETZERO                ; Да, возвращаем ноль.
                                        ; Нет, оба операнда ненулевые, вычисляем частное.
            
            ;
            ; Определение знака частного.
            MOV RSIGN,R11               ; Копируем старший байт делимого.
            MOV R1,R15                  ; Копируем старший байт делителя.
            LDI R16,0b10000000          ; Загружаем маску знака.
            AND RSIGN,R16               ; Извлекаем знак делимого.
            AND R1,R16                  ; Извлекаем знак делителя.
            EOR RSIGN,R1                ; Определяем знак частного.

            ;
            ; Распаковка делимого.
            ROL R10                     ; MSB мантиссы делимого содержит LSB экспоненты. Сдвигаем его в бит переноса.
            ROL R11                     ; Избавляемся от знака делимого и восстанавливаем младший бит экспоненты.
            ROR R10                     ; Возвращаем на место старший байт мантиссы делимого.
            OR R10,R16                  ; Восстанавливаем скрытую единицу мантиссы.

            ;
            ; Распаковка делителя.
            ROL R14                     ; То же самое для делителя.
            ROL R15                     ; 
            ROR R14                     ; 
            OR R14,R16                  ;

            ;
            ; Вычисление экспоненты частного.
            CLR EXPA1
            CLR EXPB1
            
            COM EXPB0                   ; Формируем доп. код экспоненты делителя.
            COM EXPB1                   ;
            LDI R16,1                   ; 
            ADD EXPB0,R16               ; 
            LDI R16,0                   ;
            ADC EXPB1,R16               ;

            ADD EXPA0,EXPB0             ; EXPA=EXPA-EXPB.
            ADC EXPA1,EXPB1             ;
            LDI R16,127                 ; Восстанавливаем результат в коде со смещением.
            ADD EXPA0,R16               ; 
            LDI R16,0                   ;
            ADC EXPA1,R16               ;
            
            ;
            ; Формирование доп. кода мантиссы делителя.
            CLR MANTAG                  ;
            CLR MANTBG                  ;

            MOV MANTB0NEG,MANTB0        ; Копируем положительную мантиссу делителя.
            MOV MANTB1NEG,MANTB1        ;
            MOV MANTB2NEG,MANTB2        ;
            MOV MANTBGNEG,MANTBG        ;

            COM MANTB0NEG               ; Поскольку 2^N-|B|=(2^N-1-|B|)+1=COM(|B|)+1,
            COM MANTB1NEG               ; то инвертируем биты положительной мантиссы
            COM MANTB2NEG               ;
            COM MANTBGNEG               ;

            LDI R16,1                   ; и прибавляем единицу,
            ADD MANTB0NEG,R16           ; не забывая про возможное появление бита переноса.
            LDI R16,0                   ;
            ADC MANTB1NEG,R16           ; 
            ADC MANTB2NEG,R16           ; 
            ADC MANTBGNEG,R16           ;

            ;
            ; Вычисление мантиссы частного.
            LDI STEPS,QDIGITS           ; Количество шагов равно количеству вычисляемых цифр частного.
            CLR Q0                      ; Зануляем мантиссу частного.
            CLR Q1                      ;
            CLR Q2                      ;
            CLR Q3                      ;

SUBMANTB:   ADD MANTA0,MANTB0NEG        ; Вычитаем из мантиссы делимого или остатка
            ADC MANTA1,MANTB1NEG        ; мантиссу делителя,
            ADC MANTA2,MANTB2NEG        ; умноженную на вес
            ADC MANTAG,MANTBGNEG        ; очередной цифры частного.

CALCDIGIT:  IN R16,SREG                 ;
            SBRS R16,SREG_N             ; Остаток отрицательный?
            SBR Q0,1                    ; Нет, устанавливаем текущую цифру частного в 1.

            DEC STEPS                   ; Вычислены все цифры частного?
            BREQ RESTPOSREM             ; Да, восстанавливаем последний положительный остаток.

            CLC                         ; Освобождаем и зануляем LSB для следующей цифры частного.
            ROL Q0                      ;
            ROL Q1                      ; 
            ROL Q2                      ;
            ROL Q3                      ;

            CLC                         ; Сдвигаем остаток влево вместе с виртуальной
            ROL MANTA0                  ; разрядной сеткой, которая привязана к нему.
            ROL MANTA1                  ; Неподвижная мантисса делителя в этой сетке
            ROL MANTA2                  ; станет эквивалентна умноженной на вес следующей
            ROL MANTAG                  ; младшей цифры частного, которую мы будем выяснять.

            IN R16,SREG                 ;
            SBRS R16,SREG_N             ; Остаток положительный?
            RJMP SUBMANTB               ; Да, отнимаем мантиссу делителя.
            ADD MANTA0,MANTB0           ; Нет, прибавляем мантиссу делителя.
            ADC MANTA1,MANTB1           ;
            ADC MANTA2,MANTB2           ;
            ADC MANTAG,MANTBG           ;
            RJMP CALCDIGIT              ; Определяем следующую цифру частного.

RESTPOSREM: IN R16,SREG                 ;
            SBRS R16,SREG_N             ; Последний остаток уже положительный?
            RJMP CALCSTICKY             ; Да, переходим к вычислению STICKY-бита.
            ADD MANTA0,MANTB0           ; Нет, восстанавливаем до последнего положительного.
            ADC MANTA1,MANTB1           ;
            ADC MANTA2,MANTB2           ;
            ADC MANTAG,MANTBG           ;

            ;
            ; Вычисление STICKY-бита для корректного округления к ближайшему.
            ;
            ; Если остаток ненулевой, значит справа от частного существуют ненулевые биты.
            ; S=1, R>0
            ; S=0, R=0
CALCSTICKY: COM MANTA0                  ; Вычисление доп. кода остатка.
            COM MANTA1                  ; Инвертируем остаток: 2^N-1-A < 2^N (для всех значений A).
            COM MANTA2                  ; Прибавляем единицу: 2^N-1-A+1=2^N-A < 2^N (только для ненулевых A).
            COM MANTAG                  ; Следовательно, только при нулевом остатке
            LDI R16,1                   ; из старшего байта будет единица переноса.
            ADD MANTA0,R16              ; А это значит, что S=NOT(C), где C - бит переноса.
            LDI R16,0                   ;
            ADC MANTA1,R16              ;
            ADC MANTA2,R16              ;
            ADC MANTAG,R16              ;

            IN R16,SREG                 ; Конвертируем бит переноса в S-бит.
            LDI R17,1                   ; 
            EOR R16,R17                 ;
            OUT SREG,R16                ;

            ROL Q0                      ; Добавляем справа к мантиссе частного значение S-бита.
            ROL Q1                      ; 
            ROL Q2                      ;
            ROL Q3                      ;

            ;
            ; Нормализация мантиссы частного.
            ;
            ; Мантисса частного лежит в интервале (0.5, 2)
            ; поэтому денормализация возможна только на 1 разряд вправо.
            SBRC Q3,2                   ; Целочисленная единица в частном есть?
            RJMP CHECKEXP               ; Да, частное нормализовано, проверяем экспоненту.
            CLC                         ; Нет, нормализуем влево на 1 разряд.
            ROL Q0                      ;
            ROL Q1                      ;
            ROL Q2                      ;
            ROL Q3                      ;
                                        
            LDI R16,0xFF                ; Уменьшаем экспоненту частного на 1.
            LDI R17,0XFF                ;
            ADD EXPR0,R16               ;
            ADC EXPR1,R17               ;

            ;
            ; Проверка экспоненты на переполнение/антипереполнение.
            ;
            ; Переполнение: EXP > 127+127=254. По стандарту - установка inf. Текущая реализация - выброс исключения.
            ; Антипереполнение: EXP < -126+127=1. По стандарту - переход к денормализованному числу. Текущая реализация - установка частного в ноль.
CHECKEXP:   MOV R18,EXPR0               ; Копируем расширенную экспоненту частного.
            MOV R19,EXPR1               ;

            LDI R16,255                 ; Формируем -1 в доп. коде.
            LDI R17,255                 ; 
            ADD R16,R18                 ; Если истинная экспонента меньше минимального представимого значения (-126),
            ADC R17,R19                 ; то в коде со смещением после вычитания единицы будет получено отрицательное число.
            IN R16,SREG                 ; 
            SBRC R16,SREG_N             ; Несмещенная экспонента меньше -126?
            RJMP SETZERO                ; Да, антипереполнение, возвращаем ноль.
                                        ; 
            LDI R16,1                   ; Нет, проверяем экспоненту на переполнение.
            LDI R17,0                   ; Если истинная экспонента больше максимального представимого значения (127),
            ADD R16,R18                 ; то в коде со смещением после прибавления единицы старший байт расширенной экспоненты
            ADC R17,R19                 ; будет отличен от нуля.
            COM R17                     ; Если старший байт содержит ноль,
            LDI R16,1                   ; то вычисление доп. кода даст ноль.
            ADD R16,R17                 ; Несмещенная экспонента меньше 128?
            BREQ ROUND                  ; Да, переполнения нет, переходим к округлению.
            IJMP                        ; Нет, переполнение, прыжок на обработчик ошибок, указанный в Z.

            ;
            ; Округление к ближайшему.
            ;
            ; NOTE: Округление происходит уже после нормализации (если была денормализация).
            ;
            ; Возможные сочетания битов RS. Для краткости GUARD-бит здесь не учитывается, иллюстрируется сама идея округления.
            ; RS
            ; --
            ; 00: Точное значение. |ERR| = 0.
            ; 01: Отбрасываем. |ERR| < 2^-24=2^-23/2=ULP/2. Ошибка меньше половины веса последнего разряда мантиссы одинарной точности.
            ; 10: Если такая ситуация имеет место, значит делимое имеет ненулевые разряды за пределами исходной сетки одинарной точности, что невозможно в нашем случае (обоснование - в доке).
            ; 11: Отбрасываем и прибавляем 2^-23. |ERR| < 2^-24=ULP/2.
            ;
            ; Комментарии к последнему случаю:
            ; Q - истинная мантисса частного (бесконечная точность).
            ; Q' - округленное значение.
            ; Q' = Q-(2^-24+A)+2^-23, где A - биты за пределами сетки вправо от R, индикатором которых является S-бит, следовательно, A < 2^-24.
            ; 2^-23 = 2^-24+2^-24 = 2^-24+(A+B), где (A+B) = 2^-24, но A > 0, следовательно B < 2^-24.
            ; тогда можем записать Q' = Q-2^-24-A+2^-24+A+B = Q+B, где B < 2^-24.
            ; Поэтому в последнем случае |ERR| < 2^-24=ULP/2.
ROUND:      MOV RGSBITS,Q0              ; Извлекаем RGS-биты из младшего байта мантиссы частного.
            LDI R16,RGSMASK             ;
            AND RGSBITS,R16             ;

            LDI STEPS,3                 ; Отбрасываем RGS-биты в мантиссе частного.
RSHIFT3:    CLC                         ; Мы вычисляли 26 цифр частного + S-бит,
            ROR Q3                      ; поэтому после сдвига все цифры мантиссы частного
            ROR Q2                      ; поместятся в трех младших байтах.
            ROR Q1                      ;
            ROR Q0                      ;
            DEC STEPS                   ;
            BRNE RSHIFT3                ;

            LDI R16,0xFC                ; Если в RGS установлен бит R и есть ненулевые биты справа от него,
            ADD RGSBITS,R16             ; тогда в RGS находится число больше 4, а значит, отбрасывая RGS
            IN R16,SREG                 ; мы получаем ошибку больше ULP/2.
            SBRC R16, SREG_N            ; Отбросили больше ULP/2?
            RJMP PACK                   ; Нет, пакуем частное.

            LDI R16,1                   ; Да, прибавляем 2^-23.
            ADD Q0,R16                  ; Переполнения при этом не будет, потому что
            LDI R16,0                   ; нормализованная мантисса, которая даст переполнение - больше максимальной возможной нормализованной мантиссы,
            ADC Q1,R16                  ; а денормализованная мантисса, которая даст после нормализации переполнение,
            ADC Q2,R16                  ; может быть получена только если делимое имеет ненулевые разряды за пределами одинарной точности, что невозможно в нашем случае.

            ;
            ; Упаковка знака, мантиссы и экспоненты частного и запись на место делимого.
            ; NOTE: Нормализованная и округленная мантисса частного сейчас занимает 3 младших байтах.
PACK:       ROL Q0                      ; Сдвигаем мантиссу влево, убирая целочисленную единицу.
            ROL Q1                      ;
            ROL Q2                      ;

            CLC                         ; Выдвигаем вправо LSB экспоненты в разряд переноса,
            ROR EXPR0                   ; одновременно освобождая MSB под знак.

            ROR Q2                      ; Возвращаем мантиссу на место
            ROR Q1                      ; с LSB экспоненты вместо целочисленной единицы.
            ROR Q0                      ;

            OR EXPR0,RSIGN              ; Устанавливаем разряд знака.

            ;
            ; Запись мантиссы частного на место делимого.
            MOV MANTA0,Q0
            MOV MANTA1,Q1
            MOV MANTA2,Q2

            RJMP EXIT

;
; Умножает два числа по схеме с неподвижным множителем.
; NOTE: Мы рассматриваем умножение множителя на множимое, т.е. B*A.
;
; Множимое ожидается в регистрах: R11, R10, R9, R8.
; Множитель ожидается в регистрах: R15, R14, R13, R12. 
; Произведение помещается на место множимого: R11, R10, R9, R8.
FMUL32:     ;
            ; Фильтрация операндов.
            CLR R16                     ;
            OR R16,R8                   ;
            OR R16,R9                   ;
            OR R16,R10                  ;
            OR R16,R11                  ;
            IN R16,SREG                 ; 
            SBRC R16,SREG_Z             ; Множимое равно нулю?
            RJMP SETZERO                ; Да, возвращаем ноль.

            CLR R16                     ; Нет, проверяем множитель.
            OR R16,R12                  ;
            OR R16,R13                  ;
            OR R16,R14                  ;
            OR R16,R15                  ;
            IN R16,SREG                 ; 
            SBRC R16,SREG_Z             ; Множитель равен нулю?
            RJMP SETZERO                ; Да, возвращаем ноль.

            ;
            ; Определение знака произведения.
            MOV RSIGN,R11               ; Копируем старший байт множимого.
            MOV R1,R15                  ; Копируем старший байт множителя.
            LDI R16,0b10000000          ; Загружаем маску знака.
            AND RSIGN,R16               ; Извлекаем знак множимого.
            AND R1,R16                  ; Извлекаем знак множителя.
            EOR RSIGN,R1                ; Определяем знак произведения.

            ;
            ; Распаковка множимого.
            ROL R10                     ; MSB мантиссы содержит LSB экспоненты. Сдвигаем его в бит переноса.
            ROL R11                     ; Избавляемся от знака и восстанавливаем младший бит экспоненты.
            SEC                         ; Восстанавливаем скрытую единицу мантиссы.
            ROR R10                     ; Возвращаем на место старший байт мантиссы.

            ;
            ; Распаковка множителя.
            ROL R14                     ; То же самое что и для множимого.
            ROL R15                     ; 
            SEC                         ;
            ROR R14                     ; 

            ;
            ; Вычисление экспоненты произведения.
            ;
            ; Поскольку экспоненты представлены в коде со смещением, то
            ; их значения всегда являются положительными числами в диапазоне [1,254].
            CLR EXPA1
            CLR EXPB1
            
            ADD EXPA0,EXPB0             ; EXPA=EXPA+EXPB.
            ADC EXPA1,EXPB1             ; Сумма экспонент содержит избыточное значение 127.
            LDI R16,-127                ; Необходимо отнять это значение.
            LDI R17,255                 ; Формируем доп. код для -127 в двойной сетке.
            ADD EXPA0,R16               ; Восстанавливаем сумму экспонент
            ADC EXPA1,R17               ; в коде со смещением.

            ;
            ; Вычисление мантиссы произведения.
            LDI R22,24                  ; Количество шагов цикла равно количеству цифр множимого.

            CLR MANTP0                  ; Зануляем произведение.
            CLR MANTP1                  ;
            CLR MANTP2                  ;
            CLR MANTP3                  ;
            CLR MANTP4                  ;
            CLR MANTP5                  ;

NEXTDIGIT:  ROR MANTA2                  ; Извлекаем очередную цифру множимого.
            ROR MANTA1                  ;
            ROR MANTA0                  ;
                                        
            IN R16,SREG                 ; 
            SBRS R16,SREG_C             ; Цифра равна 1?
            RJMP LOOPCOND0              ; Нет, равна 0, множитель не прибавляем.
            ADD MANTP3,MANTB0           ; Да, прибавляем множитель к аккумулятору.
            ADC MANTP4,MANTB1           ; Младшие 3 байта множителя в двойной сетке нулевые,
            ADC MANTP5,MANTB2           ; поэтому достаточно сложить только старшие байты.

LOOPCOND0:  DEC R22                     ; Это была последняя цифра множимого?
            BREQ CHECKOVF0              ; Да, мантисса произведения вычислена, проверяем её на переполнение.

            ROR MANTP5                  ; Нет, делим аккумулятор на 2.
            ROR MANTP4                  ;
            ROR MANTP3                  ;
            ROR MANTP2                  ;
            ROR MANTP1                  ;
            ROR MANTP0                  ;            

            RJMP NEXTDIGIT              ; Переходим к следующей цифре множимого.

CHECKOVF0:  IN R16,SREG                 ; 
            SBRS R16,SREG_C             ; Мантисса произведения дала переполнение?
            RJMP ROUNDPROD              ; Нет, переходим к её округлению.
            ROR MANTP5                  ; Да, нормализуем мантиссу произведения вправо на 1 разряд.
            ROR MANTP4                  ;
            ROR MANTP3                  ;
            ROR MANTP2                  ;
            ROR MANTP1                  ;
            ROR MANTP0                  ;

            LDI R16,1                   ; Корректируем экспоненту.
            ADD EXPA0,R16               ;
            LDI R16,0                   ;
            ADC EXPA1,R16               ;

            ;
            ; Округление мантиссы произведения.
            ;
            ; После установки S-бита и извлечения пары RS
            ; MANTP2 может содержать следующие значения:
            ; - 0b11000000
            ; - 0b10000000
            ; - 0b01000000
            ; - 0b00000000
ROUNDPROD:  CLR GUARD
            CLC
            
            ROL MANTP0                  ; Сдвигаем R-БИТ в GUARD-регистр.
            ROL MANTP1                  ; Теперь младшая часть содержит только биты после R.
            ROL MANTP2                  ;
            ROL GUARD                   ;

            COM MANTP0                  ; Если после R-БИТА все биты нулевые,
            COM MANTP1                  ; то вычисление доп. кода младшей части
            COM MANTP2                  ; даст бит переноса.
            LDI R16,1                   ; Поэтому отсутствие бита переноса
            ADD MANTP0,R16              ; используем как признак того,
            LDI R16,0                   ; что после R-бита есть хотя бы один ненулевой бит.
            ADC MANTP1,R16              ;
            ADC MANTP2,R16              ;

            IN R16,SREG                 ;
            SBRS R16,SREG_C             ; После r-бита есть ненулевые биты?
            SBR MANTP2,0b10000000       ; Да, устанавливаем S-бит.

            ROR GUARD                   ; Нет, вся младшая часть нулевая (включая S-бит, поэтому явно обнулять S-бит нет необходимости).
            ROR MANTP2                  ; Восстанавливаем R-бит.
            ROR MANTP1                  ;
            ROR MANTP0                  ;

            LDI R16,0b11000000          ; Извлекаем RS-биты.
            AND MANTP2,R16              ;

            CLR GUARD                   ; Интерпретируем регистр с RS-битами как число и формируем его доп. код.
            COM MANTP2                  ; Доп. код формируем в двойной сетке, т.к. для представления в доп. коде
            COM GUARD                   ; значений 0b11000000 И 0b10000000 со знаком минус
            LDI R16,1                   ; одинарной сетки уже не достаточно.
            ADD MANTP2,R16              ;
            LDI R16,0                   ;
            ADC GUARD,R16               ;

            CLR STATUS0                 ; Разность между опорным значеним 0b10000000 и числовой интерпретацией RS
            CLR STATUS1                 ; однозначно связана с направлением округления (см. доку).
            LDI R16,0b10000000          ; За признак берем нулевой результат и знак полученной разности.
            ADD MANTP2,R16              ; 
            IN STATUS0,SREG             ; Сохраняем флаги после операции с младшим байтом.
            LDI R16,0                   ; 
            ADC GUARD,R16               ;
            IN STATUS1,SREG             ; Сохраняем флаги после операции со старшим байтом.

            SBRS STATUS1,SREG_N         ; RS=0b11000000? [NOTE: Отрицательная разность возможна только в ситуации 0b10000000-0b11000000.]
            RJMP HALFWAY                ; Нет, проверяем следующий вариант.
            LDI R16,1                   ; Да, младшая часть больше ulp/2. Округляем в большую сторону.
            ADD MANTP3,R16              ; Отбрасываем младшую часть и прибавляет ULP.
            LDI R16,0                   ; Это эквивалентно прибавлению к младшей части величины меньше ULP/2,
            ADC MANTP4,R16              ; приводящему к занулению младшей части и появлению бита переноса в MANTP3.
            ADC MANTP5,R16              ;
            RJMP CHECKOVF1              ;

HALFWAY:    AND STATUS1,STATUS0         ; Разность нулевая, если флаг Z был установлен для каждого байта.
            SBRS STATUS1,SREG_Z         ; RS=0b10000000?
            RJMP CHECKEXP1              ; Нет, RS=0b01000000 или RS=0b00000000. Младшая часть меньше ULP/2, просто отбрасываем её. Переполнение при округлении не возможно - пропускаем проверку.
            LDI R16,0b00000001          ; Да, симметричное округление. Младшая часть равна ULP/2, округляем к четному.
            AND R16,MANTP3              ; Извлекаем ULP в R16.
            ADD MANTP3,R16              ; Если ULP=1, то старшая часть нечетная
            LDI R16,0                   ; и прибавление R16 (который также содержит 1) даст переход к четному.
            ADC MANTP4,R16              ; Если же ULP=0, то значение уже четное
            ADC MANTP5,R16              ; и прибавление R16 (который также содержит 0) никакого эффекта не даст, оставляя значение четным.

            ;
            ; Проверка мантиссы произведения на переполнение после округления.
CHECKOVF1:  IN R16,SREG                 ; 
            SBRS R16,SREG_C             ; Округление дало переполнение?
            RJMP CHECKEXP1              ; Нет, переходим к проверке экспоненты.
            ROR MANTP5                  ; Да, нормализуем мантиссу произведения вправо на 1 разряд.
            ROR MANTP4                  ;
            ROR MANTP3                  ;

            LDI R16,1                   ; Корректируем экспоненту.
            ADD EXPA0,R16               ;
            LDI R16,0                   ;
            ADC EXPA1,R16               ;

            ;
            ; Проверка итогового произведения на переполнение/антипереполнение по экспоненте.
            ;
            ; Если экспонента меньше -126 (-126+127=1 в коде со смещением), то произведение слишком мало для представления в одинарном float и мы переходим к нулю.
            ; Если экспонента больше 127 (127+127=254 в коде со смещением), то произведение слишком велико и мы выбрасываем исключение.
CHECKEXP1:  MOV R18,EXPR0               ; Копируем расширенную экспоненту произведения.
            MOV R19,EXPR1               ;

            LDI R16,255                 ; Формируем -1 в доп. коде.
            LDI R17,255                 ; 
            ADD R16,R18                 ; Если истинная экспонента меньше минимального представимого значения (-126),
            ADC R17,R19                 ; то в коде со смещением после вычитания единицы будет получено отрицательное число.
            IN R16,SREG                 ; 
            SBRC R16,SREG_N             ; Истинная экспонента меньше -126?
            RJMP SETZERO                ; Да, антипереполнение, возвращаем ноль.
                                        ; 
            LDI R16,1                   ; Нет, проверяем экспоненту на переполнение.
            LDI R17,0                   ; Если истинная экспонента больше максимального представимого значения (127),
            ADD R16,R18                 ; то в коде со смещением после прибавления единицы старший байт расширенной экспоненты будет отличен от нуля.
            ADC R17,R19                 ; Истинная экспонента меньше 128?
            BREQ PACKPROD               ; Да, переполнения нет, переходим к упаковке.
            IJMP                        ; Нет, переполнение, прыжок на обработчик ошибок, указанный в Z.
            
            ;
            ; Упаковка мантиссы и экспоненты произведения.
PACKPROD:   ROL MANTP3                  ; Сдвигаем мантиссу влево, убирая целочисленную единицу.
            ROL MANTP4                  ; NOTE: Достаточно сдвинуть только старший байт мантиссы.
            ROL MANTP5                  ;

            CLC                         ; Выдвигаем вправо LSB экспоненты в разряд переноса,
            ROR EXPR0                   ; одновременно освобождая MSB под знак.

            ROR MANTP5                  ; Возвращаем мантиссу на место
            ROR MANTP4                  ; с LSB экспоненты вместо целочисленной единицы.
            ROR MANTP3                  ;

            OR EXPR0,RSIGN              ; Устанавливаем разряд знака.

            MOV MANTA0,MANTP3           ; Запись мантиссы произведения на место мантиссы множимого.
            MOV MANTA1,MANTP4
            MOV MANTA2,MANTP5

            RJMP EXIT

            ; Выход из FMUL32.
EXIT:       RET

            ;
            ; Установка результата в ноль.
            ;
            ; Выполняется в следующих случаях:
            ; - Антипереполнение результата для любой операции.
            ; - Делимое равно нулю.
            ; - Хотя бы один сомножитель равен нулю.
            ; - Оба слагаемых равны нулю.
SETZERO:    CLR MANTA0
            CLR MANTA1
            CLR MANTA2
            CLR EXPA0
            RJMP EXIT

;
; Вычисляет разность двух чисел.
;
; Уменьшаемое ожидается в регистрах: R11, R10, R9, R8.
; Вычитаемое ожидается в регистрах: R15, R14, R13, R12. 
; Разность помещается на место уменьшаемого: R11, R10, R9, R8.
FSUB32:     LDI R16,0b10000000          ; B=-B.
            EOR B3,R16                  ;
            RJMP FADD32                 ;

;
; Складывает два числа.
;
; Первое слагаемое ожидается в регистрах: R11, R10, R9, R8.
; Второе слагаемое ожидается в регистрах: R15, R14, R13, R12. 
; Сумма помещается на место первого слагаемого: R11, R10, R9, R8.
FADD32:     ;
            ; Своп.
            ; Установка наибольшего (по модулю) операнда первым.
            MOV R0,R8                   ; Копируем A.
            MOV R1,R9                   ;
            MOV R2,R10                  ;
            MOV R3,R11                  ;

            MOV R4,R12                  ; Копируем B.
            MOV R5,R13                  ;
            MOV R6,R14                  ;
            MOV R7,R15                  ;

            LDI R16,0b01111111          ;
            AND R3,R16                  ; Вычисляем |A|.
            AND R7,R16                  ; Вычисляем |B|.

            COM R4                      ; Вычисляем доп. код |B|.
            COM R5                      ;
            COM R6                      ;
            COM R7                      ;
            LDI R16,1                   ;
            ADD R4,R16                  ;
            LDI R16,0                   ;
            ADC R5,R16                  ;
            ADC R6,R16                  ;
            ADC R7,R16                  ;

            ADD R4,R0                   ; |A|-|B|.
            ADC R5,R1                   ; Перезаписываем -|B|, чтобы сохранить нетронутым |A|.
            ADC R6,R2                   ; 
            ADC R7,R3                   ;
                                        ; |A|-|B|>=0?
            BRGE HANDLEZERO             ; Да, своп не нужен. Переходим к обработке нулевых операндов.
                                        ; Нет, делаем своп.
            MOV R3,R11                  ; Бэкапим A. Но поскольку регистры R0..R3 уже хранят |A|, остается только восстановить знак.
            
            MOV R8,R12                  ; Записываем B на место A.
            MOV R9,R13                  ;
            MOV R10,R14                 ;
            MOV R11,R15                 ;

            MOV R12,R0                  ; Восстанавливаем из бэкапа A на место B.
            MOV R13,R1                  ;
            MOV R14,R2                  ;
            MOV R15,R3                  ;

            ;
            ; Обработка нулевых операндов.
            ;
            ; Возможные ситуации до свопа (где 1 - любое ненулевое значение операнда):
            ; 0,0
            ; 0,1
            ; 1,0
            ; 1,1
            ;
            ; После свопа остаются только следующие варианты:
            ; 0,0
            ; 1,0
            ; 1,1
            ;
            ; Следовательно, если после свопа первый операнд нулевой, значит оба нулевые, результат - ноль.
            ; Если второй операнд нулевой, значит первый ненулевой, результат - первый операнд.
HANDLEZERO: CLR R16                     ;
            OR R16,MANTA0               ;
            OR R16,MANTA1               ;
            OR R16,MANTA2               ;
            OR R16,EXPA0                ; A=0?
            BREQ SETZERO                ; Да, и A и B равны нулю, возвращаем ноль.

            CLR R16                     ; Нет, проверяем B.
            OR R16,MANTB0               ;
            OR R16,MANTB1               ;
            OR R16,MANTB2               ;
            OR R16,EXPB0                ; B=0?
            BREQ EXIT                   ; Да, возвращаем A (A уже находится в регистре результата).
                                        ; Нет, ни A ни B не равны нулю, продолжаем вычисления.

            ;
            ; Определение знака суммы.
            ;
            ; Берется знак операнда A, который после свопа удовлетворяет выражению |A|>=|B|.
            ; Если |A|>|B| и знаки разные, то знак разности равен знаку наибольшего (по модулю) операнда, т.е. A.
            ; Если же знаки одинаковые, то знак суммы равен знаку любого операнда, в т.ч. A.
            ; Если |A|=|B| и знаки одинаковые, то знак суммы также равен знаку любого операнда, в т.ч. A.
            ; Если же знаки разные, то в силу равенства модулей, разность будет равна нулю и будет установлен положительный знак, независимо от знаков A и B.
CALCSIGN:   MOV RSIGN,R11               ; Копируем старший байт A.
            LDI R16,0b10000000          ; Формируем маску для извлечения знака, который хранится в MSB.
            AND RSIGN,R16               ; Извлекаем знак A.

            ;
            ; Бэкап знака B.
            ; 
            ; Он будет нужен для определения операции: сложение или вычитание.
            MOV R1,R15                  ; Копируем старший байт B.
            AND R1,R16                  ; Извлекаем знак B. Маска знака уже содержится в R16.

            ;
            ; Распаковка операндов.
            ROL R8                      ; Распаковка A.
            ROL R9                      ;
            ROL R10                     ; Выдвигаем в бит переноса LSB экспоненты.
            ROL R11                     ; Восстанавливаем экспоненту в старшем байте.
            SEC                         ; Восстанавливаем в мантиссе A неявную единицу.
            ROR R10                     ;
            ROR R9                      ;
            ROR R8                      ;

            ROL R12                     ; Распаковка B
            ROL R13                     ;
            ROL R14                     ;
            ROL R15                     ;
            SEC                         ;
            ROR R14                     ;
            ROR R13                     ;
            ROR R12                     ;

            ;
            ; Расширяем экспоненту A на один байт влево.
            CLR EXPA1                   ;

            ;
            ; Расширение мантисс до RGS.
            ;
            ; Эти регистры стыкуются справа от мантиссы A и B.
            CLR R6                      ; RGS мантиссы A.
            CLR R7                      ; RGS мантиссы B.

            ;
            ; Выравнивание порядков.
            ;
            ; Экспоненты обоих операндов представлены в коде со смещением и принимают значения в отрезке [1,254].
            ; После свопа порядок A будет либо больше либо равен порядку B. Это значит, что разность экспонент лежит в отрезке [0,253].
            ; Из всего этого следует, что нет необходимости вычислять корректный доп. код в двойной сетке (см. обоснование в доке).
            ;
            ; Здесь может потребоваться окруление до S-бита при денормализации мантиссы B.
            MOV R17,EXPA0               ; Копируем экспоненту A.
            MOV R16,EXPB0               ; Копируем экспоненту B.
            COM R16                     ; Вычисляем младший байт доп. кода экспоненты B.
            INC R16                     ;
            ADD R17,R16                 ; EXP(A)-EXP(B)=0? [NOTE: R17 теперь содержит разность экспонент в отрезке [0,253].]
            BREQ CHOOSEOP               ; Да, порядки равны, выравнивание не требуется.
            LDI R16,31                  ; Нет, выясняем, в каком отрезке лежит разность: [1,30] или [31,253].
            COM R16                     ; Формируем доп. код числа -31 в пределах байта. [NOTE: Необходимости в двойной сетке нет.]
            INC R16                     ;
            ADD R16,R17                 ; (EXP(A)-EXP(B))-31<0? [NOTE: Если истинная разность в двойной сетке отрицательная, то бита переноса из младшего байта не будет.]
            BRCC SHIFTMANTB             ; Да, разность в отрезке [1,30], сдвигаем мантиссу B и формируем S-бит.
            CLR MANTB0                  ; Нет, разность в отрезке [31,253];
            CLR MANTB1                  ; просто устанавливаем значение мантиссы B как 2^-31 (округление до S-бита).
            CLR MANTB2                  ;
            LDI R16,0b00000001          ;
            MOV R7,R16                  ;
            RJMP CHOOSEOP               ;

            ;
            ; Пошаговый сдвиг мантиссы B на разность экспонент вправо.
            ;
            ; Разность экспонент здесь принимает значения в отрезке [1,30].
            ; Если за пределами RGS-зоны оказался хотя бы один единичный бит, то происходит установка S-бита.
SHIFTMANTB: CLR R16                     ; R16 будет хранить в LSB значение бита переноса после каждого сдвига.
            CLC                         ;
            ROR MANTB2                  ; Сдвигаем мантиссу B вправо на 1 разряд вместе с RGS-битами.
            ROR MANTB1                  ;
            ROR MANTB0                  ;
            ROR R7                      ;
            ROL R16                     ; Извлекаем бит переноса в R16.
            OR R7,R16                   ; Если C!=0, значит за пределами RGS оказался единичный бит, значит устанавливаем S-бит.

            DEC R17                     ; Мантисса B сдвинута на разность порядков?
            BREQ CHOOSEOP               ; Да, переходим к выбору арифметической операции.
            RJMP SHIFTMANTB             ; Нет, сдвигаем дальше.

            ;
            ; Выбор арифметической операции.
CHOOSEOP:   EOR R1,R0                   ; SIGN(A)=SIGN(B)?
            BRNE DIFF                   ; Нет, знаки разные, переходим к вычитанию.
                                        ; Да, вычисляем сумму.

            ;
            ; Вычисление суммы модулей мантисс.
            ;
            ; Здесь возможно только переполнение результата.
            ; Мантисса суммы записывается на место мантиссы A.
SUM:        ADD R6,R7                   ; Складываем мантиссы A и B.
            ADD R8,R12                  ; У мантиссы A RGS-зона всегда нулевая, поэтому бит переноса не возможен.
            ADC R9,R13                  ;
            ADC R10,R14                 ;
                                        ; Переполнение есть?
            BRCC ROUNDSUM               ; Нет, переходим к округлению.
            ROR R10                     ; Да, нормализуем мантиссу вправо.
            ROR R9                      ;
            ROR R8                      ;
            ROR R6                      ;
            CLR R16                     ; Устанавливаем S-бит, если при нормализации был потерян единичный бит.
            ROL R16                     ; 
            OR R6,R16                   ;
            INC EXPA0                   ; Корректируем экспоненту. В худшем случае экспонента равна 254 поэтому бита переноса в старший байт не будет.
            RJMP ROUNDSUM               ;
            
            ;
            ; Вычисление разности модулей мантисс.
            ;
            ; Здесь в худшем случае возможна денормализация результата вправо в отрезке [0,24]
            ; При A=1 И B=((2^24)-1)*2^-23*2^-1.
DIFF:       COM R7                      ; Вычисляем псевдо доп. код мантиссы B. Это дополнение до 2 вместо 4.
            COM MANTB0                  ; Результат всегда положительный, поэтому нет необходимости в истинном доп. коде.
            COM MANTB1                  ; В доп. бите слева всегда будет единица, а из младшей части всегда будет бит переноса,
            COM MANTB2                  ; зануляющий разряд истинного доп. кода.
            LDI R16,1                   ;
            ADD R7,R16                  ;
            CLR R16                     ;
            ADC MANTB0,R16              ;
            ADC MANTB1,R16              ;
            ADC MANTB2,R16              ;

            LDI SREGACC,0b00000010      ; Маска для Z-флага.
            ADD R6,R7                   ; Складываем RGS-регистры.
            IN R16,SREG                 ; Извлекаем из регистра статуса только Z-флаг.
            AND SREGACC,R16             ;
            ADD MANTA0,MANTB0           ; Складываем следующую пару байт мантисс. (У мантиссы A RGS-зона всегда нулевая, поэтому бит переноса из предыдущей операции не возможен.)
            IN R16,SREG                 ;
            AND SREGACC,R16             ;
            ADC MANTA1,MANTB1           ; Складываем следующую пару байт.
            IN R16,SREG                 ;
            AND SREGACC,R16             ;
            ADC MANTA2,MANTB2           ; Складываем последнюю пару байт.
            IN R16,SREG                 ;
            AND SREGACC,R16             ; Результат нулевой? (SREGACC=STATUS0^STATUS1^STATUS2^STATUS3^0b00000010, где STATUS<N>-регистр статуса после сложения очередной пары байт мантисс.)
            BRNE SETZERO1               ; Да, устанавливаем положительный ноль. (Если флаг Z был установлен для каждой пары байт, то SREGACC окажется ненулевым).

            SBRC MANTA2,7               ; Мантисса разности денормализована?
            RJMP ROUNDSUM               ; Нет, мантисса нормализована, переходим к округлению.
                                        ; Да, выполняем нормализацию и коррекцию экспоненты.
            CLR R16                     ; Счетчик степени денормализации.
            LDI R17,255                 ; Шаг счетчика R17=-1. Формируем счетчик сразу в доп. коде.
NORM:       CLC                         ;
            ROL R6                      ; Нормализуем влево.
            ROL MANTA0                  ;
            ROL MANTA1                  ;
            ROL MANTA2                  ;
            ADD R16,R17                 ; DEC R16.
            SBRS MANTA2,7               ; Мантисса разности нормализовалась?
            RJMP NORM                   ; Нет, продолжаем сдвиг.
            ADD EXPA0,R16               ; Да, корректируем экспоненту: EXPA-K, где K - степень денормализации.
            ADC EXPA1,R17               ; R17,R16 - расширили доп. код R16 до двух байт (воспользовались тем, что R17 уже содержит 255).

            ;
            ; Округление.
            ;
            ; После сдвига R-бита происходит проверка C- И Z-битов в регистре статуса.
            ; Если Z=0 после сдвига, то это ситуация симметричного округления, иначе - округление в большую сторону.
ROUNDSUM:   MOV R16,R6                  ; Копируем RGS.
            CLC                         ;
            ROL R16                     ; R-бит равен нулю?
            BRCC CHECKEXP2              ; Да, RGS=000|001|010|011. Отбрасываем RGS, ошибка ERR<ULP/2.
            BREQ HALFWAY1               ; Нет, RGS=ULP/2=100, симметричное округление.
            LDI R16,1                   ; Нет, RGS=101|110|111.
            RJMP ADDULP                 ; Отбрасываем RGS и прибавляем ULP. Ошибка ERR<ULP/2.

HALFWAY1:   LDI R16,1                   ; Извлекаем значение разряда ULP.
            AND R16,R8                  ;
ADDULP:     ADD R8,R16                  ; Прибавляем ULP.
            CLR R16                     ; Если значение нечетное, то ULP=1, и результат станет четным.
            ADC R9,R16                  ; Если значение уже четное, то ULP=0, и прибавление нуля не изменит результат.
            ADC R10,R16                 ; Есть переполнение?
            BRCC CHECKEXP2              ; Нет, переходим к проверке экспоненты.
            ROR MANTA2                  ; Да, нормализуем мантиссу A. Поскольку переполнение при округлении, два младших байта мантиссы уже нулевые.
            INC EXPA0                   ; Корректируем экспоненту. 

            ;
            ; Проверка экспоненты на переполнение/антипереполнение.
            ;
            ; Экспонента в коде со смещением принимает значения в отрезке [-22,255].
            ; Если есть переполнение, то экспонента равна 255 и вычитание её из 255 даст ноль.
            ; Если нет переполнения, то вычитание экспоненты из 255 даст положительное значение.
            ; Если есть антипереполнение, то экспонента принимает значения в отрезке [-22,0] и вычитание единицы из экспоненты всегда даст отрицательное значение.
            ; Если нет антипереполнения, то, поскольку переполнение уже исключено, экспонента лежит в [1,254] и вычитание единицы всегда даст положительное значение.
CHECKEXP2:  LDI R17,255                 ; Записываем 255 в два байта.
            LDI R18,0                   ;

            MOV R21,EXPA0               ; Копируем расширенную экспоненту A.
            MOV R22,EXPA1               ;

            COM R21                     ; Вычисляем доп. код экспоненты в двух байтах.
            COM R22                     ;
            LDI R16,1                   ;
            ADD R21,R16                 ;
            CLR R16                     ;
            ADC R22,R16                 ;

            ADD R17,R21                 ; 255-EXP(A).
            IN STATUS0,SREG             ; Сохраняем флаги после сложения младших байт.
            ADC R18,R22                 ;
            IN STATUS1,SREG             ; Сохраняем флаги после сложения старших байт.

            AND STATUS0,STATUS1         ; Результат нулевой, если флаг Z был установлен для каждого байта.
            SBRC STATUS0,SREG_Z         ; 255-EXP(A)=0?
            IJMP                        ; Да, переполнение, прыжок на обработчик ошибок, указанный в регистре Z.
            LDI R16,255                 ; Нет, проверяем на антипереполнение.
            LDI R17,255                 ;
            ADD R16,EXPA0               ; EXP(A)-1.
            ADC R17,EXPA1               ; Результат отрицательный?
            BRMI SETZERO1               ; Да, антипереполнение, экспонента лежит в [0,-22] и не представима. Возвращаем ноль.
                                        ; Нет, экспонента лежит в [1,254] и представима в одинарном float.

            ;
            ; Упаковка суммы.
            ROL MANTA0                  ; Выдвигаем целочисленную единицу мантиссы суммы в бит переноса.
            ROL MANTA1                  ;
            ROL MANTA2                  ;
            ROL RSIGN                   ; Выдвигаем знак В бит переноса.
            ROR EXPA0                   ; Вдвигаем знак в MSB экспоненты и выдвигаем LSB экспоненты в бит переноса.
            ROR MANTA2                  ; Восстанавливаем исходные биты мантиссы,
            ROR MANTA1                  ; вдвигая в MSB старшего байта мантиссы LSB экспоненты вместо целочисленной единицы.
            ROR MANTA0                  ;

            RJMP EXIT1
            
            ; Выход.
EXIT1:      RET

            ;
            ; Установка результата в ноль.
            ;
            ; Выполняется в следующих случаях:
            ; - Антипереполнение результата для любой операции.
            ; - Делимое равно нулю.
            ; - Хотя бы один сомножитель равен нулю.
            ; - Оба слагаемых равны нулю.
SETZERO1:   CLR MANTA0
            CLR MANTA1
            CLR MANTA2
            CLR EXPA0
            RJMP EXIT1

;
; Преобразует число в формате плавающей точки в целое.
;
; Работает только с положительными нормализованными десятичными числами в отрезке [1,10).
; Таким образом, возвращает целочисленное значение в отрезке [1,9] в пределах байта.
; 
; Аргументы:
;   - NUM - число, ожидается в регистрах: R11, R10, R9, R8.
;
; Результат: целая часть NUM. Помещается в R8.
            .DEF A0=R8                  ;
            .DEF A1=R9                  ;
            .DEF A2=R10                 ;
            .DEF A3=R11                 ;

            .DEF STATUS=R21             ; Регистр статуса.

FTOI:       ROL A2                      ; Распаковываем num.
            ROL A3                      ; A3=EXP(NUM). Поскольку num лежит в [1,10), то все биты целой части в нормализованной мантиссе
            SEC                         ; полностью лежат в старшем байте мантиссы и нет необходимости сдвигать младшие.
            ROR A2                      ;
           
            CLR A0                      ; A0 не содержит битов целой части и нам не интересен. Он будет содержать целую часть десятичного значения NUM.
            LDI R16,-127                ; A3=EXP(NUM)-127. Экспонента лежит в [127,127+3], значит разность всегда > 0, достаточно доп. кода в пределах байта.
            ADD A3,R16                  ; Экспонента нулевая? (Если нулевая, то целая часть мантиссы уже представляет истинную целую часть десятичного значения, которая равна единице.)
            BREQ SHFTMSB                ; Да, делаем финальный сдвиг.
            MOV R16,A3                  ; Нет, устанавливаем счетчик цикла и раскрываем экспоненту, денормализуя мантиссу влево.
DENORM:     ROL A2                      ; A<<1
            ROL A0                      ;
            DEC R16                     ; Мантисса денормализована влево на величину экспоненты?
            BREQ SHFTMSB                ; Да, делаем финальный сдвиг.
            RJMP DENORM                 ; Нет, продолжаем сдвиг.

SHFTMSB:    ROL A2                      ; A0=INT(NUM). (MSB мантиссы содержит LSB истинной целой части - выдвигаем его в A0.)
            ROL A0                      ;

            RET

;
; Преобразует однобайтовое целое число в число в формате плавающей точки.
;
; Аргументы:
;   - NUM - целое число, ожидается в регистре R8.
;
; Результат: число в формате плавающей точки, помещается в R11, R10, R9, R8.
            .DEF A0=R8                  ;
            .DEF A1=R9                  ;
            .DEF A2=R10                 ;
            .DEF A3=R11                 ;

            .DEF STATUS=R21             ; Регистр статуса.

SETZERO3:   CLR A0                      ; A=0.0F.
            CLR A1                      ;
            CLR A2                      ;
            CLR A3                      ;
            RET                         ;

ITOF:       AND A0,A0                   ; NUM=0?
            BREQ SETZERO3               ; Да, возвращаем 0.0F.

            CLR A1                      ; Младшие байты мантиссы.
            CLR A2                      ;
            LDI R16,-1                  ; Байт экспоненты. Инициализируем в -1 для холостого инкремента при первом сдвиге.
            MOV A3,R16                  ;

            CLC                         ; A2 нулевой, поэтому последний сдвиг A2 всегда зануляет бит переноса - очищать на каждой итерации не нужно.
NORM0:      INC A3                      ; Совмещаем LSB целого числа с MSB мантиссы,
            ROR A0                      ; получая, по сути, денормализованную влево мантиссу.
            IN STATUS,SREG              ; Запоминаем флаг Z для A0.
            ROR A2                      ; 
            SBRS STATUS,SREG_Z          ; Мантисса нормализована? (если изначально A0=1, то он занулится, а мантисса сразу окажется нормализованной.)
            RJMP NORM0                  ; Нет, продолжаем нормализацию.
                                        ; Да, пакуем float.
            LDI R16,127                 ; Сохраняем экспоненту в коде со смещением.
            ADD A3,R16                  ;

                                        ; Убираем у мантиссы целочисленную единицу.
            ROL A2                      ; Входное число размером в байт, поэтому все ненулевые биты уже вмещаются в A2, а A0 И A1 РАВНЫ НУЛЮ.

            CLC                         ; Результат будет положительным - разряд знака нулевой.
            ROR A3                      ; Придвигаем экспоненту к мантиссе без единицы.

            ROR A2                      ; Размещаем LSB экспоненты в MSB мантиссы.

            RET

;
; Конвертирует нормализованное десятичное число в формате float в ASCII-строку.
;
; В основе лежит алгоритм, реализованный в z88dk, но с упрощениями для поддержки только нормализованных десятичных чисел.
; [https://github.com/z88dk/z88dk/blob/aa60b9c9e4bab3318b9b10e919919058a4d3aaee/libsrc/math/cimpl/ftoa.c]
;
; Основная идея алгоритма - мы игнорируем тот факт, что десятичное представление
; исходной двоичной дроби искажается при её масштабировании.
; следствие этого допущения - не все десятичные цифры в строке оказываются истинными.
; при округлении десятичного строкового представления разряды просто отбрасываются.
;
; аргументы:
;   - NUM - число, ожидается в регистрах: R11, R10, R9, R8.
;   - PRECISION - количество цифр после точки, ожидается в регистре R12.
;   - STR - указатель на область SRAM, куда будет записана ASCII-строка, ожидается в XH:XL.
            .EQU TEN0=0x00              ; 10.0F.
            .EQU TEN1=0x00              ;
            .EQU TEN2=0x20              ;
            .EQU TEN3=0x41              ;

            .DEF A0=R8                  ; Первый операнд любой арифметической операции: FDIV32,FMUL32,FADD32,FSUB32.
            .DEF A1=R9                  ;
            .DEF A2=R10                 ;
            .DEF A3=R11                 ;

            .DEF B0=R12                 ; Второй операнд любой арифметической операции: FDIV32,FMUL32,FADD32,FSUB32.
            .DEF B1=R13                 ;
            .DEF B2=R14                 ;
            .DEF B3=R15                 ;

            ;
            ; Формирование строки "0" в случае, когда NUM=0.0F.
SETZERO2:   LDI R16,0x30                ;
            ST X+,R16                   ; *STR++='0'.
            RJMP EXITFTOAN              ;

FTOAN:      CLR R16                     ;
            OR R16,A0                   ;
            OR R16,A1                   ;
            OR R16,A2                   ;
            OR R16,A3                   ; NUM=0?
            BREQ SETZERO2               ; Да, формируем фиксированную строку "0.0".

            PUSH R12                    ; Бэкапим PRECISION, т.к. он находится в одном из входных регистров арифметических операций.

            LDI R16,0b10000000          ; Извлекаем знак NUM.
            AND R16,A3                  ; NUM>0?
            BREQ GETINT                 ; Да, NUM уже положительный, продолжаем.
            EOR A3,R16                  ; Нет, вычисляем модуль NUM=|NUM| И
            LDI R16,0x2D                ; Начинаем строку со знака '-'.
            ST X+,R16                   ; *STR++='-'.

            ;
            ; Извлечение цифры целой части.
GETINT:     PUSH A3                     ; Бэкапим исходный NUM.
            PUSH A2                     ;
            PUSH A1                     ;
            PUSH A0                     ;
            CALL FTOI                   ; A0=DIGIT=INT(NUM).
            
            LDI R16,0x30                ; *STR++=ASCII(DIGIT).
            ADD R16,A0                  ;
            ST X+,R16                   ;

            CALL ITOF                   ; A=FDIGIT=FLOAT(DIGIT). Извлеченную цифру имеем теперь не как целое, а как число в float32.

            MOV B0,A0                   ; B=A=FDIGIT.
            MOV B1,A1                   ;
            MOV B2,A2                   ;
            MOV B3,A3                   ;

            POP A0                      ; A=NUM.
            POP A1                      ;
            POP A2                      ;
            POP A3                      ;

            CALL FSUB32                 ; A=NUM=FSUB32(NUM,FDIGIT). Теперь из NUM удален целочисленный десятичный разряд, цифру которого мы извлекли.

            ;
            ; Добавление десятичной точки.
            LDI R16,0x2E                ; *STR++='.'.
            ST X+,R16                   ;

            ;
            ; Извлечение дробных десятичных разрядов.
            ;
            ; Входное значение NUM<1.
            ; Двоичная экспонента после умножения на 10 лежит в [-123,3]
            ; или [4,130] в коде со смещением.
GETFRAC:    LDI R16,TEN0                ; B=10.0F.
            LDI R17,TEN1                ;
            LDI R18,TEN2                ;
            LDI R19,TEN3                ;
            MOV B0,R16                  ;
            MOV B1,R17                  ;
            MOV B2,R18                  ;
            MOV B3,R19                  ;

            CALL FMUL32                 ; A=NUM'=FMUL32(NUM,10.0F). После GETINT - A=NUM, NUM<1.

            PUSH A3                     ; Бэкапим NUM',
            PUSH A2                     ; Поскольку далее будем распаковывать его экспоненту.
            PUSH A1                     ;
            PUSH A0                     ;

            ROL A2                      ; Если экспонента лежит в [127,130],
            ROL A3                      ; то разность положительная и всегда даст бит переноса
            LDI R16,-127                ; в старший байт, где занулятся биты истинного доп. кода -127.
            ADD R16,A3                  ; NUM' лежит в [0,1)? (Если NUM' равен нулю, то экспонента равна нулю (в коде со смещением), что также даст отрицательную разность, поэтому и это условие оказывается уже покрытым.)
            BRCS ASCIIDIG1              ; Нет, в целой части десятичный дробный разряд, определяем его цифру.
            LDI R16,0x30                ; Да, очередной дробный разряд нулевой, устанавливаем цифру ноль.
            ST X+,R16                   ; *STR++='0'.

            POP A0                      ; A=NUM'.
            POP A1                      ; Восстанавливаем состояние, ожидаемое в COND1.
            POP A2                      ; В стеке - PRECISION.
            POP A3                      ;

            RJMP COND1                  ;

ASCIIDIG1:  POP A0                      ; A=NUM', сейчас NUM' - десятичная нормализованная дробь.
            POP A1                      ; Восстанавливаем исходное значение,
            POP A2                      ; Не поврежденное распаковкой экспоненты.
            POP A3                      ;

            PUSH A3                     ; Снова бэкапим NUM',
            PUSH A2                     ; Поскольку далее нам нужно будет
            PUSH A1                     ; удалить из него целую часть.
            PUSH A0                     ;

            CALL FTOI                   ; A0=DIGIT=INT(NUM').

            LDI R16,0x30                ; *STR++=ASCII(DIGIT).
            ADD R16,A0                  ;
            ST X+,R16                   ;

            CALL ITOF                   ; A=FDIGIT=FLOAT(DIGIT).

            MOV B0,A0                   ; B=A=FDIGIT.
            MOV B1,A1                   ;
            MOV B2,A2                   ;
            MOV B3,A3                   ;

            POP A0                      ; A=NUM'.
            POP A1                      ;
            POP A2                      ;
            POP A3                      ;

                                        ; Убираем извлеченный дробный разряд из целой части NUM'.
            CALL FSUB32                 ; A=NUM=FSUB32(NUM',FDIGIT). Теперь снова NUM<1.

COND1:      POP R16                     ; R16=PRECISION.
            DEC R16                     ; PRECISION--. Извлекли заданное число дробных разрядов?
            BREQ EXITFTOAN              ; Да, STR содержит десятичные цифры числа NUM, стек - адрес возврата.
            PUSH R16                    ; Нет, снова бэкапим PRECISION и
            RJMP GETFRAC                ; Извлекаем следующий десятичный дробный разряд.

EXITFTOAN:  LDI R16,0                   ;
            ST X,R16                    ; Добавляем конец строки '\0'.
            RET

;
; Формирует ASCII-строку с десятичным представлением переменной типа float в экспоненциальной форме.
;
; Если число уже нормализовано десятично, то просто выполняется конвертация в строку через FTOAN
; с учётом ограничения на максимальную длину строки MAXLEN.
;
; Иначе выполняется десятичная нормализация числа, затем происходит конвертация нормализованного числа
; в строку через FTOAN, но с ограниченным количеством знаков после точки, таким, чтобы длина результирующей
; строки (вместе со знаком минуса, десятичной точкой и экспонентой) не превысила MAXLEN.
;
; Аргументы:
;   - NUM - число, ожидается в регистрах: R11, R10, R9, R8.
;   - MAXLEN - максимальная длина выходной строки, ожидается в регистре R12. Сейчас ожидается значение 16 - кол-во символов в LCD1602.
;   - STR - указатель на область SRAM, куда будет записана ASCII-строка. ожидается в XH:XL.
            .DEF EXP=R0                 ; Показатель степени в экспоненциальной записи.

            .DEF A0=R8                  ; Первый операнд любой арифметической операции: FDIV32,FMUL32,FADD32,FSUB32.
            .DEF A1=R9                  ; Также - входной операнд NUM.
            .DEF A2=R10                 ;
            .DEF A3=R11                 ;

            .DEF MAXLEN=R12             ; Максимальная длина выходной строки с десятичным представлением NUM.

            .DEF B0=R12                 ; Второй операнд любой арифметической операции: FDIV32,FMUL32,FADD32,FSUB32.
            .DEF B1=R13                 ;
            .DEF B2=R14                 ;
            .DEF B3=R15                 ;

            .DEF TMP0=R22               ; Может быть использован для временного хранения float32.
            .DEF TMP1=R23               ;
            .DEF TMP2=R24               ;
            .DEF TMP3=R25               ;
            
FTOAE:      PUSH MAXLEN                 ; Бэкапим MAXLEN.

            CLR EXP                     ; EXP=0.

            PUSH A3                     ; Бэкапим старшие два байта NUM.
            PUSH A2                     ;
            ROL A2                      ; Распаковываем экспоненту NUM.
            ROL A3                      ;
            LDI R16,-127                ;
            ADD R16,A3                  ;
            POP A2                      ; Восстанавливаем старшие два байта NUM вместо тех, которые "пострадали" при распаковке экспоненты.
            POP A3                      ; Экспонента в коде со смещением лежит в [1,126]? 
            BRMI NORMLFT                ; Да, значит истинная экспонента лежит в [-126,-1], а это значит, что NUM<1 и INT(NUM)=0 - нормализуем влево.

NORMRGHT:   PUSH A3                     ; Нет, NUM>=1, значит NUM либо уже нормализован, либо денормализован влево (тогда нормализуем вправо).
            PUSH A2                     ; Бэкапим текущее значение NUM.
            PUSH A1                     ; Возможно, что оно уже нормализовано.
            PUSH A0                     ;

            LDI R16,TEN0                ; B=10.0F.
            LDI R17,TEN1                ;
            LDI R18,TEN2                ;
            LDI R19,TEN3                ;
            MOV B0,R16                  ;
            MOV B1,R17                  ;
            MOV B2,R18                  ;
            MOV B3,R19                  ;

            PUSH EXP                    ;
            CALL FDIV32                 ; A=NUM=FDIV32(NUM,10.0F).
            POP EXP                     ;

            PUSH A3                     ; Бэкапим старшие два байта NUM.
            PUSH A2                     ;
            ROL A2                      ; Распаковываем экспоненту NUM.
            ROL A3                      ;
            LDI R16,-127                ;
            ADD R16,A3                  ;
            POP A2                      ; Восстанавливаем старший байт NUM, искаженный извлечением экспоненты.
            POP A3                      ; Экспонента в коде со смещением лежит в [1,126]?
            BRMI RESTNORM               ; Да, значит истинная экспонента лежит в [-126,-1], а это значит, что NUM<1 и предыдущее значение до деления на 10 уже было нормализованным.
            
            INC EXP                     ; Нет, NUM>=1, значит предыдущее значение не было нормализованным. Запоминаем очередное понижение порядка NUM.

            POP R16                     ; Удаляем предыдущее значение NUM.
            POP R16                     ;
            POP R16                     ;
            POP R16                     ;
            RJMP NORMRGHT               ;

RESTNORM:   POP A0                      ; Восстанавливаем последнее значение NUM, которое уже нормализовано.
            POP A1                      ;
            POP A2                      ;
            POP A3                      ;
            RJMP CONVMANT               ;

NORMLFT:    CLR R16                     ;
            OR R16,A0                   ;
            OR R16,A1                   ;
            OR R16,A2                   ;
            OR R16,A3                   ; NUM=0.0F?
            BREQ CONVMANT               ; Да, NUM=0.0F - FTOAN обработает ноль корректно и вернет строку с символом нуля. EXP тоже остаётся равен нулю. 

            LDI R16,TEN0                ; B=10.0F.
            LDI R17,TEN1                ;
            LDI R18,TEN2                ;
            LDI R19,TEN3                ;
            MOV B0,R16                  ;
            MOV B1,R17                  ;
            MOV B2,R18                  ;
            MOV B3,R19                  ;

            PUSH EXP                    ;
            CALL FMUL32                 ; A=NUM=FMUL32(NUM,10.0F).
            POP EXP                     ;
            INC EXP                     ; EXP++.

            PUSH A3                     ;
            PUSH A2                     ;
            ROL A2                      ;
            ROL A3                      ;
            LDI R16,-127                ;
            ADD R16,A3                  ;
            POP A2                      ; Восстанавливаем NUM.
            POP A3                      ; NUM>=1?
            BRMI NORMLFT                ; Нет, продолжаем нормализацию.

            LDI R16,0b10000000          ; EXP=-EXP. Представляем отрицательную экспоненту в прямом коде.
            OR EXP,R16                  ;

            ;
            ; Конвертация десятичной мантиссы в строку.
            ;
            ; NOTE: Мы нормализовали NUM (если он не был нормализован изначально) и это значение представляет теперь
            ; мантиссу в десятичной экспоненциальной записи.
CONVMANT:   POP MAXLEN                  ; Извлекаем аргумент MAXLEN.

            AND EXP,EXP                 ; EXP=0?
            BREQ CHKSGN                 ; Да, число NUM уже нормализовано, экспоненциальная форма не требуется.

            LDI R16,-4                  ; Нет, резервируем в строке 4 места под экспоненту: E{+|-}00.
            ADD MAXLEN,R16              ; MAXLEN=MAXLEN-4.

CHKSGN:     LDI R16,0b10000000          ; Маска знака.
            AND R16,A3                  ; NUM<0?
            BRNE NUMNEG                 ; Да, резервируем в выходной строке один символ под '-'.
            
            LDI R16,-2                  ; Нет, резервируем только два места под цифру целой части и точку.
            ADD MAXLEN,R16              ; MAXLEN=MAXLEN-2.
            RJMP CALLFTOAN              ;

NUMNEG:     LDI R16,-2-1                ; Два места под цифру целой части и точку и еще одно место - под символ минуса '-'.
            ADD MAXLEN,R16              ; MAXLEN=(MAXLEN-2)-1.

CALLFTOAN:  PUSH EXP                    ;
            CALL FTOAN                  ; STR=FTOAN(NUM,MAXLEN). MAXLEN после вычислений фактически содержит PRECISION,
            POP EXP                     ; Который гарантирует, что не будет превышения исходного значения MAXLEN.

            AND EXP,EXP                 ; EXP=0?
            BREQ EXITFTOAE              ; Да, выходим.

            LDI R16,'E'                 ; Нет, формируем экспоненциальную запись.
            ST X+,R16                   ; STR+='E'.

            ROL EXP                     ; EXP<0? (Отрицательная экспонента представлена в прямом коде).
            BRCC SETPLUS                ; Нет, EXP>0, устанавливаем знак '+'.
            LDI R16,'-'                 ; Да, устанавливаем знак '-'.
            ST X+,R16                   ;
            RJMP EXPTOSTR               ;
SETPLUS:    LDI R16,'+'                 ;
            ST X+,R16                   ;

            ;
            ; Конвертация экспоненты в строку.
            ;
            ; Если экспонента не равна нулю, то модуль экспоненты лежит в [1,38].
            ; Это значит, что неполное частное от деления на 10 не превышает 3 (0b00000011).
            ; А остаток по определению меньше делителя и лежит в [0,9].
            ; Таким образом, после деления экспоненты на 10 неполное частное содержит старшую десятичную цифру экспоненты,
            ; а остаток - младшую.
EXPTOSTR:   CLC                         ; EXP=|EXP|.
            ROR EXP                     ;

            LDI R18,2                   ; Поскольку частное не больше 3, то количество проверяемых двоичных цифр равно двум.

            CLR R17                     ; Здесь формируются цифры частного.

            LDI R16,-(10*2)             ; Q[i]=2=0b00000010. Сразу формируем в доп. коде.
REPEAT:     ADD EXP,R16                 ; EXP-(10*Q[I])>=0?
            BRPL SET1                   ; Да, цифра частного Q[i] равна единице.
            RJMP SET0                   ; Нет, цифра Q[i] равна нулю.

SET1:       SEC                         ; Устанавливаем текущий разряд частного в 1.
            ROL R17                     ;

            DEC R18                     ; Определены обе двоичные цифры частного?
            BREQ SETDECDIG              ; Да, частное содержит старшую десятичную цифру экспонента, а EXP - младшую.
            LDI R16,-(10*1)             ; Нет, определяем младшую цифру частного.
            RJMP REPEAT                 ; Q[i]=1=0b00000001.

SET0:       CLC                         ; Устанавливаем текущий разряд частного в 0.
            ROL R17                     ;

            DEC R18                     ; Определены обе двоичные цифры частного?
            BREQ RESTREM                ; Да, частное содержит старшую десятичную цифру экспонента, а EXP после восстановления остатка - младшую.
            LDI R16,10                  ; Нет, определяем младшую цифру частного.
            RJMP REPEAT                 ; Новый остаток вычисляется без восстановления: (EXP+20)-10=EXP+10.
            
RESTREM:    LDI R16,10                  ; Восстанавливаем последний положительный остаток.
            ADD EXP,R16                 ;

SETDECDIG:  LDI R16,0x30                ; R16='0'.

            OR R17,R16                  ; Формируем ASCII-код старшей десятичной цифры экспоненты.
            ST X+,R17                   ; Добавляем в строку.
            
            OR EXP,R16                  ; Формируем ASCII-код младшей десятичной цифры экспоненты.
            ST X+,EXP                   ; Добавляем в строку.

            LDI R16,0                   ; R16='\0'.
            ST X,R16                    ; Добавляем конец строки.

EXITFTOAE:  RET

;
; Преобразует ASCII-строку с десятичной дробью в бинарный float.
;
; В основе лежит наивный алгоритм из [Kernighan & Ritchie, The C Programming Language],
; который в общем случае даёт не лучшее двоичное приближение к входному десятичному числу.
;
; Основная идея та же, что и для FTOA - мы просто игнорируем тот факт, что десятичное представление
; исходной двоичной дроби искажается при её масштабировании и умножаем двоичную дробь на 10 так,
; словно мы непосредственно умножаем её десятичное представление, игнорируя искажения некоторых разрядов
; нового десятичного представления отмасштабированной двоичной дроби.
;
; NOTE: Поскольку в текущей реализации нет поддержки отрицательного нуля, то при получении на вход
; строки "-0" происходит формирование положительного нуля.
;
; NOTE: Исключение при делении на ноль здесь невозможно.
; А переполнение может произойти только в следующих случаях:
;   - Переполнение NUM в FMUL32 при обработке целой части.
;   - Переполнение NUM в FMUL32 при обработке дробной части.
;   - Переполнение OVERSCALE в FMUL32 при обработке дробной части.
; 
; Переполнение NUM в FADD32 при обработке целой части не может произойти.
;
; Доказательство:
; допустим, что это не так, тогда существует такое целое число, которое не даёт переполнения
; при масштабировании, когда мы извлекаем последний разряд - разряд единиц, но при этом даёт переполнение
; при прибавлении этого разряда к отмасштабированному NUM.
;
; Еще заметим, что максимальный порядок входной числовой строки - 10^38.
; То есть, любые числа, количество цифр в записи которых превышает 39, будут давать переполнение,
; Поэтому они сразу исключаются из рассмотрения.
; 
; Возьмем теперь значение 340282430000000000000000000000000000000, оно даёт переполнение в FMUL32
; уже при анализе самого младшего разряда. Следовательно, интересующее нас значение (если оно существует)
; меньше данного.
; Возьмем теперь значение на единицу меньше - 340282429999999999999999999999999999999.
; Оно не дает переполнения в FMUL32, но оно не даёт переполнения и в FADD32, когда мы прибавляем цифру из
; разряда единиц после масштабирования NUM (и прибавляем мы маскимальное значение - 9).
; Следовательно, если значение, которое даёт переполнение только в FADD32, существует, то
; оно явно должно быть меньше первого (чтобы не давать переполнения в FMUL32), но при этом
; оно должно быть больше второго (чтобы давать переполнение при прибавлении числа из разряда единиц).
; Но между 340282429999999999999999999999999999999 и 340282430000000000000000000000000000000
; не существует других целых чисел, т.е. такого значения попросту не существует.
; 
; Переполнение NUM в FADD32 при обработке дробной части не может произойти по тем же соображениям:
; достаточно заметить, что количество цифр в дробной части не должно превышать 38, чтобы
; не было переполнения OVERSCALE и по аналогии начать рассмотрение с дроби 3.40282430000000000000000000000000000000.
; Более детальные рассуждения относительно граничных входных значений десятичных числовых строк можно найти
; в основной доке.
;
; Аргументы:
;   - STR - указатель на ASCII-строку с нулём в конце, ожидается в XH:XL.
; 
; Результат:
;   - NUM - число в формате плавающей точки, помещается в R11, R10, R9, R8.
            .EQU ONE0=0x00              ; 1.0F.
            .EQU ONE1=0x00              ;
            .EQU ONE2=0x80              ;
            .EQU ONE3=0x3F              ;

            .DEF A0=R8                  ; Первый операнд любой арифметической операции: FDIV32,FMUL32,FADD32,FSUB32.
            .DEF A1=R9                  ;
            .DEF A2=R10                 ;
            .DEF A3=R11                 ;

            .DEF B0=R12                 ; Второй операнд любой арифметической операции: FDIV32,FMUL32,FADD32,FSUB32.
            .DEF B1=R13                 ;
            .DEF B2=R14                 ;
            .DEF B3=R15                 ;

            .DEF TMP0=R22               ; Может быть использован для временного хранения float32.
            .DEF TMP1=R23               ;
            .DEF TMP2=R24               ;
            .DEF TMP3=R25               ;

ATOF:       PUSH ZL                     ; Бэкапим адрес обработчика исключений во внешнем коде,
            PUSH ZH                     ; Поскольку сначала мы перехватываем исключение здесь, внутри ATOF.

            LDI ZL,LOW(FLOATERR0)       ; Устанавливаем обработчик исключений для первого FMUL32.
            LDI ZH,HIGH(FLOATERR0)      ;
            RJMP INITNUM                ;
FLOATERR0:  POP R16                     ; Выбрасываем из стека адрес возврата.
            POP R16                     ;
            POP R16                     ; Выбрасываем DIGIT.
            POP R16                     ; Выбрасываем SIGN.
            POP ZH                      ; Восстанавливаем адрес обработчика исключений во внешнем коде.
            POP ZL                      ; В стеке остался только адрес возврата во внешнем коде после вызова ATOF.
            IJMP                        ; Передаём управление во внешний обработчик исключений.

INITNUM:    CLR A0                      ; A=NUM=0.0F.
            CLR A1                      ;
            CLR A2                      ;
            CLR A3                      ;

            ;
            ; Определение знака числа.
            LD R16,X                    ;
            LDI R17,'-'                 ;
            EOR R16,R17                 ; Первый символ числовой строки - минус?
            BREQ MINUS                  ; Да, формируем отрицательный знак результата и пропускаем первый символ.
            CLR R16                     ; Нет, знак NUM БУДЕТ положительным - MSB старшего байта NUM будет нулевым.
            PUSH R16                    ;
            RJMP GETINT1                ;

MINUS:      LD R16,X+                   ; Пропускаем знак минуса и смещаемся к следующему символу.
            LDI R16,0b10000000          ; MSB старшего байта NUM будет содержать единицу.
            PUSH R16                    ; Сохраняем SIGN в стеке до конца вычислений.

            ;
            ; Формирование целой части.
GETINT1:    LD R16,X+                   ; R16=DIGIT=*STR++.
            AND R16,R16                 ; Прочитали конец строки?
            BREQ EXITATOF               ; Да, выходим.
            LDI R17,0x2E                ; Нет.
            EOR R17,R16                 ; Прочитали точку?
            BREQ GETFRAC1               ; Да, переходим к дробной части.
                                        ; Нет, продолжаем формировать целую часть.
            LDI R17,TEN0                ; B=10.0F
            LDI R18,TEN1                ;
            LDI R19,TEN2                ;
            LDI R20,TEN3                ;
            MOV B0,R17                  ;
            MOV B1,R18                  ;
            MOV B2,R19                  ;
            MOV B3,R20                  ;

            PUSH R16                    ; Если это не первая цифра, значит порядок NUM выше, чем мы предположили.
            CALL FMUL32                 ; A=NUM=FMUL32(NUM,10.0F).
            POP R16                     ;

            PUSH A3                     ; Бэкапим NUM.
            PUSH A2                     ;
            PUSH A1                     ;
            PUSH A0                     ;

            LDI R17,0x0F                ; Извлекаем из ASCII кода цифры обозначаемое ею число.
            AND R16,R17                 ; R16=DIGIT-0x30.
            MOV A0,R16                  ; R8=DIGIT.
            CALL ITOF                   ; A=FDIGIT=FLOAT(DIGIT).
            MOV B0,A0                   ; B=FDIGIT.
            MOV B1,A1                   ;
            MOV B2,A2                   ;
            MOV B3,A3                   ;

            POP A0                      ; A=NUM.
            POP A1                      ;
            POP A2                      ;
            POP A3                      ;

                                        ; Предполагаем, что прочитанная цифра последняя в целой части и т.о. представляет разряд единиц.
            CALL FADD32                 ; A=NUM=NUM+FDIGIT.

            RJMP GETINT1

            ;
            ; Выходим из ATOF.
EXITATOF:   CLR R16                     ;
            OR R16,A0                   ;
            OR R16,A1                   ;
            OR R16,A2                   ;
            OR R16,A3                   ; Ноль?
            BRNE SETSIGN                ; Нет, устанавливаем знак.
            POP R16                     ; Да, удаляем знак из стека.
            POP R16                     ; Удаляем адрес обработчика исключений.
            POP R16                     ;
            RET                         ; Возвращаем положительный ноль.

SETSIGN:    POP R16                     ; R16=SIGN.
            EOR A3,R16                  ; Устанавливаем знак NUM.

            POP R16                     ; ATOF отработал без исключений.
            POP R16                     ; Адрес обработчика исключений в вызывающем коде больше не нужен - удаляем его из стека.
            RET                         ; В стеке остался только адрес возврата после ATOF.

            ;
            ; Формирование дробной части.
DWNSCALE:   POP B0                      ; B=OVERSCALE.
            POP B1                      ;
            POP B2                      ;
            POP B3                      ;
                                        
                                        ; Восстанавливаем истинный порядок числа NUM после извлечения дробной части.
            CALL FDIV32                 ; A=NUM=FDIV32(NUM,OVERSCALE).

            RJMP EXITATOF               ;

GETFRAC1:   LDI R16,ONE3                ; OVERSCALE=1.0F.
            LDI R17,ONE2                ;
            LDI R18,ONE1                ;
            LDI R19,ONE0                ;
            PUSH R16                    ;
            PUSH R17                    ;
            PUSH R18                    ;
            PUSH R19                    ;

            LDI ZL,LOW(FLOATERR1)       ; Устанавливаем обработчик исключений для второго FMUL32, который масштабирует NUM.
            LDI ZH,HIGH(FLOATERR1)      ; Этот же обработчик корректно сработает при переполнении на третьем FMUL32, Который масштабирует OVERSCALE.
            RJMP GETFRAC2               ;
FLOATERR1:  POP R16                     ; Выбрасываем адрес возврата.
            POP R16                     ;
            POP R16                     ; Выбрасываем DIGIT.
            POP R16                     ; Выбрасываем 4 байта константы 1.0f в формате float32 (в случае переполнения при масштабировании NUM - второй FMUL32)
            POP R16                     ; Или 4 байта отмасштабированного с избытком NUM (в случае переполнения при масштабировании OVERSCALE - третий FMUL32).
            POP R16                     ; NOTE: Конечно, можно сразу "спустить" указатель стека в нужное место, а не делать POP для каждого элемента. Но этот способ выбран для простоты и наглядности.
            POP R16                     ;
            POP R16                     ; Выбрасываем SIGN.
            POP ZH                      ; Восстанавливаем адрес обработчика исключений во внешнем коде.
            POP ZL                      ; В стеке остался только адрес возврата во внешнем коде после вызова ATOF.
            IJMP                        ; Передаём управление во внешний обработчик исключений.

GETFRAC2:   LD R16,X+                   ; R16=DIGIT=*STR++.
            AND R16,R16                 ; Прочитали конец строки?
            BREQ DWNSCALE               ; Да, восстанавливаем порядок NUM.
                                        ; Нет, продолжаем извлекать дробные разряды.
            LDI R17,TEN0                ; B=10.0F.
            LDI R18,TEN1                ;
            LDI R19,TEN2                ;
            LDI R20,TEN3                ;
            MOV B0,R17                  ;
            MOV B1,R18                  ;
            MOV B2,R19                  ;
            MOV B3,R20                  ;

            PUSH R16                    ; Завышаем порядок NUM, чтобы текущая цифра представляла разряд единиц.
            CALL FMUL32                 ; A=NUM=FMUL32(NUM,10.0F).
            POP R16                     ;

            POP TMP0                    ; TMP=OVERSCALE.
            POP TMP1                    ;
            POP TMP2                    ;
            POP TMP3                    ;

            PUSH A3                     ; Бэкапим NUM.
            PUSH A2                     ;
            PUSH A1                     ;
            PUSH A0                     ;

            PUSH R16                    ; Бэкапим DIGIT.

            MOV A0,TMP0                 ; A=TMP=OVERSCALE.
            MOV A1,TMP1                 ;
            MOV A2,TMP2                 ;
            MOV A3,TMP3                 ;

            LDI R16,TEN0                ; B=10.0F.
            LDI R17,TEN1                ;
            LDI R18,TEN2                ;
            LDI R19,TEN3                ;
            MOV B0,R16                  ;
            MOV B1,R17                  ;
            MOV B2,R18                  ;
            MOV B3,R19                  ; 

                                        ; Отслеживаем степень завышения истинного порядка NUM.
            CALL FMUL32                 ; A=OVERSCALE=FMUL32(OVERSCALE,10.0F).
            MOV TMP0,A0                 ; TMP=A=OVERSCALE.
            MOV TMP1,A1                 ;
            MOV TMP2,A2                 ;
            MOV TMP3,A3                 ;

            POP R16                     ; R16=DIGIT.

            POP A0                      ; A=NUM.
            POP A1                      ;
            POP A2                      ;
            POP A3                      ;

            PUSH TMP3                   ; Бэкапим OVERSCALE.
            PUSH TMP2                   ;
            PUSH TMP1                   ;
            PUSH TMP0                   ;

            PUSH A3                     ; Бэкапим NUM.
            PUSH A2                     ;
            PUSH A1                     ;
            PUSH A0                     ;

            LDI R17,0x0F                ; Извлекаем из ASCII-кода цифры обозначаемое ею число.
            AND R16,R17                 ; R16=DIGIT-0x30.
            MOV A0,R16                  ; R8=DIGIT.
            CALL ITOF                   ; A=FDIGIT=FLOAT(DIGIT).
            MOV B0,A0                   ; B=FDIGIT.
            MOV B1,A1                   ;
            MOV B2,A2                   ;
            MOV B3,A3                   ;

            POP A0                      ; A=NUM.
            POP A1                      ;
            POP A2                      ;
            POP A3                      ;

            CALL FADD32                 ; A=NUM=NUM+FDIGIT.

            RJMP GETFRAC2               ;
